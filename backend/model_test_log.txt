============================= test session starts ==============================
platform darwin -- Python 3.13.2, pytest-8.3.5, pluggy-1.5.0 -- /Users/cburr/Library/Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/bin/python
cachedir: .pytest_cache
django: version: 5.1.6, settings: config.settings (from ini)
rootdir: /Users/cburr/Library/CloudStorage/OneDrive-TheAlanTuringInstitute/repositories/tea-techniques/backend
configfile: pyproject.toml
plugins: django-4.10.0, cov-4.1.0, Faker-23.3.0
collecting ... collected 13 items

api/tests/test_models.py::ModelTestCase::test_assurance_goal_creation ERROR [  7%]
api/tests/test_models.py::ModelTestCase::test_attribute_type_creation ERROR [ 15%]
api/tests/test_models.py::ModelTestCase::test_attribute_value_creation ERROR [ 23%]
api/tests/test_models.py::ModelTestCase::test_category_creation ERROR    [ 30%]
api/tests/test_models.py::ModelTestCase::test_resource_type_creation ERROR [ 38%]
api/tests/test_models.py::ModelTestCase::test_subcategory_creation ERROR [ 46%]
api/tests/test_models.py::ModelTestCase::test_tag_creation ERROR         [ 53%]
api/tests/test_models.py::ModelTestCase::test_technique_attribute_relationship ERROR [ 61%]
api/tests/test_models.py::ModelTestCase::test_technique_creation ERROR   [ 69%]
api/tests/test_models.py::ModelTestCase::test_technique_limitation_relationship ERROR [ 76%]
api/tests/test_models.py::ModelTestCase::test_technique_relationships ERROR [ 84%]
api/tests/test_models.py::ModelTestCase::test_technique_resource_relationship ERROR [ 92%]
api/tests/test_models.py::ModelTestCase::test_technique_use_case_relationship ERROR [100%]

==================================== ERRORS ====================================
_________ ERROR at setup of ModelTestCase.test_assurance_goal_creation _________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_assurance_goal_creation>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106d95d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
---------------------------- Captured stderr setup -----------------------------
Creating test database for alias 'default'...
_________ ERROR at setup of ModelTestCase.test_attribute_type_creation _________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_assurance_goal_creation>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106d95d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
________ ERROR at setup of ModelTestCase.test_attribute_value_creation _________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_assurance_goal_creation>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106d95d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
____________ ERROR at setup of ModelTestCase.test_category_creation ____________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_assurance_goal_creation>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106d95d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
_________ ERROR at setup of ModelTestCase.test_resource_type_creation __________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_assurance_goal_creation>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106d95d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
__________ ERROR at setup of ModelTestCase.test_subcategory_creation ___________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_assurance_goal_creation>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106d95d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
______________ ERROR at setup of ModelTestCase.test_tag_creation _______________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_assurance_goal_creation>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106d95d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
____ ERROR at setup of ModelTestCase.test_technique_attribute_relationship _____

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_assurance_goal_creation>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106d95d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
___________ ERROR at setup of ModelTestCase.test_technique_creation ____________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_assurance_goal_creation>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106d95d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
____ ERROR at setup of ModelTestCase.test_technique_limitation_relationship ____

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_assurance_goal_creation>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106d95d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
_________ ERROR at setup of ModelTestCase.test_technique_relationships _________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_assurance_goal_creation>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106d95d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
_____ ERROR at setup of ModelTestCase.test_technique_resource_relationship _____

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_assurance_goal_creation>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106d95d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
_____ ERROR at setup of ModelTestCase.test_technique_use_case_relationship _____

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_assurance_goal_creation>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106d95d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x1194d1950>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
=============================== warnings summary ===============================
api/tests/test_models.py::ModelTestCase::test_assurance_goal_creation
  /Users/cburr/Library/Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:512: RuntimeWarning: Normally Django will use a connection to the 'postgres' database to avoid running initialization queries against the production database when it's not needed (for example, when running tests). Django was unable to create a connection to the 'postgres' database and will use the first PostgreSQL database instead.
    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
ERROR api/tests/test_models.py::ModelTestCase::test_assurance_goal_creation
ERROR api/tests/test_models.py::ModelTestCase::test_attribute_type_creation
ERROR api/tests/test_models.py::ModelTestCase::test_attribute_value_creation
ERROR api/tests/test_models.py::ModelTestCase::test_category_creation - djang...
ERROR api/tests/test_models.py::ModelTestCase::test_resource_type_creation - ...
ERROR api/tests/test_models.py::ModelTestCase::test_subcategory_creation - dj...
ERROR api/tests/test_models.py::ModelTestCase::test_tag_creation - django.db....
ERROR api/tests/test_models.py::ModelTestCase::test_technique_attribute_relationship
ERROR api/tests/test_models.py::ModelTestCase::test_technique_creation - djan...
ERROR api/tests/test_models.py::ModelTestCase::test_technique_limitation_relationship
ERROR api/tests/test_models.py::ModelTestCase::test_technique_relationships
ERROR api/tests/test_models.py::ModelTestCase::test_technique_resource_relationship
ERROR api/tests/test_models.py::ModelTestCase::test_technique_use_case_relationship
======================== 1 warning, 13 errors in 1.79s =========================
