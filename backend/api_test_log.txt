============================= test session starts ==============================
platform darwin -- Python 3.13.2, pytest-8.3.5, pluggy-1.5.0 -- /Users/cburr/Library/Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/bin/python
cachedir: .pytest_cache
django: version: 5.1.6, settings: config.settings (from ini)
rootdir: /Users/cburr/Library/CloudStorage/OneDrive-TheAlanTuringInstitute/repositories/tea-techniques/backend
configfile: pyproject.toml
plugins: django-4.10.0, cov-4.1.0, Faker-23.3.0
collecting ... collected 23 items

api/tests/test_api.py::ApiEndpointTestCase::test_api_root ERROR          [  4%]
api/tests/test_api.py::ApiEndpointTestCase::test_assurance_goals_list ERROR [  8%]
api/tests/test_api.py::ApiEndpointTestCase::test_attribute_types_list ERROR [ 13%]
api/tests/test_api.py::ApiEndpointTestCase::test_attribute_values_list ERROR [ 17%]
api/tests/test_api.py::ApiEndpointTestCase::test_categories_list ERROR   [ 21%]
api/tests/test_api.py::ApiEndpointTestCase::test_resource_types_list ERROR [ 26%]
api/tests/test_api.py::ApiEndpointTestCase::test_subcategories_list ERROR [ 30%]
api/tests/test_api.py::ApiEndpointTestCase::test_tags_list ERROR         [ 34%]
api/tests/test_api.py::ApiEndpointTestCase::test_techniques_list ERROR   [ 39%]
api/tests/test_api.py::TechniqueAPITestCase::test_create_technique ERROR [ 43%]
api/tests/test_api.py::TechniqueAPITestCase::test_debug_endpoint ERROR   [ 47%]
api/tests/test_api.py::TechniqueAPITestCase::test_delete_technique ERROR [ 52%]
api/tests/test_api.py::TechniqueAPITestCase::test_filter_techniques_by_assurance_goal ERROR [ 56%]
api/tests/test_api.py::TechniqueAPITestCase::test_filter_techniques_by_category ERROR [ 60%]
api/tests/test_api.py::TechniqueAPITestCase::test_filter_techniques_by_model_dependency ERROR [ 65%]
api/tests/test_api.py::TechniqueAPITestCase::test_filter_techniques_by_search ERROR [ 69%]
api/tests/test_api.py::TechniqueAPITestCase::test_filter_techniques_by_tag ERROR [ 73%]
api/tests/test_api.py::TechniqueAPITestCase::test_get_technique_detail ERROR [ 78%]
api/tests/test_api.py::TechniqueAPITestCase::test_get_technique_list ERROR [ 82%]
api/tests/test_api.py::TechniqueAPITestCase::test_pagination ERROR       [ 86%]
api/tests/test_api.py::TechniqueAPITestCase::test_partial_update_technique ERROR [ 91%]
api/tests/test_api.py::TechniqueAPITestCase::test_relation_specific_endpoints ERROR [ 95%]
api/tests/test_api.py::TechniqueAPITestCase::test_update_technique ERROR [100%]

==================================== ERRORS ====================================
_____________ ERROR at setup of ApiEndpointTestCase.test_api_root ______________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_api_root>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
---------------------------- Captured stderr setup -----------------------------
Creating test database for alias 'default'...
_______ ERROR at setup of ApiEndpointTestCase.test_assurance_goals_list ________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_api_root>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
_______ ERROR at setup of ApiEndpointTestCase.test_attribute_types_list ________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_api_root>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
_______ ERROR at setup of ApiEndpointTestCase.test_attribute_values_list _______

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_api_root>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
__________ ERROR at setup of ApiEndpointTestCase.test_categories_list __________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_api_root>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
________ ERROR at setup of ApiEndpointTestCase.test_resource_types_list ________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_api_root>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
________ ERROR at setup of ApiEndpointTestCase.test_subcategories_list _________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_api_root>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
_____________ ERROR at setup of ApiEndpointTestCase.test_tags_list _____________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_api_root>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
__________ ERROR at setup of ApiEndpointTestCase.test_techniques_list __________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_api_root>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
_________ ERROR at setup of TechniqueAPITestCase.test_create_technique _________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_create_technique>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
__________ ERROR at setup of TechniqueAPITestCase.test_debug_endpoint __________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_create_technique>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
_________ ERROR at setup of TechniqueAPITestCase.test_delete_technique _________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_create_technique>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
_ ERROR at setup of TechniqueAPITestCase.test_filter_techniques_by_assurance_goal _

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_create_technique>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
__ ERROR at setup of TechniqueAPITestCase.test_filter_techniques_by_category ___

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_create_technique>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
_ ERROR at setup of TechniqueAPITestCase.test_filter_techniques_by_model_dependency _

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_create_technique>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
___ ERROR at setup of TechniqueAPITestCase.test_filter_techniques_by_search ____

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_create_technique>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
_____ ERROR at setup of TechniqueAPITestCase.test_filter_techniques_by_tag _____

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_create_technique>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
_______ ERROR at setup of TechniqueAPITestCase.test_get_technique_detail _______

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_create_technique>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
________ ERROR at setup of TechniqueAPITestCase.test_get_technique_list ________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_create_technique>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
____________ ERROR at setup of TechniqueAPITestCase.test_pagination ____________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_create_technique>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
_____ ERROR at setup of TechniqueAPITestCase.test_partial_update_technique _____

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_create_technique>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
___ ERROR at setup of TechniqueAPITestCase.test_relation_specific_endpoints ____

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_create_technique>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
_________ ERROR at setup of TechniqueAPITestCase.test_update_technique _________

self = <DatabaseWrapper vendor='postgresql' alias='__no_db__'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @contextmanager
    def _nodb_cursor(self):
        cursor = None
        try:
>           with super()._nodb_cursor() as cursor:

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:712: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=postgres client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'postgres', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

During handling of the above exception, another exception occurred:

self = <DatabaseWrapper vendor='postgresql' alias='default'>

    @async_unsafe
    def ensure_connection(self):
        """Guarantee that a connection to the database is established."""
        if self.connection is None:
            if self.in_atomic_block and self.closed_in_transaction:
                raise ProgrammingError(
                    "Cannot open a new connection in an atomic block."
                )
            with self.wrap_database_errors:
>               self.connect()

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_django_setup_unittest' for <TestCaseFunction test_create_technique>>
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x106645d30>

    @pytest.fixture(autouse=True, scope="class")
    def _django_setup_unittest(
        request: pytest.FixtureRequest,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        """Setup a django unittest, internal to pytest-django."""
        if not django_settings_is_configured() or not is_django_unittest(request):
            yield
            return
    
        # Fix/patch pytest.
        # Before pytest 5.4: https://github.com/pytest-dev/pytest/issues/5991
        # After pytest 5.4: https://github.com/pytest-dev/pytest-django/issues/824
        from _pytest.unittest import TestCaseFunction
    
        original_runtest = TestCaseFunction.runtest
    
        def non_debugging_runtest(self) -> None:
            self._testcase(result=self)
    
        from django.test import SimpleTestCase
    
        assert issubclass(request.cls, SimpleTestCase)  # Guarded by 'is_django_unittest'
        try:
            TestCaseFunction.runtest = non_debugging_runtest  # type: ignore[method-assign]
    
            # Don't set up the DB if the unittest does not require DB.
            # The `databases` propery seems like the best indicator for that.
            if request.cls.databases:
>               request.getfixturevalue("django_db_setup")

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/plugin.py:584: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/pytest_django/fixtures.py:144: in django_db_setup
    db_cfg = setup_databases(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/test/utils.py:206: in setup_databases
    connection.creation.create_test_db(
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:62: in create_test_db
    self._create_test_db(verbosity, autoclobber, keepdb)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/creation.py:202: in _create_test_db
    with self._nodb_cursor() as cursor:
/opt/homebrew/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:533: in _nodb_cursor
    with conn.cursor() as cursor:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:320: in cursor
    return self._cursor()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:296: in _cursor
    self.ensure_connection()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:278: in ensure_connection
    with self.wrap_database_errors:
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:279: in ensure_connection
    self.connect()
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/base/base.py:256: in connect
    self.connection = self.get_new_connection(conn_params)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/utils/asyncio.py:26: in inner
    return func(*args, **kwargs)
../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:332: in get_new_connection
    connection = self.Database.connect(**conn_params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'psycopg.Connection'>
conninfo = 'dbname=tea_techniques client_encoding=UTF8 user=tea_user password=tea_password host=localhost port=5432 hostaddr=127.0.0.1'
autocommit = False, prepare_threshold = None
context = <psycopg.adapt.AdaptersMap object at 0x108bc0910>, row_factory = None
cursor_factory = <class 'django.db.backends.postgresql.base.Cursor'>
kwargs = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
params = {'client_encoding': 'UTF8', 'dbname': 'tea_techniques', 'host': 'localhost', 'password': 'tea_password', ...}
timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -> Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        for attempt in attempts:
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e._NO_TRACEBACK as ex:
                if len(attempts) > 1:
                    logger.debug(
                        "connection attempt failed: host: %r port: %r, hostaddr %r: %s",
                        attempt.get("host"),
                        attempt.get("port"),
                        attempt.get("hostaddr"),
                        str(ex),
                    )
                last_ex = ex
            else:
                break
    
        if not rv:
            assert last_ex
>           raise last_ex.with_traceback(None)
E           django.db.utils.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: could not receive data from server: Connection refused
E           could not send SSL negotiation packet: Connection refused

../../../../../Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/psycopg/connection.py:117: OperationalError
=============================== warnings summary ===============================
api/tests/test_api.py::ApiEndpointTestCase::test_api_root
  /Users/cburr/Library/Caches/pypoetry/virtualenvs/tea-techniques-2IMDqGEM-py3.13/lib/python3.13/site-packages/django/db/backends/postgresql/base.py:512: RuntimeWarning: Normally Django will use a connection to the 'postgres' database to avoid running initialization queries against the production database when it's not needed (for example, when running tests). Django was unable to create a connection to the 'postgres' database and will use the first PostgreSQL database instead.
    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
ERROR api/tests/test_api.py::ApiEndpointTestCase::test_api_root - django.db.u...
ERROR api/tests/test_api.py::ApiEndpointTestCase::test_assurance_goals_list
ERROR api/tests/test_api.py::ApiEndpointTestCase::test_attribute_types_list
ERROR api/tests/test_api.py::ApiEndpointTestCase::test_attribute_values_list
ERROR api/tests/test_api.py::ApiEndpointTestCase::test_categories_list - djan...
ERROR api/tests/test_api.py::ApiEndpointTestCase::test_resource_types_list - ...
ERROR api/tests/test_api.py::ApiEndpointTestCase::test_subcategories_list - d...
ERROR api/tests/test_api.py::ApiEndpointTestCase::test_tags_list - django.db....
ERROR api/tests/test_api.py::ApiEndpointTestCase::test_techniques_list - djan...
ERROR api/tests/test_api.py::TechniqueAPITestCase::test_create_technique - dj...
ERROR api/tests/test_api.py::TechniqueAPITestCase::test_debug_endpoint - djan...
ERROR api/tests/test_api.py::TechniqueAPITestCase::test_delete_technique - dj...
ERROR api/tests/test_api.py::TechniqueAPITestCase::test_filter_techniques_by_assurance_goal
ERROR api/tests/test_api.py::TechniqueAPITestCase::test_filter_techniques_by_category
ERROR api/tests/test_api.py::TechniqueAPITestCase::test_filter_techniques_by_model_dependency
ERROR api/tests/test_api.py::TechniqueAPITestCase::test_filter_techniques_by_search
ERROR api/tests/test_api.py::TechniqueAPITestCase::test_filter_techniques_by_tag
ERROR api/tests/test_api.py::TechniqueAPITestCase::test_get_technique_detail
ERROR api/tests/test_api.py::TechniqueAPITestCase::test_get_technique_list - ...
ERROR api/tests/test_api.py::TechniqueAPITestCase::test_pagination - django.d...
ERROR api/tests/test_api.py::TechniqueAPITestCase::test_partial_update_technique
ERROR api/tests/test_api.py::TechniqueAPITestCase::test_relation_specific_endpoints
ERROR api/tests/test_api.py::TechniqueAPITestCase::test_update_technique - dj...
======================== 1 warning, 23 errors in 2.72s =========================
