name: Unified Deployment

on:
  workflow_dispatch:
    inputs:
      deployment_mode:
        description: 'Deployment mode'
        required: true
        type: choice
        options:
          - static
          - dynamic
          - mock
        default: static
      deployment_target:
        description: 'Deployment target'
        required: true
        type: choice
        options:
          - github-pages
          - vercel
          - azure
        default: github-pages
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - staging
          - production
        default: staging
  push:
    branches:
      - main
      - staging
    tags:
      - 'v*'

env:
  NODE_VERSION: '18'
  PNPM_VERSION: '10.6.5'
  PYTHON_VERSION: '3.12'

jobs:
  determine-deployment:
    runs-on: ubuntu-latest
    outputs:
      mode: ${{ steps.determine.outputs.mode }}
      target: ${{ steps.determine.outputs.target }}
      environment: ${{ steps.determine.outputs.environment }}
    steps:
      - name: Determine deployment parameters
        id: determine
        run: |
          # Use workflow inputs if available, otherwise determine from context
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "mode=${{ github.event.inputs.deployment_mode }}" >> $GITHUB_OUTPUT
            echo "target=${{ github.event.inputs.deployment_target }}" >> $GITHUB_OUTPUT
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          else
            # Default mode based on branch/tag
            if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
              echo "mode=static" >> $GITHUB_OUTPUT
              echo "target=github-pages" >> $GITHUB_OUTPUT
              echo "environment=production" >> $GITHUB_OUTPUT
            elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
              echo "mode=static" >> $GITHUB_OUTPUT
              echo "target=github-pages" >> $GITHUB_OUTPUT
              echo "environment=staging" >> $GITHUB_OUTPUT
            else
              echo "mode=dynamic" >> $GITHUB_OUTPUT
              echo "target=azure" >> $GITHUB_OUTPUT
              echo "environment=staging" >> $GITHUB_OUTPUT
            fi
          fi

  validate-deployment:
    runs-on: ubuntu-latest
    needs: determine-deployment
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate deployment configuration
        run: |
          echo "Validating deployment:"
          echo "  Mode: ${{ needs.determine-deployment.outputs.mode }}"
          echo "  Target: ${{ needs.determine-deployment.outputs.target }}"
          echo "  Environment: ${{ needs.determine-deployment.outputs.environment }}"

          # Validate mode-target compatibility
          mode="${{ needs.determine-deployment.outputs.mode }}"
          target="${{ needs.determine-deployment.outputs.target }}"

          if [ "$mode" == "dynamic" ] && [ "$target" == "github-pages" ]; then
            echo "::error::Dynamic mode cannot be deployed to GitHub Pages"
            exit 1
          fi

  build-frontend:
    runs-on: ubuntu-latest
    needs: [determine-deployment, validate-deployment]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        working-directory: frontend
        run: pnpm install --frozen-lockfile

      - name: Set build environment
        run: |
          mode="${{ needs.determine-deployment.outputs.mode }}"
          target="${{ needs.determine-deployment.outputs.target }}"

          echo "NEXT_PUBLIC_DATA_SOURCE=$mode" >> $GITHUB_ENV

          if [ "$target" == "github-pages" ]; then
            echo "NEXT_PUBLIC_BASE_PATH=/tea-techniques" >> $GITHUB_ENV
            echo "NEXT_PUBLIC_ASSET_PREFIX=/tea-techniques" >> $GITHUB_ENV
          fi

      - name: Generate static API data
        if: needs.determine-deployment.outputs.mode != 'dynamic'
        working-directory: frontend
        run: |
          pnpm sync-data
          pnpm generate-api
          pnpm validate-api

      - name: Build application
        working-directory: frontend
        run: |
          if [ "${{ needs.determine-deployment.outputs.mode }}" == "static" ]; then
            pnpm build:static
          elif [ "${{ needs.determine-deployment.outputs.mode }}" == "mock" ]; then
            pnpm build:mock
          else
            pnpm build:dynamic
          fi

      - name: Post-build validation
        working-directory: frontend
        run: pnpm validate:post-build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build-${{ needs.determine-deployment.outputs.mode }}
          path: |
            frontend/out/
            frontend/.next/
          retention-days: 7

  build-backend:
    runs-on: ubuntu-latest
    needs: [determine-deployment, validate-deployment]
    if: needs.determine-deployment.outputs.mode == 'dynamic'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build backend Docker image
        run: |
          docker build -t tea-techniques-backend:${{ github.sha }} ./backend

      - name: Save Docker image
        run: |
          docker save tea-techniques-backend:${{ github.sha }} | gzip > backend-image.tar.gz

      - name: Upload Docker image
        uses: actions/upload-artifact@v4
        with:
          name: backend-docker-image
          path: backend-image.tar.gz
          retention-days: 7

  deploy:
    runs-on: ubuntu-latest
    needs: [determine-deployment, build-frontend, build-backend]
    if: always() && needs.build-frontend.result == 'success'
    environment:
      name: ${{ needs.determine-deployment.outputs.environment }}
      url: ${{ steps.deployment.outputs.url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-build-${{ needs.determine-deployment.outputs.mode }}
          path: frontend/

      - name: Deploy to target
        id: deployment
        run: |
          target="${{ needs.determine-deployment.outputs.target }}"
          mode="${{ needs.determine-deployment.outputs.mode }}"

          echo "Deploying $mode build to $target"

          case $target in
            github-pages)
              echo "::notice::GitHub Pages deployment will be handled by dedicated workflow"
              echo "url=https://${{ github.repository_owner }}.github.io/tea-techniques" >> $GITHUB_OUTPUT
              ;;
            vercel)
              echo "::notice::Vercel deployment configuration needed"
              echo "url=https://tea-techniques.vercel.app" >> $GITHUB_OUTPUT
              ;;
            azure)
              echo "::notice::Azure deployment configuration needed"
              echo "url=https://tea-techniques.azurewebsites.net" >> $GITHUB_OUTPUT
              ;;
          esac

  notify-integrations:
    runs-on: ubuntu-latest
    needs: [determine-deployment, deploy]
    if: always() && needs.deploy.result == 'success'
    steps:
      - name: Notify integration partners
        run: |
          # Webhook notification for integration partners
          if [ "${{ needs.determine-deployment.outputs.mode }}" != "dynamic" ]; then
            echo "::notice::Mock API endpoints updated at ${{ steps.deployment.outputs.url }}/api/"

            # Add webhook notifications here when configured
            # Example:
            # curl -X POST https://partner-service.com/webhooks/tea-techniques \
            #   -H "Content-Type: application/json" \
            #   -d '{
            #     "event": "mock_api_updated",
            #     "mode": "${{ needs.determine-deployment.outputs.mode }}",
            #     "url": "${{ steps.deployment.outputs.url }}",
            #     "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
            #   }'
          fi

      - name: Update deployment status
        run: |
          echo "Deployment completed successfully"
          echo "Mode: ${{ needs.determine-deployment.outputs.mode }}"
          echo "Target: ${{ needs.determine-deployment.outputs.target }}"
          echo "Environment: ${{ needs.determine-deployment.outputs.environment }}"
          echo "URL: ${{ steps.deployment.outputs.url }}"

  performance-check:
    runs-on: ubuntu-latest
    needs: [determine-deployment, deploy]
    if: always() && needs.deploy.result == 'success'
    steps:
      - name: Run Lighthouse CI
        run: |
          echo "::notice::Lighthouse CI performance check will be implemented"
          # npm install -g @lhci/cli
          # lhci autorun --collect.url=${{ steps.deployment.outputs.url }}

      - name: Check bundle size
        run: |
          echo "::notice::Bundle size tracking will be implemented"
