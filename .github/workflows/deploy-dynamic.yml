name: Deploy Dynamic Site

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - staging
          - production
        default: staging
  push:
    branches:
      - staging
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'docker-compose.*.yml'
      - '.github/workflows/deploy-dynamic.yml'

env:
  NODE_VERSION: '18'
  PNPM_VERSION: '10.6.5'
  PYTHON_VERSION: '3.12'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-backend:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image: ${{ steps.image.outputs.image }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Set output
        id: image
        run: echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:sha-${GITHUB_SHA::7}" >> $GITHUB_OUTPUT

  build-frontend:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image: ${{ steps.image.outputs.image }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            NEXT_PUBLIC_DATA_SOURCE=api
            NEXT_PUBLIC_API_URL=${{ vars.API_URL }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Set output
        id: image
        run: echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:sha-${GITHUB_SHA::7}" >> $GITHUB_OUTPUT

  integration-tests:
    runs-on: ubuntu-latest
    needs: [build-backend, build-frontend]
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: tea_techniques_test
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Compose
        run: |
          # Create docker-compose override for testing
          cat > docker-compose.test.yml << EOF
          version: '3.8'
          services:
            backend:
              image: ${{ needs.build-backend.outputs.image }}
              environment:
                - DATABASE_URL=postgresql://postgres:postgres@postgres:5432/tea_techniques_test
                - DJANGO_SETTINGS_MODULE=config.settings.test
            frontend:
              image: ${{ needs.build-frontend.outputs.image }}
              environment:
                - NEXT_PUBLIC_API_URL=http://backend:8000
          EOF

      - name: Run integration tests
        run: |
          docker-compose -f docker-compose.yml -f docker-compose.test.yml up -d

          # Wait for services
          sleep 30

          # Run tests
          docker-compose exec -T backend python manage.py test
          docker-compose exec -T frontend npm test

          # Cleanup
          docker-compose down

  deploy:
    runs-on: ubuntu-latest
    needs: [build-backend, build-frontend, integration-tests]
    environment:
      name: ${{ github.event.inputs.environment || 'staging' }}
      url: ${{ steps.deploy.outputs.url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi

      - name: Deploy to environment
        id: deploy
        run: |
          echo "::notice::Deploying to ${{ steps.env.outputs.environment }}"

          # Deployment configuration would go here
          # This is a placeholder for actual deployment logic

          if [ "${{ steps.env.outputs.environment }}" == "production" ]; then
            echo "url=https://tea-techniques.com" >> $GITHUB_OUTPUT
          else
            echo "url=https://staging.tea-techniques.com" >> $GITHUB_OUTPUT
          fi

      - name: Run smoke tests
        run: |
          url="${{ steps.deploy.outputs.url }}"
          echo "Running smoke tests against $url"

          # Test API endpoint
          if ! curl -f -s "$url/api/techniques/" > /dev/null; then
            echo "::error::API endpoint not accessible"
            exit 1
          fi

          # Test frontend
          if ! curl -f -s "$url" > /dev/null; then
            echo "::error::Frontend not accessible"
            exit 1
          fi

          echo "✅ Smoke tests passed"

  rollback-on-failure:
    runs-on: ubuntu-latest
    needs: [deploy]
    if: failure()
    steps:
      - name: Rollback deployment
        run: |
          echo "::error::Deployment failed, initiating rollback"
          # Rollback logic would go here

  notify:
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    steps:
      - name: Send deployment notification
        run: |
          status="${{ needs.deploy.result }}"
          environment="${{ github.event.inputs.environment || 'staging' }}"

          if [ "$status" == "success" ]; then
            message="✅ Dynamic deployment to $environment succeeded"
          else
            message="❌ Dynamic deployment to $environment failed"
          fi

          echo "$message"

          # Send notifications (webhook, Slack, etc.)
          # Example:
          # curl -X POST ${{ secrets.SLACK_WEBHOOK }} \
          #   -H "Content-Type: application/json" \
          #   -d "{\"text\": \"$message\"}"

      - name: Update deployment status
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # Dynamic Deployment Summary

          ## Deployment Details
          - **Status**: ${{ needs.deploy.result == 'success' && '✅ Success' || '❌ Failed' }}
          - **Environment**: ${{ github.event.inputs.environment || 'staging' }}
          - **Backend Image**: ${{ needs.build-backend.outputs.image }}
          - **Frontend Image**: ${{ needs.build-frontend.outputs.image }}
          - **Time**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")

          ## Services
          - Backend API: Deployed with Django + PostgreSQL
          - Frontend: Deployed with Next.js in SSR mode
          - Database: PostgreSQL with migrations applied

          ## Next Steps
          - Monitor application logs
          - Check performance metrics
          - Verify all features working correctly
          EOF
