This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
backend/
  api/
    management/
      commands/
        import_techniques.py
        reset_and_import_techniques.py
        reset_database.py
        tailscale_setup.py
    tests/
      __init__.py
      conftest.py
      factories.py
      test_api.py
      test_error_handling.py
      test_models.py
    views/
      api_views.py
      auth_views.py
    admin.py
    apps.py
    forms.py
    models.py
    root_urls.py
    serializers.py
    urls.py
    utils.py
  config/
    settings/
      __init__.py
      base.py
      development.py
      docker.py
      production.py
      sqlite.py
      test.py
    asgi.py
    settings_old.py
    settings_sqlite_old.py
    urls.py
    wsgi.py
  data/
    techniques_schema.json
    techniques.json
  .env.example
  Dockerfile
  entrypoint.sh
  manage.py
  pyproject.toml
docs/
  API-GUIDE.md
  DATA-MANAGEMENT.md
  DEPLOYMENT.md
  DEVELOPMENT-WORKFLOW.md
  FRONTEND-GUIDE.md
  FUTURE-ROADMAP.md
  GLOSSARY.md
  MODEL-ARCHITECTURE.md
  TAILSCALE-DEPLOYMENT.md
  TESTING.md
  USER-GUIDE.md
frontend/
  public/
    file.svg
    globe.svg
    next.svg
    README.md
    vercel.svg
    window.svg
  src/
    app/
      about/
        page.tsx
      api-test/
        page.tsx
      categories/
        page.tsx
      login/
        page.tsx
      techniques/
        [id]/
          edit/
            page.tsx
          page.tsx
          page.tsx.orig
          page.tsx.rej
          patch.txt
        add/
          page.tsx
        page.tsx
      globals.css
      layout.tsx
      page.tsx
    components/
      common/
        AuthWrapper.tsx
        FormField.tsx
        MultiSelectField.tsx
        SelectField.tsx
      layout/
        Footer.tsx
        Header.tsx
        MainLayout.tsx
      technique/
        AttributeVisualizer.tsx
        CategoryTag.tsx
        GoalIcon.tsx
        TechniqueForm.tsx
        TechniquesList.tsx
        TechniquesSidebar.tsx
      ui/
        accordion.tsx
        alert.tsx
        badge.tsx
        button.tsx
        card.tsx
        checkbox.tsx
        command.tsx
        data-list.tsx
        dialog.tsx
        DismissibleBanner.tsx
        info-label.tsx
        input.tsx
        label.tsx
        pagination.tsx
        popover.tsx
        prism-code-block.tsx
        select.tsx
        skeleton.tsx
        slider.tsx
        star-rating.tsx
        table.tsx
        tabs.tsx
        textarea.tsx
        tooltip.tsx
    lib/
      api/
        client.ts
        errorUtils.ts
        fetch.ts
        hooks.ts
        useTechniques.ts
      context/
        auth-context.tsx
        dark-mode.tsx
      hooks/
        useApiError.ts
        useFilterParams.ts
        useForm.ts
        usePagination.ts
      providers/
        query-provider.tsx
      config.ts
      constants.ts
      types.ts
      utils.ts
    mocks/
      handlers.ts
      server.ts
    providers/
      query-provider.tsx
    styles/
      globals.css
    tests/
      hooks/
        useApiError.test.ts
        useFilterParams.test.ts
        useForm.test.ts
      TechniqueForm.test.tsx
  tests/
    plan.md
    test-suite.txt
  .gitignore
  components.json
  Dockerfile
  eslint.config.mjs
  jest.config.ts
  jest.setup.ts
  next.config.ts
  package.json
  postcss.config.mjs
  tailwind.config.ts
  tsconfig.json
nginx/
  tea-techniques.conf.template
.env.example
.env.tailscale
.gitignore
CONTRIBUTING.md
deploy-tailscale.sh
dev.sh
docker-compose.yml
LICENSE
README.md
update-nginx.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/api/tests/__init__.py">
# backend/api/tests/__init__.py
</file>

<file path="backend/api/tests/conftest.py">
# api/tests/conftest.py
import pytest
from django.conf import settings


def pytest_configure(config):
    """Print information about the test environment."""
    print(f"\nUsing Django settings module: {settings.SETTINGS_MODULE}")
    db_engine = settings.DATABASES["default"]["ENGINE"]
    print(f"Using database engine: {db_engine}")
</file>

<file path="backend/api/admin.py">
from django.contrib import admin
from .models import (
    AssuranceGoal,
    Category,
    SubCategory,
    Tag,
    Technique,
    AttributeType,
    AttributeValue,
    ResourceType,
    TechniqueResource,
    TechniqueExampleUseCase,
    TechniqueLimitation,
)

# Register all models
admin.site.register(AssuranceGoal)
admin.site.register(Category)
admin.site.register(SubCategory)
admin.site.register(Tag)
admin.site.register(AttributeType)
admin.site.register(AttributeValue)
admin.site.register(ResourceType)
admin.site.register(Technique)
admin.site.register(TechniqueResource)
admin.site.register(TechniqueExampleUseCase)
admin.site.register(TechniqueLimitation)
</file>

<file path="backend/api/apps.py">
from django.apps import AppConfig


class ApiConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'api'
</file>

<file path="backend/api/forms.py">
# api/forms.py

from django import forms
from .models import Technique, Category, SubCategory

class TechniqueForm(forms.ModelForm):
    class Meta:
        model = Technique
        fields = [
            'name',
            'description',
            'assurance_goal',
            'category',
            'sub_category',
            'model_dependency',
            'example_use_case',
            'tags',
            'reference',
            'software_package',
            'limitation',
            'fairness_approach',
            'project_lifecycle_stage',
        ]
        widgets = {
            'description': forms.Textarea(attrs={'rows': 3}),
            'example_use_case': forms.Textarea(attrs={'rows': 3}),
            'limitation': forms.Textarea(attrs={'rows': 3}),
            'fairness_approach': forms.SelectMultiple(attrs={'id': 'id_fairness_approach'}),
            'project_lifecycle_stage': forms.SelectMultiple(attrs={'id': 'id_project_lifecycle_stage'}),
            'tags': forms.SelectMultiple(attrs={'id': 'id_tags'}),
            'category': forms.Select(attrs={'id': 'id_category'}),
            'sub_category': forms.Select(attrs={'id': 'id_sub_category'}),
        }
    
    model_dependency = forms.ChoiceField(choices=[('agnostic', 'Agnostic'), ('specific', 'Specific')], widget=forms.RadioSelect)
    
    # Override to filter category based on selected assurance goal
    def __init__(self, *args, **kwargs):
        super(TechniqueForm, self).__init__(*args, **kwargs)
        self.fields['category'].queryset = Category.objects.none()
        self.fields['sub_category'].queryset = SubCategory.objects.none()

        if 'assurance_goal' in self.data:
            try:
                assurance_goal_id = int(self.data.get('assurance_goal'))
                self.fields['category'].queryset = Category.objects.filter(assurance_goal_id=assurance_goal_id).order_by('name')
            except (ValueError, TypeError):
                pass  # invalid input from the client; ignore and fallback to empty Category queryset
        elif self.instance.pk:
            self.fields['category'].queryset = self.instance.assurance_goal.category_set.order_by('name')

        if 'category' in self.data:
            try:
                category_id = int(self.data.get('category'))
                self.fields['sub_category'].queryset = SubCategory.objects.filter(category_id=category_id).order_by('name')
            except (ValueError, TypeError):
                pass  # invalid input from the client; ignore and fallback to empty SubCategory queryset
        elif self.instance.pk:
            self.fields['sub_category'].queryset = self.instance.category.subcategory_set.order_by('name')
</file>

<file path="backend/api/root_urls.py">
# api/root_urls.py

from django.urls import path
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework.reverse import reverse


@api_view(["GET"])
def api_root(request, format=None):
    """
    Welcome page that provides links to the API documentation
    """
    return Response(
        {
            "message": "Welcome to the TEA XAI Techniques API",
            "documentation": {
                "swagger": reverse("schema-swagger-ui", request=request, format=format),
                "redoc": reverse("schema-redoc", request=request, format=format),
            },
            "api_endpoints": reverse("api-root", request=request, format=format),
        }
    )


urlpatterns = [
    path("", api_root, name="root"),
]
</file>

<file path="frontend/public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="frontend/public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="frontend/public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="frontend/public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="frontend/public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="frontend/src/app/techniques/page.tsx">
// src/app/techniques/page.tsx
"use client";

import { Suspense } from "react";
import MainLayout from "@/components/layout/MainLayout";
import TechniquesList from "@/components/technique/TechniquesList";

// Loading component
function LoadingState() {
	return (
		<div className="flex justify-center items-center min-h-[400px]">
			<p className="text-lg text-muted-foreground">
				Loading techniques...
			</p>
		</div>
	);
}

export default function TechniquesPage() {
	return (
		<MainLayout>
			<Suspense fallback={<LoadingState />}>
				<TechniquesList />
			</Suspense>
		</MainLayout>
	);
}
</file>

<file path="frontend/src/components/common/FormField.tsx">
// src/components/common/FormField.tsx
import React from "react";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";

interface FormFieldProps {
  id: string;
  label: string;
  type?: "text" | "textarea";
  value: string;
  onChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
  error?: string;
  placeholder?: string;
  required?: boolean;
  rows?: number;
}

export const FormField: React.FC<FormFieldProps> = ({
  id,
  label,
  type = "text",
  value,
  onChange,
  error,
  placeholder,
  required = false,
  rows = 3,
}) => {
  return (
    <div className="space-y-2">
      <Label htmlFor={id} className="text-base">
        {label} {required && <span className="text-red-500">*</span>}
      </Label>
      
      {type === "text" ? (
        <Input
          id={id}
          name={id}
          value={value || ""}
          onChange={onChange}
          placeholder={placeholder}
          className={error ? "border-red-500" : ""}
        />
      ) : (
        <Textarea
          id={id}
          name={id}
          value={value || ""}
          onChange={onChange}
          placeholder={placeholder}
          rows={rows}
          className={error ? "border-red-500" : ""}
        />
      )}
      
      {error && <p className="text-sm text-red-500">{error}</p>}
    </div>
  );
};
</file>

<file path="frontend/src/components/common/MultiSelectField.tsx">
// MultiSelectField component for handling many-to-many relationships
import React from "react";
import { CheckIcon, ChevronDownIcon, X } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { Command, CommandEmpty, CommandGroup, CommandInput, CommandItem } from "@/components/ui/command";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";

interface Option {
  value: string;
  label: string;
}

interface MultiSelectFieldProps {
  id: string;
  label: string;
  values: string[];
  onChange: (values: string[]) => void;
  options: Option[];
  placeholder?: string;
  description?: string;
  error?: string | null;
  required?: boolean;
  disabled?: boolean;
}

export const MultiSelectField: React.FC<MultiSelectFieldProps> = ({
  id,
  label,
  values,
  onChange,
  options,
  placeholder = "Select options",
  description,
  error,
  required = false,
  disabled = false,
}) => {
  // Memoize handlers to prevent unnecessary re-renders
  const handleSelect = React.useCallback((value: string) => {
    if (values.includes(value)) {
      onChange(values.filter((v) => v !== value));
    } else {
      onChange([...values, value]);
    }
  }, [values, onChange]);

  // Handle removal of a selected option
  const handleRemove = React.useCallback((value: string) => {
    onChange(values.filter((v) => v !== value));
  }, [values, onChange]);

  // Clear all selected options
  const handleClear = React.useCallback(() => {
    onChange([]);
  }, [onChange]);

  // Memoize the selected labels
  const selectedLabels = React.useMemo(() => values.map(
    (value) => options.find((option) => option.value === value)?.label || value
  ), [values, options]);

  return (
    <div className="space-y-2">
      <div className="flex justify-between items-center">
        <label htmlFor={id} className="block text-sm font-medium">
          {label} {required && <span className="text-destructive">*</span>}
        </label>
        {values.length > 0 && (
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={handleClear}
            disabled={disabled}
            className="h-auto py-0 px-2"
          >
            Clear
          </Button>
        )}
      </div>
      
      <Popover>
        <PopoverTrigger asChild>
          <Button
            id={id}
            variant="outline"
            role="combobox"
            disabled={disabled}
            className={cn(
              "w-full justify-between",
              !values.length && "text-muted-foreground"
            )}
          >
            {values.length > 0
              ? `${values.length} selected`
              : placeholder}
            <ChevronDownIcon className="ml-2 h-4 w-4 shrink-0 opacity-50" />
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-full p-0" align="start">
          <Command>
            <CommandInput placeholder={`Search ${label.toLowerCase()}...`} />
            <CommandEmpty>No {label.toLowerCase()} found.</CommandEmpty>
            <CommandGroup className="max-h-60 overflow-auto">
              {options.map((option) => (
                <CommandItem
                  key={option.value}
                  value={option.value}
                  onSelect={() => handleSelect(option.value)}
                >
                  <div className="flex items-center gap-2 w-full">
                    <div
                      className={cn(
                        "flex h-4 w-4 items-center justify-center rounded-sm border",
                        values.includes(option.value)
                          ? "border-primary bg-primary text-primary-foreground"
                          : "opacity-50 border-input"
                      )}
                    >
                      {values.includes(option.value) && (
                        <CheckIcon className="h-3 w-3" />
                      )}
                    </div>
                    <span>{option.label}</span>
                  </div>
                </CommandItem>
              ))}
            </CommandGroup>
          </Command>
        </PopoverContent>
      </Popover>
      
      {values.length > 0 && (
        <div className="flex flex-wrap gap-1 mt-2">
          {selectedLabels.map((label, i) => (
            <Badge 
              key={i} 
              variant="secondary" 
              className="px-2 py-1 text-xs flex items-center gap-1"
            >
              {label}
              <button
                type="button"
                onClick={() => handleRemove(values[i])}
                disabled={disabled}
                className="flex items-center justify-center text-muted-foreground hover:text-foreground"
              >
                <X className="h-3 w-3" />
              </button>
            </Badge>
          ))}
        </div>
      )}
      
      {description && (
        <p className="text-xs text-muted-foreground">{description}</p>
      )}
      
      {error && (
        <p className="text-xs text-destructive">{error}</p>
      )}
    </div>
  );
};

export default MultiSelectField;
</file>

<file path="frontend/src/components/common/SelectField.tsx">
// src/components/common/SelectField.tsx
import React from "react";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

interface SelectOption {
  value: string;
  label: string;
}

interface SelectFieldProps {
  id: string;
  label: string;
  value: string;
  onChange: (value: string) => void;
  options: SelectOption[];
  error?: string | null;
  placeholder?: string;
  required?: boolean;
  disabled?: boolean; // Add this property
}

export const SelectField: React.FC<SelectFieldProps> = ({
  id,
  label,
  value,
  onChange,
  options,
  error,
  placeholder = "Select an option",
  required = false,
  disabled = false, // Add default value
}) => {
  // Memoize the handler to avoid frequent recreation
  const handleValueChange = React.useCallback((newValue: string) => {
    if (newValue !== value) {
      onChange(newValue);
    }
  }, [value, onChange]);

  // Memoize props to prevent unnecessary re-renders
  const memoizedValue = React.useMemo(() => value || "", [value]);
  
  // Memoize the Select component to prevent re-rendering when props don't change
  const selectComponent = React.useMemo(() => (
    <Select
      value={memoizedValue}
      onValueChange={handleValueChange}
      disabled={disabled} // Pass the disabled prop to the Select component
    >
      <SelectTrigger id={id} className={error ? "border-red-500" : ""}>
        <SelectValue placeholder={placeholder} />
      </SelectTrigger>
      <SelectContent>
        {options.map((option) => (
          <SelectItem
            key={option.value}
            value={option.value}
          >
            {option.label}
          </SelectItem>
        ))}
      </SelectContent>
    </Select>
  ), [memoizedValue, handleValueChange, id, error, placeholder, options, disabled]); // Add disabled to the dependency array

  return (
    <div className="space-y-2">
      {label && (
        <Label htmlFor={id} className="text-base">
          {label} {required && <span className="text-red-500">*</span>}
        </Label>
      )}
      
      {selectComponent}
      
      {error && <p className="text-sm text-red-500">{error}</p>}
    </div>
  );
};

SelectField.displayName = "SelectField";
</file>

<file path="frontend/src/components/technique/AttributeVisualizer.tsx">
// src/components/technique/AttributeVisualizer.tsx
import React from "react";
import { StarRating } from "@/components/ui/star-rating";
import { Badge } from "@/components/ui/badge";
import { InfoLabel } from "@/components/ui/info-label";
import { AttributeValue } from "@/lib/types";

// Define visualization types
type VisualizationType = "stars" | "badge" | "percentage" | "default";

// Define mapping of attribute types to visualization methods
interface AttributeConfig {
	visualizationType: VisualizationType;
	tooltip: string;
	valueMapper?: (value: string | number) => string | number;
}

// Attribute type to visualization mapping
const ATTRIBUTE_CONFIGS: Record<string, AttributeConfig> = {
	Complexity: {
		visualizationType: "stars",
		tooltip: "How complex is this technique to implement (1-5)",
		valueMapper: (value) => Number(value) || 0,
	},
	"Computational Cost": {
		visualizationType: "stars",
		tooltip: "How computationally expensive is this technique (1-5)",
		valueMapper: (value) => Number(value) || 0,
	},
	// Add configurations for new attribute types from the API
	"Explanatory Scope": {
		visualizationType: "default",
		tooltip: "Whether the technique provides local or global explanations",
	},
};

interface AttributeVisualizerProps {
	attributeValues: AttributeValue[];
}

export const AttributeVisualizer: React.FC<AttributeVisualizerProps> = ({
	attributeValues,
}) => {
	// Group attributes by type
	const attributesByType = attributeValues.reduce((acc, attr) => {
		const type = attr.attribute_type_name;
		if (!acc[type]) {
			acc[type] = [];
		}
		acc[type].push(attr);
		return acc;
	}, {} as Record<string, AttributeValue[]>);

	return (
		<div className="space-y-4">
			{Object.entries(attributesByType).map(([type, attrs]) => {
				const config = ATTRIBUTE_CONFIGS[type] || {
					visualizationType: "default",
					tooltip: `${type} attribute`,
				};

				// Get first attribute value for this type (for single-value attributes like ratings)
				const attr = attrs[0];
				const rawValue = attr.name;
				const value = config.valueMapper
					? config.valueMapper(rawValue)
					: rawValue;

				return (
					<div key={type} className="space-y-1">
						<h3 className="text-sm font-medium">
							<InfoLabel label={type} tooltip={config.tooltip} />
						</h3>

						{/* Render based on visualization type */}
						{config.visualizationType === "stars" && (
							<div className="flex items-center gap-2">
								<StarRating
									rating={
										typeof value === "number" ? value : 0
									}
									className="text-primary"
								/>
							</div>
						)}

						{config.visualizationType === "badge" && (
							<Badge>{String(value)}</Badge>
						)}

						{config.visualizationType === "default" && (
							<div className="flex flex-wrap gap-2">
								{attrs.map((attr) => (
									<Badge key={attr.id} variant="secondary">
										{attr.name}
									</Badge>
								))}
							</div>
						)}
					</div>
				);
			})}
		</div>
	);
};

export default AttributeVisualizer;
</file>

<file path="frontend/src/components/technique/CategoryTag.tsx">
import React from "react";
import { Badge } from "@/components/ui/badge";
import { cn } from "@/lib/utils";

interface CategoryTagProps {
	name: string;
	className?: string;
	variant?: "default" | "secondary" | "outline" | "destructive";
	isSelected?: boolean;
	onClick?: () => void;
}

// Format a category name from hyphenated format to title case
export const formatCategoryName = (name: string): string => {
	return name
		.split("-")
		.map((word) => word.charAt(0).toUpperCase() + word.slice(1))
		.join(" ");
};

export const CategoryTag: React.FC<CategoryTagProps> = ({
	name,
	className,
	variant = "outline",
	isSelected = false,
	onClick,
}) => {
	const formattedName = formatCategoryName(name);

	return (
		<Badge
			variant={isSelected ? "default" : variant}
			className={cn(
				"cursor-pointer hover:bg-muted transition-colors",
				onClick ? "cursor-pointer" : "",
				className
			)}
			onClick={onClick}
		>
			{formattedName}
		</Badge>
	);
};

export default CategoryTag;
</file>

<file path="frontend/src/components/technique/GoalIcon.tsx">
import React from "react";
import {
	Brain,
	Scale,
	Shield,
	ShieldCheck,
	CheckCircle,
	Eye,
	Lock,
	HelpCircle,
} from "lucide-react";
import { cn } from "@/lib/utils";

// Mapping of goal names to their corresponding icons
export const goalIconsMap = {
	Explainability: Brain,
	Fairness: Scale,
	Security: Shield,
	Safety: ShieldCheck,
	Reliability: CheckCircle,
	Transparency: Eye,
	Privacy: Lock,
};

interface GoalIconProps {
	goalName: string;
	className?: string;
	size?: number;
}

export const GoalIcon: React.FC<GoalIconProps> = ({
	goalName,
	className,
	size = 20,
}) => {
	// Format goal name to match our mapping (capitalize first letter)
	const formattedGoalName =
		goalName.charAt(0).toUpperCase() + goalName.slice(1).toLowerCase();

	// Get the icon component from our mapping, or use the default
	const IconComponent =
		goalIconsMap[formattedGoalName as keyof typeof goalIconsMap] ||
		HelpCircle;

	return <IconComponent className={cn("shrink-0", className)} size={size} />;
};

export default GoalIcon;
</file>

<file path="frontend/src/components/ui/accordion.tsx">
"use client";

import * as React from "react";
import * as AccordionPrimitive from "@radix-ui/react-accordion";
import { ChevronDown } from "lucide-react";

import { cn } from "@/lib/utils";

const Accordion = AccordionPrimitive.Root;

const AccordionItem = React.forwardRef<
	React.ElementRef<typeof AccordionPrimitive.Item>,
	React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
	<AccordionPrimitive.Item
		ref={ref}
		className={cn("border-b", className)}
		{...props}
	/>
));
AccordionItem.displayName = "AccordionItem";

const AccordionTrigger = React.forwardRef<
	React.ElementRef<typeof AccordionPrimitive.Trigger>,
	React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
	<AccordionPrimitive.Header className="flex">
		<AccordionPrimitive.Trigger
			ref={ref}
			className={cn(
				"flex flex-1 items-center justify-between py-4 text-sm font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
				className
			)}
			{...props}
		>
			{children}
			<ChevronDown className="h-4 w-4 shrink-0 text-muted-foreground transition-transform duration-200" />
		</AccordionPrimitive.Trigger>
	</AccordionPrimitive.Header>
));
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName;

const AccordionContent = React.forwardRef<
	React.ElementRef<typeof AccordionPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
	<AccordionPrimitive.Content
		ref={ref}
		className={cn(
			"overflow-hidden text-sm data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down",
			className
		)}
		{...props}
	>
		<div className="pb-4 pt-0">{children}</div>
	</AccordionPrimitive.Content>
));
AccordionContent.displayName = AccordionPrimitive.Content.displayName;

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent };
</file>

<file path="frontend/src/components/ui/badge.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
</file>

<file path="frontend/src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-[color,box-shadow] disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40",
        outline:
          "border border-input bg-background shadow-xs hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
</file>

<file path="frontend/src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn("flex flex-col gap-1.5 px-6", className)}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6", className)}
      {...props}
    />
  )
}

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="frontend/src/components/ui/checkbox.tsx">
"use client";

import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
	React.ElementRef<typeof CheckboxPrimitive.Root>,
	React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
	<CheckboxPrimitive.Root
		ref={ref}
		className={cn(
			"peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow-sm focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
			className
		)}
		{...props}
	>
		<CheckboxPrimitive.Indicator
			className={cn("flex items-center justify-center text-current")}
		>
			<Check className="h-3.5 w-3.5" />
		</CheckboxPrimitive.Indicator>
	</CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };
</file>

<file path="frontend/src/components/ui/command.tsx">
import * as React from "react"
import { DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

type CommandDialogProps = DialogProps

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none aria-selected:bg-accent aria-selected:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}
</file>

<file path="frontend/src/components/ui/data-list.tsx">
"use client"

import * as React from "react"
import { cn } from "@/lib/utils"

// Root component
interface DataListRootProps extends React.HTMLAttributes<HTMLDListElement> {
  orientation?: "horizontal" | "vertical" | ResponsiveOrient
  size?: "1" | "2" | "3"
  trim?: "normal" | "start" | "end" | "both"
}

type ResponsiveOrient = {
  initial?: "horizontal" | "vertical"
  sm?: "horizontal" | "vertical"
  md?: "horizontal" | "vertical"
  lg?: "horizontal" | "vertical"
  xl?: "horizontal" | "vertical"
}

const DataList = React.forwardRef<HTMLDListElement, DataListRootProps>(
  ({ className, orientation = "horizontal", size = "2", children, ...props }, ref) => {
    const isVertical = typeof orientation === "string" 
      ? orientation === "vertical" 
      : orientation.initial === "vertical"
    
    const sizeClass = {
      "1": "text-xs",
      "2": "text-sm",
      "3": "text-base"
    }[size]
    
    return (
      <dl
        ref={ref}
        className={cn(
          "space-y-3", 
          sizeClass,
          isVertical ? "flex flex-col gap-3" : "grid grid-cols-[max-content_1fr] gap-x-4 gap-y-3",
          className
        )}
        {...props}
      >
        {children}
      </dl>
    )
  }
)
DataList.displayName = "DataList.Root"

// Item component 
interface DataListItemProps extends React.HTMLAttributes<HTMLDivElement> {
  align?: "center" | "start" | "end" | "baseline" | "stretch"
}

const DataListItem = React.forwardRef<HTMLDivElement, DataListItemProps>(
  ({ className, align, children, ...props }, ref) => {
    const alignClass = align ? `items-${align}` : ""
    
    return (
      <div
        ref={ref}
        className={cn(
          "flex flex-wrap",
          alignClass,
          className
        )}
        {...props}
      >
        {children}
      </div>
    )
  }
)
DataListItem.displayName = "DataList.Item"

// Label component
interface DataListLabelProps extends React.HTMLAttributes<HTMLElement> {
  width?: string
  minWidth?: string
  maxWidth?: string
  color?: string
  highContrast?: boolean
}

const DataListLabel = React.forwardRef<HTMLElement, DataListLabelProps>(
  ({ className, width, minWidth, maxWidth, color, highContrast, children, ...props }, ref) => {
    const styleProps: React.CSSProperties = {}
    if (width) styleProps.width = width
    if (minWidth) styleProps.minWidth = minWidth
    if (maxWidth) styleProps.maxWidth = maxWidth
    
    let colorClass = ""
    if (color) {
      colorClass = `text-${color}-${highContrast ? '900' : '500'}`
    }
    
    return (
      <dt
        ref={ref}
        className={cn(
          "font-medium text-muted-foreground mb-1",
          colorClass,
          className
        )}
        style={styleProps}
        {...props}
      >
        {children}
      </dt>
    )
  }
)
DataListLabel.displayName = "DataList.Label"

// Value component
const DataListValue = React.forwardRef<
  HTMLElement, 
  React.HTMLAttributes<HTMLElement>
>(({ className, children, ...props }, ref) => {
  return (
    <dd
      ref={ref}
      className={cn("text-foreground", className)}
      {...props}
    >
      {children}
    </dd>
  )
})
DataListValue.displayName = "DataList.Value"

// Section component
interface DataListSectionProps extends React.HTMLAttributes<HTMLDivElement> {
  heading?: string | React.ReactNode
}

const DataListSection = React.forwardRef<HTMLDivElement, DataListSectionProps>(
  ({ className, heading, children, ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn("space-y-2", className)}
        {...props}
      >
        {heading && (
          <h3 className="font-semibold text-sm">{heading}</h3>
        )}
        <div className="space-y-2">
          {children}
        </div>
      </div>
    )
  }
)
DataListSection.displayName = "DataList.Section"

export { 
  DataList, 
  DataListItem, 
  DataListLabel, 
  DataListValue, 
  DataListSection 
}
</file>

<file path="frontend/src/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}
</file>

<file path="frontend/src/components/ui/info-label.tsx">
// src/components/ui/info-label.tsx
import React from "react";
import { Info } from "lucide-react";
import { Tooltip } from "@/components/ui/tooltip";

interface InfoLabelProps {
	label: string;
	tooltip: string;
}

export const InfoLabel: React.FC<InfoLabelProps> = ({ label, tooltip }) => {
	return (
		<Tooltip content={tooltip}>
			<div className="inline-flex items-center cursor-help">
				{label}
				<Info className="ml-1 h-4 w-4 text-muted-foreground" />
			</div>
		</Tooltip>
	);
};

export default InfoLabel;
</file>

<file path="frontend/src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "border-input file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="frontend/src/components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }
</file>

<file path="frontend/src/components/ui/pagination.tsx">
// src/components/ui/pagination.tsx
import React from "react";
import { Button } from "@/components/ui/button";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { cn } from "@/lib/utils";

interface PaginationProps {
	currentPage: number;
	totalPages: number;
	onPageChange: (page: number) => void;
	className?: string;
}

export function Pagination({
	currentPage,
	totalPages,
	onPageChange,
	className,
}: PaginationProps) {
	// Don't render pagination if there's only one page
	if (totalPages <= 1) {
		return null;
	}

	// Safety check to ensure currentPage is within bounds
	const safeCurrentPage = Math.max(1, Math.min(currentPage, totalPages));
	
	// Create an array of page numbers to display
	const getPageNumbers = () => {
		const pageNumbers: number[] = [];
		const maxPagesToShow = 7; // Show at most 7 page numbers at once
		
		if (totalPages <= maxPagesToShow) {
			// If we have 7 or fewer pages, show all of them
			for (let i = 1; i <= totalPages; i++) {
				pageNumbers.push(i);
			}
		} else {
			// Always include first page
			pageNumbers.push(1);
			
			// Calculate start and end of page numbers to show
			let startPage = Math.max(2, safeCurrentPage - 2);
			let endPage = Math.min(totalPages - 1, safeCurrentPage + 2);
			
			// Adjust if we're near the beginning
			if (safeCurrentPage <= 4) {
				startPage = 2;
				endPage = Math.min(totalPages - 1, 6);
			}
			
			// Adjust if we're near the end
			if (safeCurrentPage >= totalPages - 3) {
				startPage = Math.max(2, totalPages - 5);
				endPage = totalPages - 1;
			}
			
			// Add ellipsis if needed before middle pages
			if (startPage > 2) {
				pageNumbers.push(-1); // -1 represents ellipsis
			}
			
			// Add middle pages
			for (let i = startPage; i <= endPage; i++) {
				pageNumbers.push(i);
			}
			
			// Add ellipsis if needed after middle pages
			if (endPage < totalPages - 1) {
				pageNumbers.push(-2); // -2 represents ellipsis (different key)
			}
			
			// Always include last page
			pageNumbers.push(totalPages);
		}
		
		return pageNumbers;
	};

	const pageNumbers = getPageNumbers();

	return (
		<nav className={cn("flex items-center justify-center space-x-1", className)} aria-label="Pagination">
			{/* Previous page button */}
			<Button
				variant="outline"
				size="icon"
				onClick={() => onPageChange(safeCurrentPage - 1)}
				disabled={safeCurrentPage === 1}
				className="h-8 w-8"
				aria-label="Previous page"
			>
				<ChevronLeft className="h-4 w-4" />
			</Button>
			
			{/* Page number buttons */}
			{pageNumbers.map((pageNumber) => {
				// Render ellipsis
				if (pageNumber < 0) {
					return (
						<span 
							key={`ellipsis-${pageNumber}`} 
							className="px-2 text-sm text-muted-foreground"
						>
							…
						</span>
					);
				}
				
				// Render page number
				return (
					<Button
						key={pageNumber}
						variant={pageNumber === safeCurrentPage ? "default" : "outline"}
						size="sm"
						onClick={() => onPageChange(pageNumber)}
						className="h-8 w-8"
						aria-current={pageNumber === safeCurrentPage ? "page" : undefined}
						aria-label={`Page ${pageNumber}`}
					>
						{pageNumber}
					</Button>
				);
			})}
			
			{/* Next page button */}
			<Button
				variant="outline"
				size="icon"
				onClick={() => onPageChange(safeCurrentPage + 1)}
				disabled={safeCurrentPage === totalPages}
				className="h-8 w-8"
				aria-label="Next page"
			>
				<ChevronRight className="h-4 w-4" />
			</Button>
		</nav>
	);
}
</file>

<file path="frontend/src/components/ui/popover.tsx">
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }
</file>

<file path="frontend/src/components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger>) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive flex h-9 w-full items-center justify-between rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("px-2 py-1.5 text-sm font-medium", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}
</file>

<file path="frontend/src/components/ui/slider.tsx">
"use client";

import * as React from "react";
import * as SliderPrimitive from "@radix-ui/react-slider";

import { cn } from "@/lib/utils";

const Slider = React.forwardRef<
	React.ElementRef<typeof SliderPrimitive.Root>,
	React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
	<SliderPrimitive.Root
		ref={ref}
		className={cn(
			"relative flex w-full touch-none select-none items-center",
			className
		)}
		{...props}
	>
		<SliderPrimitive.Track className="relative h-1.5 w-full grow overflow-hidden rounded-full bg-primary/20">
			<SliderPrimitive.Range className="absolute h-full bg-primary" />
		</SliderPrimitive.Track>
		<SliderPrimitive.Thumb className="block h-4 w-4 rounded-full border border-primary/50 bg-background shadow transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50" />
	</SliderPrimitive.Root>
));
Slider.displayName = SliderPrimitive.Root.displayName;

export { Slider };
</file>

<file path="frontend/src/components/ui/star-rating.tsx">
// src/components/ui/star-rating.tsx
import { Star } from "lucide-react";
import { cn } from "@/lib/utils";

interface StarRatingProps {
	rating: number;
	maxRating?: number;
	className?: string;
	size?: "sm" | "md" | "lg";
}

export function StarRating({
	rating,
	maxRating = 5,
	className,
	size = "md",
}: StarRatingProps) {
	// Handle invalid ratings gracefully
	const validRating = Math.max(0, Math.min(Math.round(rating), maxRating));

	// Determine star sizes based on the size prop
	const starSize = {
		sm: "w-3 h-3",
		md: "w-4 h-4",
		lg: "w-5 h-5",
	}[size];

	return (
		<div className={cn("flex items-center gap-1", className)}>
			{[...Array(maxRating)].map((_, i) => (
				<Star
					key={i}
					className={cn(
						starSize,
						i < validRating
							? "text-yellow-500 fill-yellow-500" // Filled star
							: "text-gray-300 dark:text-gray-600" // Empty star
					)}
				/>
			))}
		</div>
	);
}
</file>

<file path="frontend/src/components/ui/table.tsx">
"use client"

import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-muted-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="frontend/src/components/ui/tabs.tsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-1",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring inline-flex items-center justify-center gap-1.5 rounded-md px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="frontend/src/components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }
</file>

<file path="frontend/src/components/ui/tooltip.tsx">
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = ({ 
  children, 
  content, 
  width, 
  minWidth, 
  maxWidth = "360px", 
  ...props 
}: { 
  children: React.ReactNode
  content: React.ReactNode
  width?: string
  minWidth?: string
  maxWidth?: string
} & React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Root>) => {
  const styleProps: React.CSSProperties = {}
  if (width) styleProps.width = width
  if (minWidth) styleProps.minWidth = minWidth
  if (maxWidth) styleProps.maxWidth = maxWidth

  return (
    <TooltipPrimitive.Root {...props}>
      <TooltipPrimitive.Trigger asChild>
        {children}
      </TooltipPrimitive.Trigger>
      <TooltipPrimitive.Content
        side="top"
        align="center"
        sideOffset={4}
        style={styleProps}
        className={cn(
          "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2"
        )}
      >
        {content}
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Root>
  )
}

export { Tooltip, TooltipProvider }
</file>

<file path="frontend/src/lib/api/useTechniques.ts">
// src/lib/api/useTechniques.ts
/**
 * @deprecated This file is maintained for backward compatibility.
 * Import from hooks.ts directly instead.
 */

import {
	useTechniques,
	useCreateTechnique,
	useUpdateTechnique,
	useDeleteTechnique,
} from "./hooks";
import type { Technique } from "@/lib/types";

// Re-export with legacy name for backward compatibility
export const useAddTechnique = useCreateTechnique;

// Re-export other hooks with their standard names
export { useTechniques, useUpdateTechnique, useDeleteTechnique };

// Re-export the updated type
export type { Technique };
</file>

<file path="frontend/src/lib/providers/query-provider.tsx">
"use client";

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactNode, useState } from "react";

export function QueryProvider({ children }: { children: ReactNode }) {
	const [queryClient] = useState(
		() =>
			new QueryClient({
				defaultOptions: {
					queries: {
						staleTime: 60 * 1000, // 1 minute
						refetchOnWindowFocus: false,
					},
				},
			})
	);

	return (
		<QueryClientProvider client={queryClient}>
			{children}
		</QueryClientProvider>
	);
}
</file>

<file path="frontend/src/lib/constants.ts">
export const APP_TITLE = "TEA Techniques Database";
export const APP_DESCRIPTION =
	"A database of techniques to help assure your responsible design, development, and deployment of AI technologies.";
</file>

<file path="frontend/src/lib/utils.ts">
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";
import { TechniqueAttribute } from "./types";

export function cn(...inputs: ClassValue[]) {
	return twMerge(clsx(inputs));
}

export function getTechniqueRatings(attributes: TechniqueAttribute[]) {
	let complexity = 0;
	let computationalCost = 0;

	// Extract ratings from attributes
	attributes.forEach((attr) => {
		if (attr.attribute_type === "Complexity") {
			complexity = Number(attr.attribute_value_name) || 0;
		}
		if (attr.attribute_type === "Computational Cost") {
			computationalCost = Number(attr.attribute_value_name) || 0;
		}
	});

	return { complexity, computationalCost };
}
</file>

<file path="frontend/src/providers/query-provider.tsx">
// frontend/src/providers/query-provider.tsx
"use client";

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import React from "react";

const queryClient = new QueryClient();

const ReactQueryProvider = ({ children }: { children: React.ReactNode }) => {
	return (
		<QueryClientProvider client={queryClient}>
			{children}
		</QueryClientProvider>
	);
};

export default ReactQueryProvider;
</file>

<file path="frontend/src/styles/globals.css">
@import "tailwindcss";

@plugin "tailwindcss-animate";

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;

    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;

    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;

    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;

    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;

    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;

    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;

    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;

    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;

    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;

    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;

    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;

    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;

    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;

    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;

    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;

    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
    font-feature-settings: "rlig" 1, "calt" 1;
  }
}
</file>

<file path="frontend/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# repomix
repomix-output.txt
</file>

<file path="frontend/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="frontend/eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="frontend/jest.config.ts">
import type { Config } from 'jest';
import nextJest from 'next/jest';

const createJestConfig = nextJest({
  // Provide the path to your Next.js app to load next.config.js and .env files in your test environment
  dir: './',
});

// Add any custom config to be passed to Jest
const config: Config = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],
  testEnvironment: 'jest-environment-jsdom',
  preset: 'ts-jest',
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  testMatch: ['**/*.test.ts', '**/*.test.tsx'],
  collectCoverage: true,
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/_*.{ts,tsx}',
    '!src/app/api/**',
  ],
};

// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async
export default createJestConfig(config);
</file>

<file path="frontend/postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="frontend/tailwind.config.ts">
// frontend/tailwind.config.ts
import type { Config } from "tailwindcss";
import typographyPlugin from "@tailwindcss/typography";

const config: Config = {
	content: ["./src/**/*.{js,ts,jsx,tsx}"],
	theme: {
		extend: {},
	},
	plugins: [
		typographyPlugin,
		// other plugins you might be using
	],
};

export default config;
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Christopher Burr

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="backend/api/tests/factories.py">
import factory
from faker import Faker
from api.models import (
    Technique,
    Category,
    SubCategory,
    AssuranceGoal,
    Tag,
    AttributeType,
    AttributeValue,
    ResourceType,
    TechniqueResource,
    TechniqueExampleUseCase,
    TechniqueLimitation,
)

fake = Faker()


class AssuranceGoalFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = AssuranceGoal

    name = factory.LazyFunction(lambda: fake.unique.word().capitalize())
    description = factory.LazyFunction(lambda: fake.paragraph())


class CategoryFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = Category

    name = factory.LazyFunction(lambda: fake.unique.word().capitalize())
    description = factory.LazyFunction(lambda: fake.paragraph())
    assurance_goal = factory.SubFactory(AssuranceGoalFactory)


class SubCategoryFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = SubCategory

    name = factory.LazyFunction(lambda: fake.unique.word().capitalize())
    description = factory.LazyFunction(lambda: fake.paragraph())
    category = factory.SubFactory(CategoryFactory)


class TagFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = Tag

    name = factory.LazyFunction(lambda: fake.unique.word().capitalize())


class AttributeTypeFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = AttributeType

    name = factory.LazyFunction(lambda: fake.unique.word().capitalize())
    description = factory.LazyFunction(lambda: fake.paragraph())

    @factory.post_generation
    def applicable_goals(self, create, extracted, **kwargs):
        if not create:
            return

        if extracted:
            for goal in extracted:
                self.applicable_goals.add(goal)

    @factory.post_generation
    def required_for_goals(self, create, extracted, **kwargs):
        if not create:
            return

        if extracted:
            for goal in extracted:
                self.required_for_goals.add(goal)


class AttributeValueFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = AttributeValue

    name = factory.LazyFunction(lambda: fake.word().capitalize())
    description = factory.LazyFunction(lambda: fake.sentence())
    attribute_type = factory.SubFactory(AttributeTypeFactory)
    technique = factory.SubFactory('api.tests.factories.TechniqueFactory')


class ResourceTypeFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = ResourceType

    name = factory.LazyFunction(lambda: fake.unique.word().capitalize())
    icon = factory.LazyFunction(lambda: fake.word().lower())


class TechniqueFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = Technique

    name = factory.LazyFunction(lambda: fake.unique.sentence(nb_words=3))
    description = factory.LazyFunction(lambda: fake.paragraph())
    model_dependency = factory.LazyFunction(
        lambda: fake.random_element(elements=("Model-Agnostic", "Model-Specific"))
    )

    @factory.post_generation
    def assurance_goals(self, create, extracted, **kwargs):
        if not create:
            return

        if extracted:
            for goal in extracted:
                self.assurance_goals.add(goal)
        else:
            self.assurance_goals.add(AssuranceGoalFactory())

    @factory.post_generation
    def categories(self, create, extracted, **kwargs):
        if not create:
            return

        if extracted:
            for category in extracted:
                self.categories.add(category)
        else:
            self.categories.add(CategoryFactory())

    @factory.post_generation
    def subcategories(self, create, extracted, **kwargs):
        if not create:
            return

        if extracted:
            for subcategory in extracted:
                self.subcategories.add(subcategory)

    @factory.post_generation
    def tags(self, create, extracted, **kwargs):
        if not create:
            return

        if extracted:
            for tag in extracted:
                self.tags.add(tag)


# TechniqueAttribute has been replaced with AttributeValue
# that directly links to Technique
class AttributeValueFactoryWithTechnique(factory.django.DjangoModelFactory):
    class Meta:
        model = AttributeValue

    technique = factory.SubFactory(TechniqueFactory)
    attribute_type = factory.SubFactory(AttributeTypeFactory)
    name = factory.LazyFunction(lambda: fake.word().capitalize())
    description = factory.LazyFunction(lambda: fake.sentence())


class TechniqueResourceFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = TechniqueResource

    technique = factory.SubFactory(TechniqueFactory)
    resource_type = factory.SubFactory(ResourceTypeFactory)
    title = factory.LazyFunction(lambda: fake.sentence())
    url = factory.LazyFunction(lambda: fake.url())
    description = factory.LazyFunction(lambda: fake.paragraph())


class TechniqueExampleUseCaseFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = TechniqueExampleUseCase

    technique = factory.SubFactory(TechniqueFactory)
    description = factory.LazyFunction(lambda: fake.paragraph())
    assurance_goal = factory.SubFactory(AssuranceGoalFactory)


class TechniqueLimitationFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = TechniqueLimitation

    technique = factory.SubFactory(TechniqueFactory)
    description = factory.LazyFunction(lambda: fake.paragraph())
</file>

<file path="backend/api/tests/test_api.py">
from django.test import TestCase
from rest_framework import status
from rest_framework.test import APITestCase, APIClient
from api.models import (
    Technique,
    AssuranceGoal,
    Category,
    SubCategory,
    Tag,
    AttributeType,
    AttributeValue,
    ResourceType,
)
from api.tests.factories import (
    TechniqueFactory,
    CategoryFactory,
    SubCategoryFactory,
    AssuranceGoalFactory,
    TagFactory,
    AttributeTypeFactory,
    AttributeValueFactory,
    ResourceTypeFactory,
)
import json


class ApiEndpointTestCase(APITestCase):
    """Test that all API endpoints return 200 OK using direct URLs"""

    def setUp(self):
        # Create base objects for relationships
        self.assurance_goal = AssuranceGoalFactory()
        self.category = CategoryFactory(assurance_goal=self.assurance_goal)
        self.subcategory = SubCategoryFactory(category=self.category)
        self.tag = TagFactory()
        self.attribute_type = AttributeTypeFactory()
        self.attribute_value = AttributeValueFactory(attribute_type=self.attribute_type)
        self.resource_type = ResourceTypeFactory()
        self.technique = TechniqueFactory(
            assurance_goals=[self.assurance_goal],
            categories=[self.category],
            subcategories=[self.subcategory],
            tags=[self.tag],
        )

        # Create a client
        self.client = APIClient()

    def test_api_root(self):
        """Test that API root works"""
        response = self.client.get("/api/")
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    def test_assurance_goals_list(self):
        """Test the assurance goals endpoint"""
        response = self.client.get("/api/assurance-goals/")
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    def test_categories_list(self):
        """Test the categories endpoint"""
        response = self.client.get("/api/categories/")
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    def test_subcategories_list(self):
        """Test the subcategories endpoint"""
        response = self.client.get("/api/subcategories/")
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    def test_tags_list(self):
        """Test the tags endpoint"""
        response = self.client.get("/api/tags/")
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    def test_techniques_list(self):
        """Test the techniques endpoint"""
        response = self.client.get("/api/techniques/")
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    def test_attribute_types_list(self):
        """Test the attribute types endpoint"""
        response = self.client.get("/api/attribute-types/")
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    def test_attribute_values_list(self):
        """Test the attribute values endpoint"""
        response = self.client.get("/api/attribute-values/")
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    def test_resource_types_list(self):
        """Test the resource types endpoint"""
        response = self.client.get("/api/resource-types/")
        self.assertEqual(response.status_code, status.HTTP_200_OK)


class TechniqueAPITestCase(APITestCase):
    """Test Techniques API CRUD operations using direct URLs"""

    def setUp(self):
        self.assurance_goal = AssuranceGoalFactory(name="Explainability")
        self.category = CategoryFactory(
            name="Feature Analysis", assurance_goal=self.assurance_goal
        )
        self.subcategory = SubCategoryFactory(
            name="Importance and Attribution", category=self.category
        )
        self.tag1 = TagFactory(name="Machine Learning")
        self.tag2 = TagFactory(name="Neural Networks")

        # Create attribute types and values
        self.scope_type = AttributeTypeFactory(name="Scope")
        self.global_value = AttributeValueFactory(
            name="Global", attribute_type=self.scope_type
        )
        self.local_value = AttributeValueFactory(
            name="Local", attribute_type=self.scope_type
        )

        # Create resource types
        self.paper_type = ResourceTypeFactory(name="Paper", icon="paper")
        self.github_type = ResourceTypeFactory(name="GitHub", icon="github")

        # Create sample techniques
        self.technique1 = TechniqueFactory(
            name="SHAP",
            description="SHapley Additive exPlanations",
            model_dependency="Model-Agnostic",
            assurance_goals=[self.assurance_goal],
            categories=[self.category],
            subcategories=[self.subcategory],
            tags=[self.tag1],
        )

        self.technique2 = TechniqueFactory(
            name="Grad-CAM",
            description="Gradient-weighted Class Activation Mapping",
            model_dependency="Model-Specific",
            assurance_goals=[self.assurance_goal],
            categories=[self.category],
            subcategories=[self.subcategory],
            tags=[self.tag1, self.tag2],
        )

        # URL for technique operations
        self.techniques_url = "/api/techniques/"

        # Create a client
        self.client = APIClient()

    def test_get_technique_list(self):
        """Test retrieving a list of techniques"""
        response = self.client.get(self.techniques_url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        data = response.json()

        # Check pagination structure
        self.assertIn("count", data)
        self.assertIn("results", data)

        # Should have at least our 2 created techniques
        self.assertGreaterEqual(data["count"], 2)

        # Check if our created techniques are in the results
        technique_names = [t["name"] for t in data["results"]]
        self.assertIn(self.technique1.name, technique_names)
        self.assertIn(self.technique2.name, technique_names)

    def test_get_technique_detail(self):
        """Test retrieving a specific technique"""
        url = f"{self.techniques_url}{self.technique1.id}/"
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        data = response.json()
        self.assertEqual(data["name"], self.technique1.name)
        self.assertEqual(data["description"], self.technique1.description)
        self.assertEqual(data["model_dependency"], self.technique1.model_dependency)

        # Check relationships
        self.assertEqual(len(data["assurance_goals"]), 1)
        self.assertEqual(data["assurance_goals"][0]["name"], self.assurance_goal.name)

        self.assertEqual(len(data["categories"]), 1)
        self.assertEqual(data["categories"][0]["name"], self.category.name)

        self.assertEqual(len(data["subcategories"]), 1)
        self.assertEqual(data["subcategories"][0]["name"], self.subcategory.name)

        self.assertEqual(len(data["tags"]), 1)
        self.assertEqual(data["tags"][0]["name"], self.tag1.name)

    def test_create_technique(self):
        """Test creating a technique with associated relationships"""
        # Create a complex technique with all relationships
        data = {
            "name": "New Test Technique",
            "description": "Description for new test technique",
            "model_dependency": "Model-Agnostic",
            "assurance_goal_ids": [self.assurance_goal.id],
            "category_ids": [self.category.id],
            "subcategory_ids": [self.subcategory.id],
            "tag_ids": [self.tag1.id, self.tag2.id],
            "attributes": [
                {
                    "attribute_type": self.scope_type.id,
                    "attribute_value": self.global_value.id,
                }
            ],
            "resources": [
                {
                    "resource_type": self.paper_type.id,
                    "title": "Test Paper",
                    "url": "https://example.com/paper",
                    "description": "A test paper",
                },
                {
                    "resource_type": self.github_type.id,
                    "title": "GitHub Repo",
                    "url": "https://github.com/test/repo",
                    "description": "Repository for the technique",
                },
            ],
            "example_use_cases": [
                {
                    "description": "Example use case 1",
                    "assurance_goal": self.assurance_goal.id,
                }
            ],
            "limitations": ["Limitation 1", "Limitation 2"],
        }

        response = self.client.post(
            self.techniques_url, data=json.dumps(data), content_type="application/json"
        )

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Technique.objects.count(), 3)

        # Verify created technique
        created_technique = Technique.objects.get(name="New Test Technique")
        self.assertEqual(
            created_technique.description, "Description for new test technique"
        )
        self.assertEqual(created_technique.model_dependency, "Model-Agnostic")

        # Check relationships
        self.assertEqual(created_technique.assurance_goals.count(), 1)
        self.assertEqual(created_technique.categories.count(), 1)
        self.assertEqual(created_technique.subcategories.count(), 1)
        self.assertEqual(created_technique.tags.count(), 2)
        self.assertEqual(created_technique.attribute_values.count(), 1)
        self.assertEqual(created_technique.resources.count(), 2)
        self.assertEqual(created_technique.example_use_cases.count(), 1)
        self.assertEqual(created_technique.limitations.count(), 2)

    def test_update_technique(self):
        """Test updating a technique"""
        url = f"{self.techniques_url}{self.technique1.id}/"

        # Update the technique
        data = {
            "name": "Updated SHAP",
            "description": "Updated description for SHAP",
            "model_dependency": self.technique1.model_dependency,
            "assurance_goal_ids": [self.assurance_goal.id],
            "category_ids": [self.category.id],
            "subcategory_ids": [self.subcategory.id],
            "tag_ids": [self.tag1.id, self.tag2.id],  # Add a new tag
        }

        response = self.client.put(
            url, data=json.dumps(data), content_type="application/json"
        )

        self.assertEqual(response.status_code, status.HTTP_200_OK)

        # Verify the update in the database
        self.technique1.refresh_from_db()
        self.assertEqual(self.technique1.name, "Updated SHAP")
        self.assertEqual(self.technique1.description, "Updated description for SHAP")
        self.assertEqual(self.technique1.tags.count(), 2)

    def test_partial_update_technique(self):
        """Test partially updating a technique"""
        url = f"{self.techniques_url}{self.technique1.id}/"

        # Partially update the technique (only name)
        data = {"name": "Partially Updated SHAP"}

        response = self.client.patch(
            url, data=json.dumps(data), content_type="application/json"
        )

        self.assertEqual(response.status_code, status.HTTP_200_OK)

        # Verify the update in the database
        self.technique1.refresh_from_db()
        self.assertEqual(self.technique1.name, "Partially Updated SHAP")
        # Description should remain unchanged
        self.assertEqual(self.technique1.description, "SHapley Additive exPlanations")

    def test_delete_technique(self):
        """Test deleting a technique"""
        url = f"{self.techniques_url}{self.technique1.id}/"
        response = self.client.delete(url)

        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)
        self.assertEqual(Technique.objects.count(), 1)
        self.assertFalse(Technique.objects.filter(id=self.technique1.id).exists())

    def test_filter_techniques_by_assurance_goal(self):
        """Test filtering techniques by assurance goal"""
        # Create a new assurance goal and technique for testing filters
        fairness_goal = AssuranceGoalFactory(name="Fairness")
        fairness_technique = TechniqueFactory(
            name="Equal Opportunity", assurance_goals=[fairness_goal]
        )

        # Filter by original assurance goal
        url = f"{self.techniques_url}?assurance_goals={self.assurance_goal.id}"
        response = self.client.get(url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        data = response.json()

        # Should only include techniques with this assurance goal
        self.assertEqual(data["count"], 2)
        technique_names = [t["name"] for t in data["results"]]
        self.assertIn(self.technique1.name, technique_names)
        self.assertIn(self.technique2.name, technique_names)
        self.assertNotIn(fairness_technique.name, technique_names)

    def test_filter_techniques_by_category(self):
        """Test filtering techniques by category"""
        # Create a new category and technique for testing filters
        new_category = CategoryFactory(
            name="New Category", assurance_goal=self.assurance_goal
        )
        new_technique = TechniqueFactory(
            name="New Technique",
            categories=[new_category],
            assurance_goals=[self.assurance_goal],
        )

        # Filter by original category
        url = f"{self.techniques_url}?categories={self.category.id}"
        response = self.client.get(url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        data = response.json()

        # Should only include techniques with this category
        technique_names = [t["name"] for t in data["results"]]
        self.assertIn(self.technique1.name, technique_names)
        self.assertIn(self.technique2.name, technique_names)
        self.assertNotIn(new_technique.name, technique_names)

    def test_filter_techniques_by_search(self):
        """Test searching techniques by name or description"""
        # Search by partial name
        url = f"{self.techniques_url}?search=SHAP"
        response = self.client.get(url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        data = response.json()

        self.assertGreaterEqual(data["count"], 1)
        technique_names = [t["name"] for t in data["results"]]
        self.assertIn(self.technique1.name, technique_names)

        # Search by partial description
        url = f"{self.techniques_url}?search=Class+Activation"
        response = self.client.get(url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        data = response.json()

        self.assertGreaterEqual(data["count"], 1)
        technique_names = [t["name"] for t in data["results"]]
        self.assertIn(self.technique2.name, technique_names)

    def test_filter_techniques_by_model_dependency(self):
        """Test filtering techniques by model dependency"""
        url = f"{self.techniques_url}?model_dependency=Model-Agnostic"
        response = self.client.get(url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        data = response.json()

        # Should only include techniques with this model dependency
        self.assertGreaterEqual(data["count"], 1)
        technique_names = [t["name"] for t in data["results"]]
        self.assertIn(self.technique1.name, technique_names)
        self.assertNotIn(self.technique2.name, technique_names)

    def test_filter_techniques_by_tag(self):
        """Test filtering techniques by tag"""
        # Create a technique with only tag2
        tag_only_technique = TechniqueFactory(
            name="Tag Only Technique", tags=[self.tag2]
        )

        # Filter by tag1
        url = f"{self.techniques_url}?tags={self.tag1.id}"
        response = self.client.get(url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        data = response.json()

        # Should only include techniques with this tag
        technique_names = [t["name"] for t in data["results"]]
        self.assertIn(self.technique1.name, technique_names)
        self.assertIn(self.technique2.name, technique_names)
        self.assertNotIn(tag_only_technique.name, technique_names)

    def test_pagination(self):
        """Test that pagination works"""
        # Create 10 more techniques to test pagination
        for i in range(10):
            TechniqueFactory(name=f"Pagination Test Technique {i}")

        # Get first page (default page size is defined in settings)
        response = self.client.get(self.techniques_url)
        data = response.json()

        self.assertIn("count", data)
        self.assertIn("next", data)
        self.assertIn("previous", data)
        self.assertIn("results", data)

        # Should have at least 12 techniques in total (2 from setup + 10 created here)
        self.assertGreaterEqual(data["count"], 12)

        # If next page exists, check it
        if data["next"]:
            response = self.client.get(data["next"])
            self.assertEqual(response.status_code, status.HTTP_200_OK)
            data = response.json()
            self.assertIn("results", data)

    def test_relation_specific_endpoints(self):
        """Test the endpoints for filtering categories and subcategories by parent"""
        # Test categories by assurance goal
        url = f"/api/categories-by-goal/{self.assurance_goal.id}/"
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        data = response.json()

        # Should include the category created in setup
        category_ids = [c["id"] for c in data]
        self.assertIn(self.category.id, category_ids)

        # Test subcategories by category
        url = f"/api/subcategories-by-category/{self.category.id}/"
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        data = response.json()

        # Should include the subcategory created in setup
        subcategory_ids = [sc["id"] for sc in data]
        self.assertIn(self.subcategory.id, subcategory_ids)

    def test_debug_endpoint(self):
        """Test that the debug endpoint works"""
        url = "/api/debug/"

        # Test GET
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        # Test POST
        test_data = {"test": "data"}
        response = self.client.post(
            url, data=json.dumps(test_data), content_type="application/json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        # Check that our test data was echoed back
        data = response.json()
        self.assertIn("received_data", data)
        self.assertEqual(data["received_data"], test_data)

    def test_category_tags_compatibility(self):
        """Test that techniques created with category_tags format work with the API"""
        # Create a technique with specific categories that mimics one created from the new CSV format
        goal_name = "Explainability"
        cat_name = "feature-analysis"
        subcat_name = "importance-and-attribution"

        goal, _ = AssuranceGoal.objects.get_or_create(name=goal_name)
        category, _ = Category.objects.get_or_create(name=cat_name, assurance_goal=goal)
        subcategory, _ = SubCategory.objects.get_or_create(
            name=subcat_name, category=category
        )

        # Create technique and link relationships to mimic import from category_tags
        technique = TechniqueFactory(
            name="Category Tags Test Technique",
            assurance_goals=[goal],
        )
        technique.categories.add(category)
        technique.subcategories.add(subcategory)

        # Test retrieving and filtering
        response = self.client.get(f"{self.techniques_url}{technique.id}/")
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.json()["name"], technique.name)

        # Test filtering by category
        response = self.client.get(f"{self.techniques_url}?categories={category.id}")
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertIn(technique.name, [t["name"] for t in response.json()["results"]])
</file>

<file path="backend/api/tests/test_error_handling.py">
from rest_framework.test import APIClient
from rest_framework import status
import pytest
from django.urls import reverse
from django.contrib.auth.models import User


@pytest.mark.django_db
class TestErrorHandling:
    def setup_method(self):
        # Create test user
        self.username = "testuser"
        self.password = "testpassword"
        self.user = User.objects.create_user(
            username=self.username, 
            password=self.password,
            email="test@example.com"
        )
        
        self.client = APIClient()
        # Use the base API URL without trailing slash as configured in urls.py
        self.techniques_url = "/api/techniques"
    
    def test_not_found_error_format(self):
        """Test that 404 errors return the standardized error format."""
        # Try to access a non-existent technique ID
        response = self.client.get(f"{self.techniques_url}/99999")
        
        assert response.status_code == status.HTTP_404_NOT_FOUND
        
        # Check the response has our standardized format
        assert "detail" in response.data
        assert "status_code" in response.data
        assert "error_type" in response.data
        
        # The exact wording may vary, so just check for status code and error type
        assert response.data["status_code"] == 404
    
    def test_bad_request_error_format(self):
        """Test that bad request errors return the standardized error format."""
        # Authenticate first since we need to create a technique
        self.client.force_authenticate(user=self.user)
        
        # Create a technique with invalid data (missing required fields)
        response = self.client.post(self.techniques_url, 
                                    {"name": ""}, # Empty name is invalid
                                    format="json")
        
        # Now verify the error format
        assert response.status_code == status.HTTP_400_BAD_REQUEST
        
        # Check standardized error format
        assert "detail" in response.data
        assert "status_code" in response.data
        assert "error_type" in response.data
        
        # Should have either errors or the detail message
        assert response.data["status_code"] == 400
        assert response.data["error_type"] == "ValidationError"
        
    def test_permission_error_format(self):
        """Test that permission errors return the standardized error format."""
        # In Django REST Framework, unauthenticated requests that need authentication
        # often return 403 Forbidden rather than 401 Unauthorized
        response = self.client.post(
            self.techniques_url,
            {"name": "Test Technique", "description": "Description"},
            format="json"
        )
        
        assert response.status_code == status.HTTP_403_FORBIDDEN
        
        # Check standardized error format
        assert "detail" in response.data
        assert "status_code" in response.data
        assert "error_type" in response.data
        
        assert response.data["status_code"] == 403
    
    def test_create_error_format(self):
        """Test that validation errors during creation return the standardized error format."""
        # Authenticate as a regular user
        self.client.force_authenticate(user=self.user)
        
        # Create a technique with missing required fields
        invalid_data = {
            "name": "Test Technique",
            # Missing model_dependency which is required
        }
        
        response = self.client.post(self.techniques_url, invalid_data, format="json")
        
        # It should give a validation error
        assert response.status_code == status.HTTP_400_BAD_REQUEST
        
        # Check standardized error format
        assert "detail" in response.data
        assert "status_code" in response.data
        assert "error_type" in response.data
        assert "errors" in response.data
        
        assert response.data["status_code"] == 400
        assert response.data["error_type"] == "ValidationError"
</file>

<file path="backend/api/tests/test_models.py">
from django.test import TestCase
from api.models import (
    Technique,
    Category,
    SubCategory,
    AssuranceGoal,
    Tag,
    AttributeType,
    AttributeValue,
    ResourceType,
    TechniqueResource,
    TechniqueExampleUseCase,
    TechniqueLimitation,
)
from api.tests.factories import (
    TechniqueFactory,
    CategoryFactory,
    SubCategoryFactory,
    AssuranceGoalFactory,
    TagFactory,
    AttributeTypeFactory,
    AttributeValueFactory,
    AttributeValueFactoryWithTechnique,
    ResourceTypeFactory,
    TechniqueResourceFactory,
    TechniqueExampleUseCaseFactory,
    TechniqueLimitationFactory,
)


class ModelTestCase(TestCase):
    def test_assurance_goal_creation(self):
        """Test that an AssuranceGoal can be created"""
        goal = AssuranceGoalFactory(name="Test Goal", description="Test description")
        self.assertEqual(goal.name, "Test Goal")
        self.assertEqual(goal.description, "Test description")
        self.assertEqual(str(goal), "Test Goal")

    def test_category_creation(self):
        """Test that a Category can be created"""
        goal = AssuranceGoalFactory()
        category = CategoryFactory(name="Test Category", assurance_goal=goal)
        self.assertEqual(category.name, "Test Category")
        self.assertTrue(category.id)
        self.assertEqual(category.assurance_goal, goal)
        self.assertIn(f"({goal.name})", str(category))

    def test_subcategory_creation(self):
        """Test that a SubCategory can be created"""
        category = CategoryFactory()
        subcategory = SubCategoryFactory(name="Test SubCategory", category=category)
        self.assertEqual(subcategory.name, "Test SubCategory")
        self.assertEqual(subcategory.category, category)
        self.assertIn(category.name, str(subcategory))

    def test_tag_creation(self):
        """Test that a Tag can be created"""
        tag = TagFactory(name="TestTag")
        self.assertEqual(tag.name, "TestTag")
        self.assertEqual(str(tag), "TestTag")

    def test_attribute_type_creation(self):
        """Test that an AttributeType can be created"""
        attr_type = AttributeTypeFactory(
            name="Test Type", description="Test description"
        )
        self.assertEqual(attr_type.name, "Test Type")
        self.assertEqual(attr_type.description, "Test description")
        self.assertEqual(str(attr_type), "Test Type")

    def test_attribute_value_creation(self):
        """Test that an AttributeValue can be created"""
        attr_type = AttributeTypeFactory(name="Test Type")
        technique = TechniqueFactory()
        attr_value = AttributeValueFactory(
            name="Test Value", 
            description="Test description", 
            attribute_type=attr_type,
            technique=technique
        )
        self.assertEqual(attr_value.name, "Test Value")
        self.assertEqual(attr_value.attribute_type, attr_type)
        self.assertEqual(attr_value.technique, technique)
        self.assertEqual(str(attr_value), "Test Type: Test Value")

    def test_resource_type_creation(self):
        """Test that a ResourceType can be created"""
        resource_type = ResourceTypeFactory(name="Test Resource", icon="test-icon")
        self.assertEqual(resource_type.name, "Test Resource")
        self.assertEqual(resource_type.icon, "test-icon")
        self.assertEqual(str(resource_type), "Test Resource")

    def test_technique_creation(self):
        """Test that a Technique can be created"""
        technique = TechniqueFactory(
            name="Test Technique",
            description="Test description",
            model_dependency="Model-Agnostic",
        )
        self.assertEqual(technique.name, "Test Technique")
        self.assertEqual(technique.description, "Test description")
        self.assertEqual(technique.model_dependency, "Model-Agnostic")
        self.assertEqual(str(technique), "Test Technique")

    def test_technique_relationships(self):
        """Test that a Technique can have relationships with other models"""
        goal = AssuranceGoalFactory()
        category = CategoryFactory(assurance_goal=goal)
        subcategory = SubCategoryFactory(category=category)
        tag = TagFactory()

        technique = TechniqueFactory(
            assurance_goals=[goal],
            categories=[category],
            subcategories=[subcategory],
            tags=[tag],
        )

        # Test relationships
        self.assertEqual(technique.assurance_goals.count(), 1)
        self.assertEqual(technique.assurance_goals.first(), goal)

        self.assertEqual(technique.categories.count(), 1)
        self.assertEqual(technique.categories.first(), category)

        self.assertEqual(technique.subcategories.count(), 1)
        self.assertEqual(technique.subcategories.first(), subcategory)

        self.assertEqual(technique.tags.count(), 1)
        self.assertEqual(technique.tags.first(), tag)

    def test_technique_attribute_relationship(self):
        """Test that a Technique can have attributes"""
        technique = TechniqueFactory()
        attr_type = AttributeTypeFactory(name="Scope")
        
        # Now AttributeValue links directly to Technique
        attr_value = AttributeValueFactoryWithTechnique(
            technique=technique, 
            attribute_type=attr_type,
            name="Global"
        )

        self.assertEqual(attr_value.technique, technique)
        self.assertEqual(attr_value.attribute_type, attr_type)
        self.assertEqual(attr_value.name, "Global")
        self.assertEqual(str(attr_value), "Scope: Global")

    def test_technique_resource_relationship(self):
        """Test that a Technique can have resources"""
        technique = TechniqueFactory()
        resource_type = ResourceTypeFactory(name="Paper")

        resource = TechniqueResourceFactory(
            technique=technique,
            resource_type=resource_type,
            title="Test Paper",
            url="https://example.com/paper",
            description="A test paper",
        )

        self.assertEqual(resource.technique, technique)
        self.assertEqual(resource.resource_type, resource_type)
        self.assertEqual(resource.title, "Test Paper")
        self.assertEqual(resource.url, "https://example.com/paper")
        self.assertEqual(str(resource), "Paper: Test Paper")

    def test_technique_use_case_relationship(self):
        """Test that a Technique can have example use cases"""
        technique = TechniqueFactory()
        goal = AssuranceGoalFactory()

        use_case = TechniqueExampleUseCaseFactory(
            technique=technique, description="Test use case", assurance_goal=goal
        )

        self.assertEqual(use_case.technique, technique)
        self.assertEqual(use_case.description, "Test use case")
        self.assertEqual(use_case.assurance_goal, goal)
        self.assertIn(technique.name, str(use_case))

    def test_technique_limitation_relationship(self):
        """Test that a Technique can have limitations"""
        technique = TechniqueFactory()

        limitation = TechniqueLimitationFactory(
            technique=technique, description="Test limitation"
        )

        self.assertEqual(limitation.technique, technique)
        self.assertEqual(limitation.description, "Test limitation")
        self.assertIn(technique.name, str(limitation))
</file>

<file path="backend/api/views/auth_views.py">
# api/views/auth_views.py
from django.contrib.auth import authenticate, login, logout
from django.middleware.csrf import get_token
from django.http import JsonResponse
from django.views.decorators.http import require_POST
from django.views.decorators.csrf import ensure_csrf_cookie
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.response import Response
from rest_framework import status

import json
import logging

logger = logging.getLogger(__name__)

@api_view(['GET'])
@permission_classes([AllowAny])
@ensure_csrf_cookie
def get_csrf(request):
    """
    Get CSRF token for the front end
    """
    csrf_token = get_token(request)
    return Response({"csrfToken": csrf_token})

@api_view(['POST'])
@permission_classes([AllowAny])
def login_view(request):
    """
    Log in a user
    """
    data = json.loads(request.body)
    username = data.get('username')
    password = data.get('password')

    if not username or not password:
        return Response(
            {"detail": "Please provide both username and password"},
            status=status.HTTP_400_BAD_REQUEST
        )

    # Authenticate the user
    user = authenticate(request, username=username, password=password)

    if user is not None:
        login(request, user)
        return Response({
            "id": user.id,
            "username": user.username,
            "email": user.email,
            "isStaff": user.is_staff,
        })
    else:
        return Response(
            {"detail": "Invalid credentials"},
            status=status.HTTP_401_UNAUTHORIZED
        )

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def logout_view(request):
    """
    Log out a user
    """
    logout(request)
    return Response({"detail": "Successfully logged out"})

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def user_view(request):
    """
    Get the current user's information
    """
    user = request.user
    return Response({
        "id": user.id,
        "username": user.username,
        "email": user.email,
        "isStaff": user.is_staff,
    })

@api_view(['GET'])
@permission_classes([AllowAny])
def auth_status_view(request):
    """
    Check if the user is authenticated
    """
    if request.user.is_authenticated:
        return Response({
            "isAuthenticated": True,
            "user": {
                "id": request.user.id,
                "username": request.user.username,
                "email": request.user.email,
                "isStaff": request.user.is_staff,
            }
        })
    else:
        return Response({"isAuthenticated": False})
</file>

<file path="backend/config/settings/__init__.py">
"""
Django settings package for the project.
Default imports come from the base settings module.
"""

from .base import *  # noqa
</file>

<file path="backend/config/settings/base.py">
"""
Base settings for the project.
Contains settings common to all environments.
"""

import os
import sys
from pathlib import Path
from dotenv import load_dotenv

# Load .env file
load_dotenv()

# Build paths inside the project like this: BASE_DIR / 'subdir'.
# Note: need to go one level higher than before due to settings module structure
BASE_DIR = Path(__file__).resolve().parent.parent.parent

# Static files (CSS, JavaScript, Images)
STATIC_URL = "/static/"
STATIC_ROOT = os.path.join(BASE_DIR, "staticfiles")
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, "static"),
]

# WhiteNoise settings for static files in production
WHITENOISE_USE_FINDERS = True
STATICFILES_STORAGE = "whitenoise.storage.CompressedManifestStaticFilesStorage"

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.getenv("SECRET_KEY")

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = os.getenv("DEBUG") == "True"

ALLOWED_HOSTS = os.getenv("ALLOWED_HOSTS", "localhost,127.0.0.1").split(",")

# Application definition

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "rest_framework",
    "django_filters",
    "api",
    "django_extensions",
    "corsheaders",
    "drf_yasg",
]

MIDDLEWARE = [
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "whitenoise.middleware.WhiteNoiseMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

REST_FRAMEWORK = {
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",
    "PAGE_SIZE": 20,
    "DEFAULT_FILTER_BACKENDS": [
        "django_filters.rest_framework.DjangoFilterBackend",
        "rest_framework.filters.SearchFilter",
        "rest_framework.filters.OrderingFilter",
    ],
    # Temporarily allow any access for development
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.AllowAny",
    ],
    # Exception handler to make error responses consistent
    "EXCEPTION_HANDLER": "api.utils.custom_exception_handler",
    # Make JSON the default format
    "DEFAULT_RENDERER_CLASSES": [
        "rest_framework.renderers.JSONRenderer",
        "rest_framework.renderers.BrowsableAPIRenderer",
    ],
    # Allow requests without trailing slashes
    "TRAILING_SLASH": False,
}

ROOT_URLCONF = "config.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "config.wsgi.application"

# Default PostgreSQL configuration
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": os.getenv("DB_NAME", "techniques"),
        "USER": os.getenv("DB_USER", "postgres"),
        "PASSWORD": os.getenv("DB_PASSWORD", "postgres"),
        "HOST": os.getenv("DB_HOST", "localhost"),
        "PORT": os.getenv("DB_PORT", "5432"),
    }
}

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]

# CORS settings
# Instead of enabling all origins, use explicit list for better security
CORS_ALLOW_ALL_ORIGINS = False
CORS_ALLOWED_ORIGINS = os.getenv(
    "CORS_ALLOWED_ORIGINS", 
    "http://localhost:3000,http://127.0.0.1:3000,http://localhost:3001,http://frontend:3000"
).split(",")
CORS_ALLOW_CREDENTIALS = True
CORS_EXPOSE_HEADERS = ["Content-Type", "X-CSRFToken"]

# Disable redirects to URLs with trailing slashes (Django default is True)
APPEND_SLASH = False

CORS_ALLOW_METHODS = [
    "DELETE",
    "GET",
    "OPTIONS",
    "PATCH",
    "POST",
    "PUT",
]
# Allow common headers
CORS_ALLOW_HEADERS = [
    "accept",
    "accept-encoding",
    "authorization", 
    "content-type",
    "dnt",
    "origin",
    "user-agent",
    "x-csrftoken",
    "x-requested-with",
]

# Set CSRF settings to work with CORS
CSRF_TRUSTED_ORIGINS = [
    "http://localhost:3000",
    "http://127.0.0.1:3000",
    "http://localhost:3001",
    "https://arch-webserver.tailb4d95.ts.net",
    "http://arch-webserver.tailb4d95.ts.net",
    "https://*.ts.net",
]

INTERNAL_IPS = [
    "127.0.0.1",
]

# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = "en-gb"

TIME_ZONE = "UTC"

USE_I18N = True

USE_TZ = True

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"
</file>

<file path="backend/config/settings/development.py">
"""
Development settings for the project.
Extends the base settings with development-specific settings.
"""

from .base import *  # noqa

# Set DEBUG to True for development
DEBUG = True

# Allow all hosts in development
ALLOWED_HOSTS = ["*"]

# Use more verbose error pages
DEBUG_PROPAGATE_EXCEPTIONS = True

# Add Django Debug Toolbar for development
INSTALLED_APPS += ["debug_toolbar"]  # noqa
MIDDLEWARE += ["debug_toolbar.middleware.DebugToolbarMiddleware"]  # noqa

# For Django Debug Toolbar
INTERNAL_IPS = [
    "127.0.0.1",
    "localhost",
]

# Development-specific CORS settings
CORS_ALLOWED_ORIGINS += [  # noqa
    "http://localhost:3001",
    "http://127.0.0.1:3001",
]
</file>

<file path="backend/config/settings/docker.py">
"""
Docker-specific settings for the project.
Extends the development settings with Docker-specific settings.
"""

from .development import *  # noqa

# Set the database host to the Docker service name
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": os.getenv("DB_NAME", "techniques"),  # noqa
        "USER": os.getenv("DB_USER", "postgres"),  # noqa
        "PASSWORD": os.getenv("DB_PASSWORD", "postgres"),  # noqa
        "HOST": os.getenv("DB_HOST", "db"),  # Docker service name
        "PORT": os.getenv("DB_PORT", "5432"),  # noqa
    }
}

# Allow the frontend service to access the API
CORS_ALLOWED_ORIGINS += [  # noqa
    "http://frontend:3000",
]
</file>

<file path="backend/config/settings/production.py">
"""
Production settings for the project.
Extends the base settings with production-specific settings.
"""

from .base import *  # noqa

# Disable DEBUG in production
DEBUG = False

# Security middleware settings
SECURE_HSTS_SECONDS = 31536000  # 1 year
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True
SECURE_SSL_REDIRECT = True
SESSION_COOKIE_SECURE = True
CSRF_COOKIE_SECURE = True
SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True

# Disable browsable API in production
REST_FRAMEWORK["DEFAULT_RENDERER_CLASSES"] = [  # noqa
    "rest_framework.renderers.JSONRenderer",
]
</file>

<file path="backend/config/settings/sqlite.py">
"""
SQLite settings for local development.
Extends the development settings with SQLite database.
This file is not intended for production use.

To use these settings, set the environment variable:
DJANGO_SETTINGS_MODULE=config.settings.sqlite
"""

from .development import *  # noqa

# Override database settings to use SQLite
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": os.path.join(BASE_DIR, "db.sqlite3"),  # noqa
    }
}

# Log that we're using SQLite settings
print("Using SQLite database settings for local development only")
</file>

<file path="backend/config/settings/test.py">
"""
Test settings for the project.
Extends the base settings with test-specific settings.
"""

from .base import *  # noqa

# Use in-memory SQLite for faster test execution
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": ":memory:",
    }
}

# Disable debug for tests
DEBUG = False

# Disable some middleware for faster tests
MIDDLEWARE = [
    m for m in MIDDLEWARE if not m.startswith("debug_toolbar")  # noqa
]

# Use a simpler password hasher for speed
PASSWORD_HASHERS = [
    "django.contrib.auth.hashers.MD5PasswordHasher",
]
</file>

<file path="backend/config/asgi.py">
"""
ASGI config for config project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings.production')

application = get_asgi_application()
</file>

<file path="backend/config/settings_old.py">
import os
import sys
from pathlib import Path
from dotenv import load_dotenv

# Load .env file
load_dotenv()

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Use SQLite for testing
if "test" in sys.argv or "pytest" in sys.argv[0]:
    DATABASES = {
        "default": {
            "ENGINE": "django.db.backends.sqlite3",
            "NAME": ":memory:",  # Use in-memory database for faster tests
        }
    }

# Static files (CSS, JavaScript, Images)
STATIC_URL = "/static/"
STATIC_ROOT = os.path.join(BASE_DIR, "staticfiles")
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, "static"),
]

# WhiteNoise settings for static files in production
WHITENOISE_USE_FINDERS = True
STATICFILES_STORAGE = "whitenoise.storage.CompressedManifestStaticFilesStorage"

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.getenv("SECRET_KEY")

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = os.getenv("DEBUG") == "True"

ALLOWED_HOSTS = os.getenv("ALLOWED_HOSTS").split(",")

# Application definition

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "rest_framework",
    "django_filters",
    "api",
    "django_extensions",
    "corsheaders",
    "drf_yasg",
]

MIDDLEWARE = [
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "whitenoise.middleware.WhiteNoiseMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

REST_FRAMEWORK = {
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",
    "PAGE_SIZE": 20,
    "DEFAULT_FILTER_BACKENDS": [
        "django_filters.rest_framework.DjangoFilterBackend",
        "rest_framework.filters.SearchFilter",
        "rest_framework.filters.OrderingFilter",
    ],
    # Temporarily allow any access for development
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.AllowAny",
    ],
    # Exception handler to make error responses consistent
    "EXCEPTION_HANDLER": "api.utils.custom_exception_handler",
    # Make JSON the default format
    "DEFAULT_RENDERER_CLASSES": [
        "rest_framework.renderers.JSONRenderer",
        "rest_framework.renderers.BrowsableAPIRenderer",
    ],
    # Allow requests without trailing slashes
    "TRAILING_SLASH": False,
}

ROOT_URLCONF = "config.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "config.wsgi.application"


# Database configuration using PostgreSQL by default
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": os.getenv("DB_NAME", "techniques"),
        "USER": os.getenv("DB_USER", "postgres"),
        "PASSWORD": os.getenv("DB_PASSWORD", "postgres"),
        "HOST": os.getenv("DB_HOST", "localhost"),
        "PORT": os.getenv("DB_PORT", "5432"),
    }
}

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]

# CORS settings
# Instead of enabling all origins, use explicit list for better security
CORS_ALLOW_ALL_ORIGINS = False
CORS_ALLOWED_ORIGINS = os.getenv("CORS_ALLOWED_ORIGINS", "http://localhost:3000,http://127.0.0.1:3000,http://localhost:3001,http://frontend:3000").split(",")
CORS_ALLOW_CREDENTIALS = True
CORS_EXPOSE_HEADERS = ["Content-Type", "X-CSRFToken"]

# Disable redirects to URLs with trailing slashes (Django default is True)
APPEND_SLASH = False

CORS_ALLOW_METHODS = [
    "DELETE",
    "GET",
    "OPTIONS",
    "PATCH",
    "POST",
    "PUT",
]
# Allow common headers
CORS_ALLOW_HEADERS = [
    "accept",
    "accept-encoding",
    "authorization", 
    "content-type",
    "dnt",
    "origin",
    "user-agent",
    "x-csrftoken",
    "x-requested-with",
]

# Set CSRF settings to work with CORS
CSRF_TRUSTED_ORIGINS = [
    "http://localhost:3000",
    "http://127.0.0.1:3000",
    "http://localhost:3001",
    "https://arch-webserver.tailb4d95.ts.net",
    "http://arch-webserver.tailb4d95.ts.net",
    "https://*.ts.net",
]

INTERNAL_IPS = [
    "127.0.0.1",
]

# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = "en-gb"

TIME_ZONE = "UTC"

USE_I18N = True

USE_TZ = True

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"
</file>

<file path="backend/config/settings_sqlite_old.py">
"""
SQLite settings for local development only.
This file is not intended for production use.

To use these settings, set the environment variable:
DJANGO_SETTINGS_MODULE=config.settings_sqlite
"""

from .settings import *  # noqa

# Override database settings to use SQLite
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": os.path.join(BASE_DIR, "db.sqlite3"),
    }
}

# Log that we're using SQLite settings
print("Using SQLite database settings for local development only")
</file>

<file path="backend/config/wsgi.py">
# config/wsgi.py

import os
from django.core.wsgi import get_wsgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings.production")

application = get_wsgi_application()

app = application
</file>

<file path="backend/manage.py">
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    # Default to the development settings, but allow override via environment variable
    settings_module = os.environ.get("DJANGO_SETTINGS_MODULE", "config.settings.development")
    
    # Check for test command to use test settings
    if len(sys.argv) > 1 and sys.argv[1] in ["test", "pytest"]:
        settings_module = "config.settings.test"
        
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", settings_module)
    
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == "__main__":
    main()
</file>

<file path="docs/API-GUIDE.md">
# API Guide

> [!NOTE] Overview
> The TEA Techniques application provides a RESTful API for managing and retrieving techniques for evidencing claims about responsible AI. The API is built using Django REST Framework.

## Base URL

When [deployed locally](DEPLOYMENT.md), the API is available at: `http://localhost:8000/api/`

## Authentication

> [!IMPORTANT]
> The API currently supports session-based authentication for admin access. Authentication is required for create, update, and delete operations.
>
> To authenticate:
>
> 1. Log in through the Django admin interface at `/admin/`
> 2. Session cookie will be automatically applied to subsequent API requests

## Core Endpoints

| Endpoint                              | Description                               | Methods                 |
| ------------------------------------- | ----------------------------------------- | ----------------------- |
| `/api/`                               | API root with links to all endpoints      | GET                     |
| `/api/techniques`                     | List, create, and filter techniques       | GET, POST               |
| `/api/techniques/{id}`                | Retrieve, update, delete technique        | GET, PUT, PATCH, DELETE |
| `/api/assurance-goals`                | List and manage assurance goals           | GET, POST               |
| `/api/categories`                     | List and manage categories                | GET, POST               |
| `/api/subcategories`                  | List and manage subcategories             | GET, POST               |
| `/api/tags`                           | List and manage tags                      | GET, POST               |
| `/api/categories-by-goal/{id}`        | Get categories for a specific goal        | GET                     |
| `/api/subcategories-by-category/{id}` | Get subcategories for a specific category | GET                     |
| `/api/attribute-types`                | List and manage attribute types           | GET, POST               |
| `/api/attribute-values`               | List and manage attribute values          | GET, POST               |
| `/api/resource-types`                 | List and manage resource types            | GET, POST               |

## Documentation

> [!TIP]
> Interactive API documentation is available at:
>
> - Swagger UI: `/swagger`

## Pagination

The API uses page-based pagination for list endpoints:

```json
{
  "count": 100,
  "next": "http://localhost:8000/api/techniques?page=2",
  "previous": null,
  "results": [...]
}
```

Control pagination with query parameters:

- `?page=2` - Page number
- `?page_size=50` - Results per page (default: 10)

## Filtering

The API supports filtering through query parameters:

```
/api/techniques?model_dependency=Model-Agnostic&assurance_goals=1
```

Available filters for techniques:

- `name` - Filter by name
- `model_dependency` - Filter by model dependency ("Model-Agnostic" or "Model-Specific")
- `assurance_goals` - Filter by assurance goal ID
- `categories` - Filter by category ID
- `subcategories` - Filter by subcategory ID
- `tags` - Filter by tag ID

## Searching

Search across multiple fields using the search parameter:

```
/api/techniques?search=fairness
```

This will search the name and description fields for the given term.

## Ordering

Control result ordering with the ordering parameter:

```
/api/techniques?ordering=name
/api/techniques?ordering=-name  # Descending order
```

## Error Handling

The API returns standard HTTP status codes:

- `200 OK` - Request succeeded
- `201 Created` - Resource created
- `400 Bad Request` - Invalid request (details provided)
- `401 Unauthorized` - Authentication required
- `403 Forbidden` - Authenticated but insufficient permissions
- `404 Not Found` - Resource not found
- `500 Internal Server Error` - Server error

Error responses include descriptive messages:

```json
{
  "detail": "Error message",
  "errors": {
    "field_name": ["Error details"]
  }
}
```

## Examples

### List Techniques

Request:

```
GET /api/techniques
```

Response:

```json
{
  "count": 50,
  "next": "http://localhost:8000/api/techniques?page=2",
  "previous": null,
  "results": [
    {
      "id": 1,
      "name": "Fairness Metrics",
      "description": "Statistical measures to assess fairness...",
      "model_dependency": "Model-Agnostic",
      ...
    },
    ...
  ]
}
```

### Get Technique Details

Request:

```
GET /api/techniques/1
```

Response:

```json
{
  "id": 1,
  "name": "Technique Name",
  "description": "Some description of the technique...",
  "model_dependency": "Model-Agnostic",
  "complexity_rating": 3,
  "computational_cost_rating": 2,
  "assurance_goals": [
    {
      "id": 1,
      "name": "Fairness",
      "description": "..."
    }
  ],
  "categories": [...],
  "subcategories": [...],
  "attribute_values": [...],
  "resources": [...],
  "example_use_cases": [...],
  "limitations": [...]
}
```

### Create a Technique

Request:

```
POST /api/techniques
Content-Type: application/json

{
  "name": "New Technique",
  "description": "Description...",
  "model_dependency": "Model-Agnostic",
  "assurance_goal_ids": [1, 2],
  "category_ids": [3],
  "subcategory_ids": [4, 5],
  "tag_ids": [],
  ...
}
```

Response:

```json
{
  "id": 51,
  "name": "New Technique",
  ...
}
```

## Debugging

> [!WARNING]
> For troubleshooting API issues:
>
> - Use the `/api/debug` endpoint to check API status and configuration
> - Check server logs for detailed error messages
> - Verify correct Content-Type headers (application/json) for POST/PUT requests

## Client Integration

The frontend application uses custom hooks to interact with the API. These hooks are located in `/frontend/src/lib/api/hooks.ts` and provide a convenient interface for common operations.

Key hooks include:

- `useTechniques` - List and filter techniques
- `useTechniqueDetail` - Get technique details
- `useCreateTechnique` - Create a new technique
- `useUpdateTechnique` - Update an existing technique
- `useAssuranceGoals` - List assurance goals
- `useCategories` - List categories

## Rate Limiting

The API does not currently implement rate limiting, but may do so in the future for production deployments.
</file>

<file path="docs/FRONTEND-GUIDE.md">
# Frontend Guide

> [!NOTE] Overview
> The TEA Techniques frontend is built with Next.js 15.2, TypeScript, and Tailwind CSS. It provides an interactive interface for browsing, searching, and managing techniques for trustworthy and ethical AI assurance.

## Architecture

The frontend follows Next.js App Router organization:

```
frontend/
├── src/
│   ├── app/               # Next.js App Router pages
│   ├── components/        # Reusable React components
│   │   ├── common/        # Generic form components
│   │   ├── layout/        # Layout components (header, footer)
│   │   ├── technique/     # Technique-specific components
│   │   └── ui/            # Base UI components
│   ├── lib/               # Utilities and helpers
│   │   ├── api/           # API integration
│   │   ├── context/       # React context providers
│   │   └── hooks/         # Custom React hooks
│   └── styles/            # Global styles
└── public/                # Static assets
```

## Component Structure

### Page Components

Located in `src/app/`, these components define the routes of the application:

- `page.tsx` - Homepage
- `techniques/page.tsx` - Techniques listing page
- `techniques/[id]/page.tsx` - Technique detail page
- `techniques/[id]/edit/page.tsx` - Edit technique page
- `techniques/add/page.tsx` - Add new technique page
- `categories/page.tsx` - Categories browsing page
- `about/page.tsx` - About page

### Layout Components

Located in `src/components/layout/`:

- `Header.tsx` - Top navigation bar
- `Footer.tsx` - Page footer
- `MainLayout.tsx` - Main layout wrapper

### Technique Components

Located in `src/components/technique/`:

- `TechniqueForm.tsx` - Form for creating and editing techniques
- `TechniquesList.tsx` - Grid display of technique cards
- `TechniquesSidebar.tsx` - Filter sidebar for techniques listing
- `AttributeVisualizer.tsx` - Visual representation of technique attributes
- `CategoryTag.tsx` - Display category tags
- `GoalIcon.tsx` - Icons for assurance goals

### UI Components

Located in `src/components/ui/`:

- Base UI components like buttons, cards, inputs, etc.
- Based on shadcn/ui with custom styling
- Follows a consistent design language

## State Management

The application uses a combination of:

1. **React Query** for server state management
2. **React Context** for cross-component state (e.g., dark mode)
3. **React useState/useReducer** for local component state

### API Integration

API calls are handled through custom hooks in `src/lib/api/hooks.ts`:

```typescript
// Example API hook
export function useTechniques(params: TechniquesParams = {}) {
  return useQuery({
    queryKey: ["techniques", params],
    queryFn: () => fetchTechniques(params),
  });
}
```

## Key Features

### Technique Browsing

- Grid view of techniques with filtering
- Sidebar with filters for assurance goals, categories, model dependency, and ratings (i.e. complexity and computational cost)
- Search functionality for finding techniques by name or description
- Pagination for handling large sets of techniques

### Technique Details

- Comprehensive view of a technique's metadata
- Visualisation of attributes and relationships
- Links to related resources
- Examples and limitations sections

### Technique Management

- Form for adding new techniques
- Form for editing existing techniques
- Validation for required fields
- Multi-step process for complex data entry

## Form Management

The application uses a custom `useForm` hook for form state management:

```typescript
const {
  values,
  errors,
  handleChange,
  handleBlur,
  setFieldValue,
  validateForm,
} = useForm<TechniqueFormData>(initialFormData, validators);
```

## API Error Handling

Error handling is centralized using the `useApiError` hook:

```typescript
const { error, handleError } = useApiError();

try {
  // API call
} catch (error) {
  handleError(error);
}
```

## Styling

The application uses Tailwind CSS for styling with a customised theme:

```
tailwind.config.ts      # Tailwind configuration
src/app/globals.css     # Global styles
```

### Theme

- Dark and light mode support
- Responsive design for mobile, tablet, and desktop

## TypeScript Types

Core types are defined in `src/lib/types.ts`:

```typescript
export interface Technique {
  id: number;
  name: string;
  description: string;
  model_dependency: string;
  // ... other properties
}

export interface AssuranceGoal {
  id: number;
  name: string;
  description: string;
}

// ... other interfaces
```

## Testing

Frontend tests are located in the `frontend/tests` directory, using Jest and React Testing Library.

### Running Tests

```bash
# Run all tests
npm run test

# Run tests in watch mode
npm run test:watch
```

## Development Workflow

1. Start the backend server
2. Start the frontend development server:
   ```bash
   npm run dev --turbopack
   ```
3. Access the application at `http://localhost:3000`

## Build Process

```bash
# Build for production
npm run build

# Start production server
npm run start
```

## Performance Considerations

- Images are optimised using Next.js Image component
- Data is cached with React Query
- Components use proper memoization where appropriate
- Pagination for large data sets

## Related Links

- [Testing Guide](TESTING.md) - More details on testing approach
- [API Guide](API-GUIDE.md) - Information on the API endpoints used by the frontend
- [Deployment Guide](DEPLOYMENT.md) - How to deploy the frontend
- [Next.js Documentation](https://nextjs.org/docs)
</file>

<file path="docs/FUTURE-ROADMAP.md">
# Future Roadmap

> [!NOTE] Overview
> This document outlines the planned improvements and future direction for the TEA Techniques project. It serves as a guide for contributors and users to understand where the project is headed.

## Short-term Goals (0-3 months)

### Data Enrichment

- **Expand technique database**: expand techniques database to ensure greater coverage for goals beyond explainability and fairness
- **Improve existing entries**: enhance descriptions, add more resources, and refine categorisations
- **Hierarchical tags**: support for nested tagging system
- **Add technique relationships**: implement relationships between complementary or alternative techniques

### User Experience

- **Advanced filtering**: add filtering by additional attributes
- **Responsive optimisations**: improve mobile and tablet experiences
- **Accessibility**: ensure technique detail pages are accessible

### Community Features

- **Authorisation for CRUD Operations**: allow invited users to update the techniques via the frontend
- **Techniques Feedback**: provide targeted options for community to rate techniques (e.g. upvoting popular resources or techniques)
- **API documentation improvements**: Enhance Swagger documentation with more examples for developers
- **Frontend component library**: Create a storybook documentation for UI components
- **Dev container support**: Add devcontainer configuration for VSCode

## Medium-term Goals (3-6 months)

### Feature Additions

- **User accounts**: implement open user registration and authentication
- **Wiki Functionality**: flagging issues, errors, or omissions with techniques
- **Favorites system**: allow users to bookmark favorite techniques
- **Comment system**: enable discussions on techniques
- **Contribution workflow**: allow authenticated users to suggest new techniques or edits
- **Technique comparison**: side-by-side comparison of multiple techniques
- **Export functionality**: allow exporting technique details as PDF or CSV

### Development Improvements

- **API optimisation**: query optimization and endpoint consolidation
- **Frontend bundle optimisation**: code splitting and lazy loading of components
- **CI/CD pipeline**: comprehensive testing and deployment pipeline

### TEA Platform Integration

- **Public API tokens**: support for API keys for external integrations
- **TEA Platform Integration**: support TEA platform extension via API
- **Webhook support**: notify external systems on data updates
- **Embeddable widgets**: create embeddable technique cards for other websites
- **OpenAPI specification**: complete OpenAPI 3.0 specification for the API

## Long-term Goals (6+ months)

### Major Features

- **Technique evaluation framework**: add capability to evaluate and compare techniques based on standard metrics
- **Decision support system**: guide users to appropriate techniques based on their specific needs
- **Implementation guides**: step-by-step guides for using or implementing each technique
- **i18n support**: translate content to multiple languages
- **Interactive demonstrations**: In-browser demos or videos of selected techniques
- **Community-driven content**: allow greater community contributions (e.g. case studies) with moderation workflow
- **LLM integration**: Use TEA search (with LLM functionality) for technique explanation, practical guidance, and resource recommendation

### Architecture Evolution

[...]

## Data Model Improvements

### Taxonomy Enhancements

- **Folksonomy**: user-generated tagging to supplement official taxonomy
- **Cross-references**: better mapping between related techniques
- **Standard compatibility**: map techniques to relevant standards and regulations (integrate with AI Standards Hub)

### New Data Entities

- **Use Case library**: expand into a library of AI assurance use cases (via TEA Platform)
- **Organisation profiles**: information about organizations using specific techniques (via TEA Platform)
- **Practitioner guides**: role-specific guidance for different stakeholders (via BridgeAI)
- **Regulatory mapping**: connection between techniques and regulatory requirements (w/ DSIT)

### Visualisation Enhancements

- **Technique relationship graphs**: visual representation of related techniques (e.g. Obsidian Graph View)
- **Taxonomy explorer**: interactive visualisation of the technique taxonomy

## Research Integration

- **Citations**: BibTex citations for resources
- **Case study repository**: Citable repository of technique case studies (independent of TEA platform)

## Getting Involved

We welcome contributions to help achieve these roadmap items! See the [Contributing Guide](CONTRIBUTING.md) for information on how to get involved.

## Related Links

- [Contributing Guide](CONTRIBUTING.md)
- [Development Workflow](DEVELOPMENT-WORKFLOW.md)
- [Deployment Guide](DEPLOYMENT.md)
</file>

<file path="docs/GLOSSARY.md">
# Glossary

## Assurance Terminology

### Assurance

The process of providing evidence and confidence that a system or product meets specified requirements and operates as intended.

### Trustworthy and Ethical Assurance (TEA)

A framework for evidencing claims about responsible AI design, development, and deployment, focusing on multiple dimensions of trustworthiness (e.g. fairness, explainability).

### Assurance Goal

A high-level objective, such as fairness, transparency, or safety, that guides the selection and application of assurance techniques and the development of an assurance case.

### Assurance Technique

A specific method, tool, or approach used to provide evidence about an aspect of AI system behavior or performance.

### Assurance Case

A structured argument, supported by evidence, that a system satisfies specific claims about its properties (i.e. property claims).

## Model Dependency Types

### Model-Agnostic

Techniques that can be applied to any model, regardless of its architecture or implementation details.

### Model-Specific

Techniques that are designed for or only applicable to specific types of models (e.g., deep neural networks, decision trees).

## Technique Attributes

### Scope

- **Local**: techniques that provide insights about specific predictions or decisions
- **Global**: techniques that provide insights about the model's overall behavior

### Application Stage

- **Pre-training**: applied before model training begins
- **In-training**: applied during model training
- **Post-training**: applied after model training is complete
- **Inference-time**: applied when the model makes predictions

### Implementation Approach

- **Statistical**: based on statistical methods and analyses
- **Formal**: based on formal verification or mathematical proofs
- **Empirical**: based on experimental observations and testing
- **Heuristic**: based on rules of thumb or best practices

### Complexity Rating (1-5)

A measure of how difficult a technique is to implement:

- **1**: Very simple, minimal technical knowledge required
- **2**: Relatively straightforward implementation
- **3**: Moderate complexity, requires some specialised knowledge
- **4**: Complex implementation, requires significant expertise
- **5**: Very complex, requires deep technical expertise

### Computational Cost Rating (1-5)

A measure of the computational resources required to implement a technique:

- **1**: Very lightweight, minimal computational resources needed
- **2**: Low computational requirements
- **3**: Moderate computational requirements
- **4**: High computational requirements
- **5**: Very computationally intensive

## Goals and Categories

<!-- TODO: descriptions of assurance goals and categories/sub-categories  -->

[...]

## Resource Types

<!-- TODO: add descriptions of resource types  -->

### Paper

[...]

### Software Package

[...]

### Documentation

[...]

### Tutorial

[...]

## Related Links

- [Model Architecture](MODEL-ARCHITECTURE.md)
- [User Guide](USER-GUIDE.md)
- [Data Management Guide](DATA-MANAGEMENT.md)
</file>

<file path="docs/MODEL-ARCHITECTURE.md">
# Model Architecture

> [!NOTE]
> The TEA Techniques application is built around a core set of models that represent techniques for evidencing claims about responsible AI design, development, and deployment. The model architecture follows a hierarchical structure with assurance goals at the top level, followed by categories, subcategories, and techniques.

## Entity Relationship Diagram

```
┌─────────────────┐     ┌───────────────┐     ┌────────────────┐
│  AssuranceGoal  │     │    Category   │     │   SubCategory  │
├─────────────────┤     ├───────────────┤     ├────────────────┤
│ id              │     │ id            │     │ id             │
│ name            │────┐│ name          │────┐│ name           │
│ description     │    ││ description   │    ││ description    │
└─────────────────┘    │└───────────────┘    │└────────────────┘
                       │                      │
                       │                      │
┌─────────────────┐    │    ┌───────────────┐│    ┌────────────────┐
│    Technique    │    │    │AttributeType  ││    │ AttributeValue  │
├─────────────────┤    │    ├───────────────┤│    ├────────────────┤
│ id              │    │    │ id            ││    │ id             │
│ name            │    │    │ name          ││    │ attribute_type │
│ description     │    │    │ description   ││    │ name           │
│ model_dependency│◄───┼────┤               ││◄───┤ description    │
│ complexity      │    │    └───────────────┘│    │ technique      │
│ comp_cost       │    │                     │    └────────────────┘
└───────┬─────────┘    │                     │
        │              │                     │
        │              │                     │
        ▼              │                     │
┌─────────────────┐    │                     │
│  TechResource   │    │                     │
├─────────────────┤    │                     │
│ id              │    │                     │
│ technique       │◄───┘                     │
│ resource_type   │                          │
│ title           │                          │
│ url             │                          │
│ description     │                          │
└─────────────────┘                          │
                                             │
┌─────────────────┐                          │
│  TechUseCase    │                          │
├─────────────────┤                          │
│ id              │                          │
│ technique       │◄─────────────────────────┘
│ description     │
│ assurance_goal  │
└─────────────────┘

┌─────────────────┐
│ TechLimitation  │
├─────────────────┤
│ id              │
│ technique       │◄─────────────────────────┐
│ description     │                          │
└─────────────────┘                          │
                                             │
┌─────────────────┐                          │
│ ResourceType    │                          │
├─────────────────┤                          │
│ id              │                          │
│ name            │◄─────────────────────────┘
│ icon            │
└─────────────────┘
```

## Core Models

### AssuranceGoal

The highest level of classification for techniques. Represents broad goals in responsible AI such as fairness, transparency, safety, etc.

```python
class AssuranceGoal(models.Model):
    name = models.CharField(max_length=255, unique=True)
    description = models.TextField()
```

### Category

A domain within an assurance goal. Each category belongs to a specific assurance goal.

```python
class Category(models.Model):
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    assurance_goal = models.ForeignKey(AssuranceGoal, on_delete=models.CASCADE)
```

### SubCategory

A specific area within a category. Each subcategory belongs to a specific category.

```python
class SubCategory(models.Model):
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    category = models.ForeignKey(Category, on_delete=models.CASCADE, related_name="subcategories")
```

### Technique

The central model representing a specific technique for evidencing claims about responsible AI.

```python
class Technique(models.Model):
    name = models.CharField(max_length=255, unique=True)
    description = models.TextField()
    model_dependency = models.CharField(max_length=100)
    category_tags = models.CharField(max_length=500, blank=True)
    complexity_rating = models.PositiveSmallIntegerField(null=True, blank=True)
    computational_cost_rating = models.PositiveSmallIntegerField(null=True, blank=True)
    applicable_models = models.JSONField(null=True, blank=True)
    assurance_goals = models.ManyToManyField(AssuranceGoal, related_name="techniques")
    categories = models.ManyToManyField(Category, related_name="techniques")
    subcategories = models.ManyToManyField(SubCategory, related_name="techniques", blank=True)
    tags = models.ManyToManyField(Tag, related_name="techniques", blank=True)
```

## Supporting Models

### Tag

Simple tagging system for techniques.

```python
class Tag(models.Model):
    name = models.CharField(max_length=255, unique=True)
```

### AttributeType and AttributeValue

Flexible attributes system for techniques. Types define the kinds of attributes, and values store the specific values for each technique.

```python
class AttributeType(models.Model):
    name = models.CharField(max_length=255, unique=True)
    description = models.TextField(blank=True)

class AttributeValue(models.Model):
    attribute_type = models.ForeignKey(AttributeType, on_delete=models.CASCADE, related_name="values")
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    technique = models.ForeignKey(Technique, on_delete=models.CASCADE, related_name="attribute_values")
```

### ResourceType and TechniqueResource

System for linking techniques to external resources like papers, code repositories, and documentation.

```python
class ResourceType(models.Model):
    name = models.CharField(max_length=100, unique=True)
    icon = models.CharField(max_length=50, blank=True)

class TechniqueResource(models.Model):
    technique = models.ForeignKey(Technique, on_delete=models.CASCADE, related_name="resources")
    resource_type = models.ForeignKey(ResourceType, on_delete=models.PROTECT)
    title = models.CharField(max_length=255)
    url = models.URLField()
    description = models.TextField(blank=True)
    authors = models.CharField(max_length=500, blank=True, null=True)
    publication_date = models.CharField(max_length=50, blank=True, null=True)
    source_type = models.CharField(max_length=100, blank=True, null=True)
```

### TechniqueExampleUseCase and TechniqueLimitation

Additional information about techniques.

```python
class TechniqueExampleUseCase(models.Model):
    technique = models.ForeignKey(Technique, on_delete=models.CASCADE, related_name="example_use_cases")
    description = models.TextField()
    assurance_goal = models.ForeignKey(AssuranceGoal, on_delete=models.CASCADE, null=True, blank=True)

class TechniqueLimitation(models.Model):
    technique = models.ForeignKey(Technique, on_delete=models.CASCADE, related_name="limitations")
    description = models.TextField()
```

## Key Relationships

- **Hierarchical Classification**: AssuranceGoal → Category → SubCategory
- **Many-to-Many**: Techniques can belong to multiple assurance goals, categories, subcategories, and tags
- **One-to-Many**: Techniques can have multiple attributes, resources, use cases, and limitations

> [!TIP] Model Dependency
> The `model_dependency` field on Technique indicates whether a technique is:
>
> - **Model-Agnostic**: Works with any AI model
> - **Model-Specific**: Works only with specific types of AI models
>
> For model-specific techniques, the `applicable_models` field stores a JSON array of specific model types.

## Rating Systems

Techniques include two rating fields:

- **complexity_rating**: How difficult the technique is to implement (1-5 scale)
- **computational_cost_rating**: How computationally expensive the technique is to run (1-5 scale)

> [!IMPORTANT] Database Considerations
> The application supports both SQLite (for development) and PostgreSQL (for production) databases. Some special handling is required for SQLite due to schema compatibility issues, particularly with JSONField.

## Schema Evolution

When modifying the model schema, follow these steps in order:

1. Create Django migrations: `python manage.py makemigrations`
2. Apply migrations: `python manage.py migrate`
3. Update the related serializers in `serializers.py`
4. Update the JSON data structure in `techniques.json`
5. For SQLite deployments, handle missing columns with `add_missing_columns` management command

## Related Links

- [Data Management Guide](DATA-MANAGEMENT.md) - How to manage and import technique data
- [API Guide](API-GUIDE.md) - API endpoints for accessing the models
- [Django Models Documentation](https://docs.djangoproject.com/en/5.1/topics/db/models/)
</file>

<file path="docs/USER-GUIDE.md">
# User Guide

> [!NOTE]
> The TEA Techniques application provides a comprehensive database of techniques for evidencing claims about responsible AI design, development, and deployment. This guide will help you navigate the application and make the most of its features.

## Getting Started

<!-- TODO: add screenshots -->

[...]

### Navigation

The main navigation menu provides access to:

- **Home**: landing page with an overview of the application
- **Techniques**: browse and search the technique database
- **Categories**: information about the main categories for the TEA techniques platform
- **About** - information about the application and its purpose

## Using the Platform

[...]

### Filtering Options

The sidebar provides several filtering options:

- **Assurance Goals**: filter by high-level goals like fairness, transparency, etc.
- **Categories**: filter by domain categories within goals
- **Subcategories**: filter by specific subcategories
- **Model Dependency**: filter by model-agnostic or model-specific techniques
- **Complexity**: filter by implementation complexity (1-5 scale)
- **Computational Cost**: filter by computational requirements (1-5 scale)

<!-- TODO: add callout about glossary -->

## Technique Details

The technique detail page provides comprehensive information about a specific technique.

### Basic Information

- **Name** - The full name of the technique
- **Description** - A detailed description of the technique
- **Model Dependency** - Whether the technique is model-agnostic or model-specific
- **Applicable Models** - For model-specific techniques, which model types are supported

### Classification

- **Assurance Goals** - Which high-level goals this technique addresses
- **Categories** - Which categories the technique belongs to
- **Subcategories** - Which subcategories the technique belongs to
- **Tags** - Additional tags for finer classification

### Attributes

Visual representation of technique attributes such as:

- Scope (local vs. global)
- Approach (statistical, model-based, etc.)
- Implementation complexity
- Computational cost

### Resources

Links to external resources including:

- Academic papers
- Code repositories
- Documentation
- Tutorials
- Videos

Each resource includes:

- Title
- URL
- Brief description
- Author information (when available)
- Publication date (when available)

### Example Use Cases

Real-world examples of how the technique can be applied, including:

- Detailed descriptions of use cases
- Which assurance goals they primarily address

### Limitations

Known limitations of the technique, including:

- Technical constraints
- Applicability limitations
- Performance considerations

## Troubleshooting

### Common Issues

> [!WARNING]
>
> - **No Results**: Try removing some filters or broadening your search
> - **Slow Loading**: Check your internet connection or try refreshing the page
> - **Filter Not Working**: Try clearing all filters and applying them again

### Getting Help

> [!IMPORTANT]
> If you encounter issues not covered in this guide:
>
> - Check the [FAQ section](#faq) below
> - Check the [Glossary](GLOSSARY.md) for descriptions of key terms
> - Submit a bug report through the appropriate channels

## FAQ

<!-- TODO: copy this to the main site -->

> [!NOTE]
>
> ### General Questions
>
> **Q: What is the purpose of the TEA Techniques database?**  
> A: It provides a structured repository of techniques for evidencing claims about responsible AI development, helping practitioners identify appropriate methods for specific needs.
>
> **Q: How often is the database updated?**  
> A: The database is regularly updated with new techniques and improvements to existing entries as they become available.
>
> **Q: Can I export data from the database?**  
> A: Currently, data export functionality is not available through the UI. Contact the administrator if you need to export data.
>
> ### Technical Questions
>
> **Q: What does "Model-Agnostic" vs "Model-Specific" mean?**  
> A: Model-Agnostic techniques work with any AI model, while Model-Specific techniques only work with particular types of models (e.g., neural networks, decision trees).
>
> **Q: How are complexity and computational cost determined?**  
> A: These ratings are determined by the community, based on feedback mechanisms that allow them to change over time.
>
> **Q: Why are some techniques missing information?**  
> A: The database is continually being improved. Some techniques may have incomplete information that will be added in future updates.

### Feature Requests

> [!TIP]
> If you have suggestions for new features or improvements, please contact the system administrator or submit your ideas through the appropriate channels.

## Related Links

- [API Guide](API-GUIDE.md) - Information on the API for developers
- [Data Management Guide](DATA-MANAGEMENT.md) - How the database is managed and updated
</file>

<file path="frontend/public/README.md">
# TEA Techniques

An interactive database for exploring techniques for evidencing claims about responsible AI design, development, and deployment. This repository has been designed to work in conjunction with the [Trustworthy and Ethical Assurance (TEA) platform](https://assuranceplatform.azurewebsites.net/) as a core plugin to enable practitioners to identify and implement appropriate assurance methods.

## Development Setup

### Quick Start (Recommended)

For local development, you can use SQLite which doesn't require Docker:

1. **Clone the repository**
   ```bash
   git clone https://github.com/chrisdburr/tea-techniques.git
   cd tea-techniques
   ```

2. **Setup environment variable**
   ```bash
   cp .env.example .env
   ```

3. **Set up the backend**
   ```bash
   cd backend
   poetry install
   USE_SQLITE=True python manage.py reset_and_import_techniques
   ```

4. **Run the backend with SQLite**
   ```bash
   USE_SQLITE=True poetry run python manage.py runserver
   ```

5. **In a new terminal, set up and run the frontend**
   ```bash
   cd frontend
   npm install
   npm run dev --turbopack
   ```

6. **Access the application**
   - Frontend: http://localhost:3000
   - API: http://localhost:8000/api/
   - Django Admin: http://localhost:8000/admin/

### Using Docker (for production-like environment)

If you want to use the full Docker setup with PostgreSQL:

1. **Setup environment variable**
   ```bash
   cp .env.example .env
   ```

2. **Start the application**
   ```bash
   docker compose up -d
   ```

3. **Access the application**
   - Frontend: http://localhost:3000
   - API: http://localhost:8000/api/

## Project Structure

- **Backend**: Django with Django REST Framework
  - `backend/api`: Main Django app
  - `backend/config`: Django project settings
  - `backend/data`: CSV file with technique data

- **Frontend**: Next.js with TypeScript and Tailwind CSS
  - `frontend/src/app`: Next.js pages and routes
  - `frontend/src/components`: Reusable React components
  - `frontend/src/lib`: Utilities, types, and API clients

## Development Tips

1. **API Documentation**
   Access the API documentation at http://localhost:8000/swagger/ when the backend is running.

2. **Database Migrations**
   When changing models, create and apply migrations:
   ```bash
   cd backend
   USE_SQLITE=True poetry run python manage.py makemigrations
   USE_SQLITE=True poetry run python manage.py migrate
   ```

## Testing

Run frontend tests:
```bash
cd frontend
npm test
```

Run backend tests:
```bash
cd backend
poetry run pytest
```

## Key Features

- **Structured Documentation**: Each technique includes comprehensive information about its purpose, implementation details, and practical use cases.
- **Categorized Organization**: Techniques are organized by assurance goals, categories, and subcategories to help you find exactly what you need.
- **API Access**: Access all data through a comprehensive REST API with documentation via Swagger.
- **Model Agnostic & Specific**: Browse techniques that work across different model types or that are designed for specific model architectures.

## License

This project is licensed under the MIT License - see the LICENSE file for details.
</file>

<file path="frontend/src/app/api-test/page.tsx">
'use client';

import { useEffect, useState } from 'react';
import { apiClient } from '@/lib/api/client';

// Define types for the API details
interface ApiClientDetails {
  baseURL?: string;
  timeout?: number;
  headers?: Record<string, string>;
}

export default function ApiTestPage() {
  const [count, setCount] = useState<number | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const [apiDetails, setApiDetails] = useState<ApiClientDetails>({});

  useEffect(() => {
    const testApi = async () => {
      try {
        setLoading(true);
        // Log API client details
        setApiDetails({
          baseURL: apiClient.defaults.baseURL,
          timeout: apiClient.defaults.timeout,
          headers: apiClient.defaults.headers as Record<string, string>
        });
        
        // Use our configured API client
        const response = await apiClient.get('/api/techniques/');
        console.log('API Response:', response.data);
        setCount(response.data.count);
        setError(null);
      } catch (err: unknown) {
        console.error('API Error:', err);
        
        // Simplified error handling for TypeScript compatibility
        const errorMessage = err instanceof Error 
          ? err.message 
          : 'Unknown error occurred';
        
        setError(`API Error: ${errorMessage}`);
      } finally {
        setLoading(false);
      }
    };

    testApi();
  }, []);

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-4">API Connection Test</h1>
      
      {loading && <p>Loading...</p>}
      
      {error && (
        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
          <h2 className="font-bold">Error:</h2>
          <pre className="whitespace-pre-wrap">{error}</pre>
        </div>
      )}
      
      {count !== null && (
        <div className="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded mb-4">
          <p className="font-bold">API Connected Successfully!</p>
          <p>Found {count} techniques</p>
        </div>
      )}
      
      <div className="mt-4">
        <h2 className="text-xl font-bold mb-2">Debugging Information:</h2>
        <pre className="bg-gray-100 p-4 rounded overflow-auto">
          {JSON.stringify({
            environment: {
              NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL,
              NODE_ENV: process.env.NODE_ENV,
              BACKEND_URL: process.env.BACKEND_URL,
            },
            apiClient: apiDetails
          }, null, 2)}
        </pre>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/app/login/page.tsx">
"use client";

import { Suspense, useState } from "react"; // Import Suspense
import { useRouter, useSearchParams } from "next/navigation";
import Link from "next/link";
import { useAuth } from "@/lib/context/auth-context";
import MainLayout from "@/components/layout/MainLayout";
import {
	Card,
	CardContent,
	CardDescription,
	CardFooter,
	CardHeader,
	CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { ExternalLink } from "lucide-react";
import { Skeleton } from "@/components/ui/skeleton"; // Import Skeleton

// Define a loading component for Suspense
function LoginPageLoadingSkeleton() {
	return (
		<MainLayout>
			<div className="max-w-md mx-auto py-12">
				<Card>
					<CardHeader>
						<Skeleton className="h-6 w-1/4 mb-2" />
						<Skeleton className="h-4 w-3/4" />
					</CardHeader>
					<CardContent className="space-y-4">
						<div className="space-y-2">
							<Skeleton className="h-4 w-1/4" />
							<Skeleton className="h-9 w-full" />
						</div>
						<div className="space-y-2">
							<Skeleton className="h-4 w-1/4" />
							<Skeleton className="h-9 w-full" />
						</div>
						<Skeleton className="h-9 w-full mt-2" />
						<Skeleton className="h-9 w-full mt-4" />
					</CardContent>
					<CardFooter className="flex justify-center">
						<Skeleton className="h-4 w-1/2" />
					</CardFooter>
				</Card>
			</div>
		</MainLayout>
	);
}

// The component that actually uses the hooks
function LoginPageContent() {
	const [username, setUsername] = useState("");
	const [password, setPassword] = useState("");
	const [errorMsg, setErrorMsg] = useState("");
	const [isSubmitting, setIsSubmitting] = useState(false);

	const { login } = useAuth();
	const router = useRouter();
	const searchParams = useSearchParams(); // Hook usage is here
	const redirectPath = searchParams.get("redirect") || "/";

	const handleLogin = async (e: React.FormEvent) => {
		e.preventDefault();
		setErrorMsg("");
		setIsSubmitting(true);

		try {
			await login(username, password);
			router.push(redirectPath);
		} catch (error: any) {
			setErrorMsg(
				error.response?.data?.detail ||
					"Login failed. Please check your credentials."
			);
		} finally {
			setIsSubmitting(false);
		}
	};

	const goToAdminLogin = () => {
		window.location.href = "/admin";
	};

	return (
		<MainLayout>
			<div className="max-w-md mx-auto py-12">
				<Card>
					<CardHeader>
						<CardTitle>Login</CardTitle>
						<CardDescription>
							Enter your credentials to access protected features
						</CardDescription>
					</CardHeader>
					<CardContent>
						<form onSubmit={handleLogin} className="space-y-4">
							<div className="space-y-2">
								<Label htmlFor="username">Username</Label>
								<Input
									id="username"
									type="text"
									placeholder="Enter your username"
									value={username}
									onChange={(e) =>
										setUsername(e.target.value)
									}
									required
								/>
							</div>
							<div className="space-y-2">
								<Label htmlFor="password">Password</Label>
								<Input
									id="password"
									type="password"
									placeholder="Enter your password"
									value={password}
									onChange={(e) =>
										setPassword(e.target.value)
									}
									required
								/>
							</div>

							{errorMsg && (
								<div className="bg-red-50 border border-red-200 text-red-600 p-3 rounded-md text-sm">
									{errorMsg}
								</div>
							)}

							<Button
								type="submit"
								className="w-full mt-2"
								disabled={isSubmitting}
							>
								{isSubmitting ? "Logging in..." : "Log in"}
							</Button>
						</form>

						<div className="flex items-center my-4">
							<div className="flex-grow border-t border-gray-200"></div>
							<span className="px-3 text-sm text-muted-foreground">
								Or
							</span>
							<div className="flex-grow border-t border-gray-200"></div>
						</div>

						<Button
							variant="outline"
							className="w-full"
							onClick={goToAdminLogin}
						>
							<ExternalLink size={16} className="mr-2" />
							Go to Django Admin Login
						</Button>
					</CardContent>
					<CardFooter className="flex justify-center">
						<p className="text-sm text-muted-foreground">
							Need access? Contact your administrator.
						</p>
					</CardFooter>
				</Card>
			</div>
		</MainLayout>
	);
}

// Export the page component, wrapping the content with Suspense
export default function LoginPage() {
	return (
		<Suspense fallback={<LoginPageLoadingSkeleton />}>
			<LoginPageContent />
		</Suspense>
	);
}
</file>

<file path="frontend/src/app/techniques/[id]/edit/page.tsx">
"use client";

import React from "react";
import { useParams, useRouter } from "next/navigation";
import { useTechniqueDetail } from "@/lib/api/hooks";
import MainLayout from "@/components/layout/MainLayout";
import TechniqueForm from "@/components/technique/TechniqueForm";
import AuthWrapper from "@/components/common/AuthWrapper";
import { Button } from "@/components/ui/button";
import { ArrowLeft } from "lucide-react";

export default function EditTechniquePage() {
  const params = useParams();
  const router = useRouter();
  const id = Number(params.id);
  
  const { data: technique, isLoading, error } = useTechniqueDetail(id);
  
  const goBack = () => {
    router.push(`/techniques/${id}`);
  };
  
  return (
    <MainLayout>
      <AuthWrapper authRequired>
        <div className="space-y-6">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-3xl font-bold">Edit Technique</h1>
              <p className="text-muted-foreground">
                Update this technique with new information
              </p>
            </div>
            <Button onClick={goBack} variant="outline">
              <ArrowLeft className="mr-2 h-4 w-4" /> Back to Details
            </Button>
          </div>
          
          {isLoading ? (
            <div className="text-center py-8">Loading technique details...</div>
          ) : error ? (
            <div className="bg-red-50 border border-red-200 text-red-700 p-4 rounded-md">
              <p>There was an error loading this technique.</p>
              <p className="text-sm mt-2">{(error as Error)?.message || "Unknown error"}</p>
            </div>
          ) : technique ? (
            <TechniqueForm id={id} isEditMode={true} />
          ) : (
            <div className="text-center py-8">No technique found</div>
          )}
        </div>
      </AuthWrapper>
    </MainLayout>
  );
}
</file>

<file path="frontend/src/app/techniques/[id]/page.tsx.orig">
// src/app/techniques/[id]/page.tsx
"use client";

import { useParams } from "next/navigation";
import { useEffect } from "react";
import MainLayout from "@/components/layout/MainLayout";
import { useTechniqueDetail } from "@/lib/api/hooks";
import { Button } from "@/components/ui/button";
import {
	Card,
	CardContent,
	CardHeader,
	CardTitle,
	CardFooter,
} from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { TooltipProvider } from "@/components/ui/tooltip";
import { StarRating } from "@/components/ui/star-rating";
import Link from "next/link";
import {
	ArrowLeft,
	ArrowRight,
	Brain,
	CheckCircle,
	Cpu,
	Edit,
	Eye,
	ExternalLink,
	FileText,
	Book,
	FileCode,
	Package,
	GraduationCap,
	Info,
	Loader2,
	Lock,
	Scale,
	Shield,
	ShieldCheck,
} from "lucide-react";
import {
	TechniqueResource,
	TechniqueExampleUseCase,
	TechniqueLimitation,
	AttributeValue,
} from "@/lib/types";

// Utility function to find applicable models for model-specific techniques
// This simulates what we would expect from the backend API when updated
function findApplicableModels(techniqueId: number): string[] {
	// Sample data based on model-specific.json structure
	const modelSpecificData = {
		"Tree-based Models": {
			techniques: [
				{
					id: 3,
					name: "Mean Decrease Impurity",
					applicable_models: [
						"Decision Trees",
						"Random Forests",
						"Gradient Boosting Models",
					],
				},
				{
					id: 4,
					name: "Gini Importance",
					applicable_models: ["Decision Trees", "Random Forests"],
				},
				{
					id: 9,
					name: "Variable Importance in Random Forests (MDA MDG)",
					applicable_models: ["Random Forests"],
				},
			],
		},
		"Linear Models": {
			techniques: [
				{
					id: 5,
					name: "Coefficient Magnitudes (in Linear Models)",
					applicable_models: [
						"Linear Regression",
						"Logistic Regression",
						"Ridge Regression",
						"Lasso Regression",
					],
				},
			],
		},
		"Neural Networks": {
			techniques: [
				{
					id: 6,
					name: "Integrated Gradients",
					applicable_models: [
						"General Neural Networks",
						"CNNs",
						"RNNs",
						"Transformers",
					],
				},
				{
					id: 7,
					name: "DeepLIFT",
					applicable_models: [
						"General Neural Networks",
						"CNNs",
						"RNNs",
					],
				},
				{
					id: 8,
					name: "Layer-wise Relevance Propagation (LRP)",
					applicable_models: [
						"General Neural Networks",
						"CNNs",
						"RNNs",
					],
				},
			],
		},
	};

	// Search through all categories and techniques to find the matching ID
	for (const category of Object.values(modelSpecificData)) {
		for (const technique of category.techniques) {
			if (technique.id === techniqueId) {
				return technique.applicable_models || [];
			}
		}
	}

	return [];
}

// Helper component for section containers
function Section({
	title,
	children,
	noBorder = false,
}: {
	title: string;
	children: React.ReactNode;
	noBorder?: boolean;
}) {
	return (
		<div className="mb-8">
			<h2
				className="text-xl font-semibold mb-4"
				id={title.toLowerCase().replace(/\s+/g, "-")}
			>
				{title}
			</h2>
			{noBorder ? (
				<>{children}</>
			) : (
				<div className="bg-card rounded-lg border p-4 shadow-sm">
					{children}
				</div>
			)}
		</div>
	);
}

function TechniqueResources({ resources }: { resources: TechniqueResource[] }) {
	if (!resources || resources.length === 0) {
		return <p className="text-muted-foreground">No resources available.</p>;
	}
	
	// Debug: Log resources to see what we're actually getting from the API
	console.log("Resources from API:", JSON.stringify(resources, null, 2));

	// Function to get the appropriate icon for source type
	const getResourceIcon = (resource: TechniqueResource) => {
		const sourceType = (resource.source_type || "unknown").toLowerCase();
		
		switch (sourceType) {
			case "documentation":
				return <FileText className="h-5 w-5" aria-hidden="true" />;
			case "tutorial":
				return <GraduationCap className="h-5 w-5" aria-hidden="true" />;
			case "software_package":
				return <Package className="h-5 w-5" aria-hidden="true" />;
			case "technical_paper":
				return <FileCode className="h-5 w-5" aria-hidden="true" />;
			case "review_paper":
				return <FileCode className="h-5 w-5" aria-hidden="true" />;
			case "introductory_paper":
			case "paper":
				return <FileCode className="h-5 w-5" aria-hidden="true" />;
			case "blog":
				return <FileText className="h-5 w-5" aria-hidden="true" />;
			case "implementation":
				return <Package className="h-5 w-5" aria-hidden="true" />;
			default:
				return <Book className="h-5 w-5" aria-hidden="true" />;
		}
	};

	// Format source type for display
	const formatSourceType = (sourceType: string): string => {
		if (!sourceType) return "Unknown";
		
		// Convert snake_case to Title Case
		return sourceType
			.split(/_|\s/)
			.map(word => word.charAt(0).toUpperCase() + word.slice(1))
			.join(" ");
	};

	return (
		<>
			{resources.map((resource) => (
				<div
					key={resource.id}
					className="border rounded-md p-4 mb-4 hover:border-primary transition-colors"
				>
					<div className="flex">
						<div className="flex-shrink-0 mr-3 mt-1">
							{getResourceIcon(resource)}
						</div>
						
						<div className="flex-grow">
							<div className="flex items-center justify-between">
								<h3 className="font-medium">
									{resource.title}
								</h3>
								<Button
									variant="outline"
									size="sm"
									asChild
									className="flex items-center gap-1"
								>
									<a href={resource.url} target="_blank" rel="noopener noreferrer">
										<ExternalLink
											className="h-4 w-4"
											aria-hidden="true"
										/>
										<span>View Resource</span>
									</a>
								</Button>
							</div>

							{/* Display metadata - all with same style */}
							<div className="mt-2 text-sm text-muted-foreground">
								{resource.source_type && (
									<div>
										Source Type: {formatSourceType(resource.source_type)}
									</div>
								)}
								
								{resource.authors && (
									<div>
										Authors: {resource.authors}
									</div>
								)}
								{resource.publication_date && (
									<div>
										Published: {resource.publication_date}
									</div>
								)}
							</div>

							{resource.description && (
								<p className="text-sm mt-2 text-muted-foreground">
									{resource.description}
								</p>
							)}
						</div>
					</div>
				</div>
			))}
		</>
	);
}

function TechniqueExampleUseCases({
	useCases,
}: {
	useCases: TechniqueExampleUseCase[];
}) {
	if (!useCases || useCases.length === 0) {
		return (
			<p className="text-muted-foreground">
				No example use cases specified.
			</p>
		);
	}

	// Group use cases by assurance goal
	const groupedUseCases = useCases.reduce((acc, useCase) => {
		const goalName = useCase.assurance_goal_name || "Other";
		if (!acc[goalName]) {
			acc[goalName] = [];
		}
		acc[goalName].push(useCase);
		return acc;
	}, {} as Record<string, TechniqueExampleUseCase[]>);

	// Map assurance goals to their respective icons
	const goalIcons = {
		Explainability: <Brain className="h-5 w-5" aria-hidden="true" />,
		Fairness: <Scale className="h-5 w-5" aria-hidden="true" />,
		Security: <Shield className="h-5 w-5" aria-hidden="true" />,
		Safety: <ShieldCheck className="h-5 w-5" aria-hidden="true" />,
		Reliability: <CheckCircle className="h-5 w-5" aria-hidden="true" />,
		Transparency: <Eye className="h-5 w-5" aria-hidden="true" />,
		Privacy: <Lock className="h-5 w-5" aria-hidden="true" />,
		Other: <Info className="h-5 w-5" aria-hidden="true" />,
	};

	return (
		<div className="space-y-8">
			{Object.entries(groupedUseCases).map(([goalName, cases]) => (
				<div key={goalName} className="space-y-4">
					<div className="flex items-center gap-2 text-primary font-medium">
						{goalIcons[goalName as keyof typeof goalIcons] || (
							<Info className="h-5 w-5" aria-hidden="true" />
						)}
						<h3 className="font-medium">{goalName}</h3>
					</div>
					<div className="space-y-4 pl-7">
						{cases.map((useCase) => (
							<div key={useCase.id} className="space-y-1">
								<p className="whitespace-pre-line">
									{useCase.description}
								</p>
							</div>
						))}
					</div>
				</div>
			))}
		</div>
	);
}

// Component to display technique limitations
function TechniqueLimitations({
	limitations,
}: {
	limitations: TechniqueLimitation[];
}) {
	if (!limitations || limitations.length === 0) {
		return (
			<p className="text-muted-foreground">No limitations specified.</p>
		);
	}

	return (
		<div className="space-y-4">
			{limitations.map((limitation) => {
				// Try to parse the nested JSON in the description field
				const parsedDescription = limitation.description;
				try {
					// Try to parse the string as JSON
					const parsedData = JSON.parse(limitation.description);

					// If it's an array with objects containing description fields, extract them
					if (Array.isArray(parsedData) && parsedData.length > 0) {
						return (
							<div key={limitation.id} className="space-y-2">
								{parsedData.map((item, index) => (
									<div
										key={index}
										className="flex items-start gap-2 py-1"
									>
										<ArrowRight
											className="h-4 w-4 text-primary mt-1 flex-shrink-0"
											aria-hidden="true"
										/>
										<span>{item.description || item}</span>
									</div>
								))}
							</div>
						);
					}
				} catch {
					// If parsing fails, use the original description
				}

				return (
					<div
						key={limitation.id}
						className="flex items-start gap-2 py-1"
					>
						<ArrowRight
							className="h-4 w-4 text-primary mt-1 flex-shrink-0"
							aria-hidden="true"
						/>
						<span>{parsedDescription}</span>
					</div>
				);
			})}
		</div>
	);
}

export default function TechniqueDetailPage() {
	const params = useParams();
	const id = Number(params.id);

	// This would be replaced with actual auth state - for now always false
	const isAuthenticated = false;

	const { data: technique, isLoading, error } = useTechniqueDetail(id);

	// Debug logging - can be removed in production
	useEffect(() => {
		if (technique) {
			console.log("Technique data loaded:", technique);
		}
	}, [technique]);

	if (isLoading) {
		return (
			<MainLayout>
				<div className="flex justify-center items-center py-12">
					<Loader2
						className="h-8 w-8 animate-spin text-primary"
						aria-hidden="true"
					/>
					<span className="ml-2">Loading technique details...</span>
				</div>
			</MainLayout>
		);
	}

	if (error || !technique) {
		return (
			<MainLayout>
				<div className="flex flex-col items-center justify-center py-20">
					<h1 className="text-2xl font-bold mb-4">
						Error Loading Technique
					</h1>
					<p className="text-muted-foreground mb-8">
						There was an error loading this technique. It may not
						exist or you may not have permission to view it.
					</p>
					<Button asChild>
						<Link href="/techniques">Back to Techniques</Link>
					</Button>
				</div>
			</MainLayout>
		);
	}

	const applicableModels =
		technique.model_dependency === "Model-Specific"
			? technique.applicable_models || findApplicableModels(technique.id)
			: [];

	// Helper function to parse category tags
	const parseCategoryTags = (categoryTagsStr: string) => {
		if (!categoryTagsStr) return [];

		return categoryTagsStr
			.split("#")
			.filter((tag) => tag.trim().length > 0)
			.map((tag) => {
				const parts = tag.trim().split("/");
				// Format category name (remove hyphens, title case)
				const formatName = (name: string) => {
					return name
						.split("-")
						.map(
							(word) =>
								word.charAt(0).toUpperCase() + word.slice(1)
						)
						.join(" ");
				};

				return {
					category: formatName(parts[0]),
					subcategory: parts.length > 1 ? formatName(parts[1]) : null,
				};
			});
	};

	const categoryTags = parseCategoryTags(technique.category_tags);

	// Map assurance goals to their respective icons
	const goalIcons = {
		Explainability: <Brain className="h-5 w-5" />,
		Fairness: <Scale className="h-5 w-5" />,
		Security: <Shield className="h-5 w-5" />,
		Safety: <ShieldCheck className="h-5 w-5" />,
		Reliability: <CheckCircle className="h-5 w-5" />,
		Transparency: <Eye className="h-5 w-5" />,
		Privacy: <Lock className="h-5 w-5" />,
	};

	return (
		<TooltipProvider>
			<MainLayout>
				{/* Header section */}
				<div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
					{/* Main content */}
					<div className="lg:col-span-2 space-y-8">
						<div className="mb-6">
							<h1 className="text-3xl font-bold">
								{technique.name}
							</h1>
						</div>
						<Section title="Description">
							<div className="prose max-w-none">
								<p className="whitespace-pre-line">
									{technique.description}
								</p>
							</div>
						</Section>

						<Section title="Example Use Cases">
							<TechniqueExampleUseCases
								useCases={technique.example_use_cases}
							/>
						</Section>

						<Section title="Limitations">
							<TechniqueLimitations
								limitations={technique.limitations}
							/>
						</Section>

						<Section title="Resources" noBorder={true}>
							<TechniqueResources
								resources={technique.resources}
							/>
						</Section>
					</div>

					{/* Sidebar with technique attributes */}
					<div>
						<Card className="sticky top-4 shadow-sm">
							<CardHeader className="pb-3 border-b">
								<CardTitle className="text-lg font-semibold">
									Technique Attributes
									<span
										className="ml-1 inline-flex"
										title="Classification metadata for this technique"
									>
										<Info className="h-4 w-4 text-muted-foreground" />
									</span>
								</CardTitle>
							</CardHeader>
							<CardContent className="space-y-6">
								{/* Assurance Goals with Icons */}
								<div className="space-y-2">
									<h3 className="text-sm font-medium flex items-center">
										Assurance Goals
										<span
											className="ml-1 inline-flex"
											title="The primary goals that this technique helps achieve"
										>
											<Info className="h-4 w-4 text-muted-foreground" />
										</span>
									</h3>
									<div className="flex flex-wrap gap-3">
										{technique.assurance_goals.map(
											(goal) => (
												<div
													key={goal.id}
													className="flex items-center gap-2 p-2 bg-secondary rounded-md"
													title={goal.name}
												>
													{goalIcons[
														goal.name as keyof typeof goalIcons
													] || (
														<Info className="h-5 w-5" />
													)}
													<span className="font-medium text-sm">
														{goal.name}
													</span>
												</div>
											)
										)}
									</div>
								</div>

								{/* Categories (from category tags) */}
								{technique.category_tags &&
									categoryTags.length > 0 && (
										<div className="space-y-2">
											<h3 className="text-sm font-medium flex items-center">
												Categories
												<span
													className="ml-1 inline-flex"
													title="Classification categories for this technique"
												>
													<Info className="h-4 w-4 text-muted-foreground" />
												</span>
											</h3>
											<div className="space-y-2">
												{categoryTags.map(
													(tag, index) => (
														<div
															key={index}
															className="flex justify-between items-center text-sm py-1 border-b last:border-0 border-muted"
														>
															<span>
																{tag.category}
															</span>
															{tag.subcategory && (
																<Badge
																	variant="outline"
																	className="text-xs"
																>
																	{
																		tag.subcategory
																	}
																</Badge>
															)}
														</div>
													)
												)}
											</div>
										</div>
									)}

								{/* Ratings */}
								{technique.complexity_rating ? (
									<div className="space-y-2">
										<h3 className="text-sm font-medium flex items-center">
											Complexity
										</h3>
										<StarRating
											rating={technique.complexity_rating}
											maxRating={5}
											className="text-amber-400"
											aria-label={`Complexity rating: ${technique.complexity_rating} out of 5`}
										/>
									</div>
								) : null}

								{technique.computational_cost_rating ? (
									<div className="space-y-2">
										<h3 className="text-sm font-medium flex items-center">
											Computational Cost
										</h3>
										<StarRating
											rating={
												technique.computational_cost_rating
											}
											maxRating={5}
											className="text-amber-400"
											aria-label={`Computational cost rating: ${technique.computational_cost_rating} out of 5`}
										/>
									</div>
								) : null}

								{/* Model Dependency */}
								<div className="space-y-2">
									<h3 className="text-sm font-medium flex items-center">
										Model Dependency
										<span
											className="ml-1 inline-flex"
											title="Indicates whether this technique requires access to model internals"
										>
											<Info className="h-4 w-4 text-muted-foreground" />
										</span>
									</h3>
									<div>
										<Badge
											variant="outline"
											className="text-sm"
										>
											{technique.model_dependency}
										</Badge>
									</div>
								</div>

								{/* Applicable Models Section (for model-specific techniques) */}
								{technique.model_dependency ===
									"Model-Specific" &&
									applicableModels.length > 0 && (
										<div className="space-y-2">
											<h3 className="text-sm font-medium flex items-center">
												Applicable Models
												<span
													className="ml-1 inline-flex"
													title="Specific model architectures this technique can be applied to"
												>
													<Info className="h-4 w-4 text-muted-foreground" />
												</span>
											</h3>
											<div className="flex flex-wrap gap-2">
												{applicableModels.map(
													(model) => (
														<Badge
															key={model}
															variant="outline"
															className="flex items-center gap-1.5 text-xs py-1"
														>
															<Cpu className="h-3 w-3" />
															<span>{model}</span>
														</Badge>
													)
												)}
											</div>
										</div>
									)}

								{/* Goal-Specific Attributes section */}
								<div className="space-y-3 border-t pt-3">
									<h3 className="text-sm font-medium flex items-center">
										Goal-Specific Attributes
										<span
											className="ml-1 inline-flex"
											title="Attributes specific to the technique's assurance goals"
										>
											<Info className="h-4 w-4 text-muted-foreground" />
										</span>
									</h3>

									{/* Add Explanatory Scope and other attributes */}
									{technique.attribute_values &&
										technique.attribute_values.length > 0 &&
										Object.entries(
											technique.attribute_values.reduce(
												(acc, attr) => {
													const type =
														attr.attribute_type_name;
													if (!acc[type]) {
														acc[type] = [];
													}
													acc[type].push(attr);
													return acc;
												},
												{} as Record<
													string,
													AttributeValue[]
												>
											)
										).map(([type, values]) => (
											<div
												className="space-y-1"
												key={type}
											>
												<h4 className="text-xs text-muted-foreground">
													{type}
												</h4>
												<div className="flex flex-wrap gap-2">
													{values.map((value) => (
														<Badge
															key={value.id}
															variant="outline"
															className="text-sm"
														>
															{value.name}
														</Badge>
													))}
												</div>
											</div>
										))}
								</div>

								{/* Tags */}
								{technique.tags &&
									technique.tags.length > 0 && (
										<div className="space-y-2">
											<h3 className="text-sm font-medium flex items-center">
												Tags
												<span
													className="ml-1 inline-flex"
													title="Keywords associated with this technique"
												>
													<Info className="h-4 w-4 text-muted-foreground" />
												</span>
											</h3>
											<div className="flex flex-wrap gap-2">
												{technique.tags.map((tag) => (
													<Badge
														key={tag.id}
														variant="secondary"
													>
														{tag.name}
													</Badge>
												))}
											</div>
										</div>
									)}
							</CardContent>

							{/* Edit section - delete will be accessible from edit form later */}
							<CardFooter className="flex flex-col items-stretch pt-4 pb-4 border-t">
								<div
									className={`bg-muted/50 rounded p-3 mb-4 flex items-center ${
										isAuthenticated ? "hidden" : ""
									}`}
								>
									<Lock
										className="h-4 w-4 mr-2 text-muted-foreground"
										aria-hidden="true"
									/>
									<p className="text-sm text-muted-foreground">
										Authentication is required to edit a
										technique. Not implemented yet.
									</p>
								</div>
								<Button
									asChild
									variant="outline"
									className="w-full"
									disabled={!isAuthenticated}
								>
									<Link
										href="#"
										aria-label="Edit technique (disabled)"
									>
										<Edit
											className="h-4 w-4 mr-2"
											aria-hidden="true"
										/>{" "}
										Edit Technique
									</Link>
								</Button>
							</CardFooter>
						</Card>
					</div>
				</div>

				{/* Back button at the bottom */}
				<div className="mt-8">
					<Button asChild variant="outline" size="sm">
						<Link
							href="/techniques"
							className="flex items-center gap-2"
						>
							<ArrowLeft className="h-4 w-4" aria-hidden="true" />
							<span>Back to Techniques</span>
						</Link>
					</Button>
				</div>
			</MainLayout>
		</TooltipProvider>
	);
}
</file>

<file path="frontend/src/app/techniques/[id]/page.tsx.rej">
@@ -194,6 +194,10 @@
 					return <Package className="h-5 w-5" aria-hidden="true" />;
+				case "github":
+					return <FileCode className="h-5 w-5" aria-hidden="true" />;
+				case "website":
+					return <Book className="h-5 w-5" aria-hidden="true" />;
 				default:
 					return <Book className="h-5 w-5" aria-hidden="true" />;
 			}
</file>

<file path="frontend/src/app/techniques/[id]/patch.txt">
--- page.tsx.old	2025-03-21 17:30:00.000000000 -0000
+++ page.tsx	2025-03-21 17:30:00.000000000 -0000
@@ -194,6 +194,10 @@
 					return <Package className="h-5 w-5" aria-hidden="true" />;
+				case "github":
+					return <FileCode className="h-5 w-5" aria-hidden="true" />;
+				case "website":
+					return <Book className="h-5 w-5" aria-hidden="true" />;
 				default:
 					return <Book className="h-5 w-5" aria-hidden="true" />;
 			}
</file>

<file path="frontend/src/app/techniques/add/page.tsx">
"use client";

import React from "react";
import { useRouter } from "next/navigation";
import MainLayout from "@/components/layout/MainLayout";
import TechniqueForm from "@/components/technique/TechniqueForm";
import AuthWrapper from "@/components/common/AuthWrapper";
import { Button } from "@/components/ui/button";
import { ArrowLeft } from "lucide-react";

export default function AddTechniquePage() {
  const router = useRouter();
  
  return (
    <MainLayout>
      <AuthWrapper authRequired>
        <div className="space-y-6">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-3xl font-bold">Add New Technique</h1>
              <p className="text-muted-foreground">
                Create a new technique for the collection
              </p>
            </div>
            <Button onClick={() => router.push('/techniques')} variant="outline">
              <ArrowLeft className="mr-2 h-4 w-4" /> Back to Techniques
            </Button>
          </div>
          
          <TechniqueForm />
        </div>
      </AuthWrapper>
    </MainLayout>
  );
}
</file>

<file path="frontend/src/app/globals.css">
@import "tailwindcss";
@import 'prismjs/themes/prism-tomorrow.css';

@plugin "tailwindcss-animate";

@custom-variant dark (&:is(.dark *));

@theme {
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

:root {
  --background: oklch(1 0 0);
  --foreground: oklch(0.129 0.042 264.695);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.129 0.042 264.695);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.129 0.042 264.695);
  --primary: oklch(0.208 0.042 265.755);
  --primary-foreground: oklch(0.984 0.003 247.858);
  --secondary: oklch(0.968 0.007 247.896);
  --secondary-foreground: oklch(0.208 0.042 265.755);
  --muted: oklch(0.968 0.007 247.896);
  --muted-foreground: oklch(0.554 0.046 257.417);
  --accent: oklch(0.968 0.007 247.896);
  --accent-foreground: oklch(0.208 0.042 265.755);
  --destructive: oklch(0.577 0.245 27.325);
  --destructive-foreground: oklch(0.577 0.245 27.325);
  --border: oklch(0.929 0.013 255.508);
  --input: oklch(0.929 0.013 255.508);
  --ring: oklch(0.704 0.04 256.788);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --radius: 0.625rem;
  --sidebar: oklch(0.984 0.003 247.858);
  --sidebar-foreground: oklch(0.129 0.042 264.695);
  --sidebar-primary: oklch(0.208 0.042 265.755);
  --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
  --sidebar-accent: oklch(0.968 0.007 247.896);
  --sidebar-accent-foreground: oklch(0.208 0.042 265.755);
  --sidebar-border: oklch(0.929 0.013 255.508);
  --sidebar-ring: oklch(0.704 0.04 256.788);
}

.dark {
  --background: oklch(0.129 0.042 264.695);
  --foreground: oklch(0.984 0.003 247.858);
  --card: oklch(0.129 0.042 264.695);
  --card-foreground: oklch(0.984 0.003 247.858);
  --popover: oklch(0.129 0.042 264.695);
  --popover-foreground: oklch(0.984 0.003 247.858);
  --primary: oklch(0.984 0.003 247.858);
  --primary-foreground: oklch(0.208 0.042 265.755);
  --secondary: oklch(0.279 0.041 260.031);
  --secondary-foreground: oklch(0.984 0.003 247.858);
  --muted: oklch(0.279 0.041 260.031);
  --muted-foreground: oklch(0.704 0.04 256.788);
  --accent: oklch(0.279 0.041 260.031);
  --accent-foreground: oklch(0.984 0.003 247.858);
  --destructive: oklch(0.396 0.141 25.723);
  --destructive-foreground: oklch(0.637 0.237 25.331);
  --border: oklch(0.279 0.041 260.031);
  --input: oklch(0.279 0.041 260.031);
  --ring: oklch(0.446 0.043 257.281);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.208 0.042 265.755);
  --sidebar-foreground: oklch(0.984 0.003 247.858);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
  --sidebar-accent: oklch(0.279 0.041 260.031);
  --sidebar-accent-foreground: oklch(0.984 0.003 247.858);
  --sidebar-border: oklch(0.279 0.041 260.031);
  --sidebar-ring: oklch(0.446 0.043 257.281);
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-destructive-foreground: var(--destructive-foreground);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="frontend/src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import { DarkModeProvider } from "@/lib/context/dark-mode";
import { AuthProvider } from "@/lib/context/auth-context";
import { QueryProvider } from "@/lib/providers/query-provider";
import "./globals.css";

const geistSans = Geist({
	variable: "--font-geist-sans",
	subsets: ["latin"],
});

const geistMono = Geist_Mono({
	variable: "--font-geist-mono",
	subsets: ["latin"],
});

export const metadata: Metadata = {
	title: "TEA Techniques",
	description: "Explore Techniques for Responsible AI Design, Development, and Deployment",
};

export default function RootLayout({
	children,
}: Readonly<{
	children: React.ReactNode;
}>) {
	return (
		<html lang="en" suppressHydrationWarning>
			<body
				className={`${geistSans.variable} ${geistMono.variable} antialiased`}
			>
				<QueryProvider>
					<AuthProvider>
						<DarkModeProvider>{children}</DarkModeProvider>
					</AuthProvider>
				</QueryProvider>
			</body>
		</html>
	);
}
</file>

<file path="frontend/src/app/page.tsx">
"use client";

import Image from "next/image";
import Link from "next/link";
import MainLayout from "@/components/layout/MainLayout";
import { Button } from "@/components/ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "@/components/ui/card";
import { Database, FileText, Globe } from "lucide-react";

export default function HomePage() {
	return (
		<MainLayout>
			<div className="space-y-24 pb-16">
				{/* Hero Section with Split Layout */}
				<section className="container mx-auto py-12 px-4">
					<div className="grid grid-cols-1 lg:grid-cols-2 gap-12 items-center">
						{/* Left side: Content */}
						<div className="space-y-6 max-w-2xl">
							<h1 className="text-4xl md:text-5xl lg:text-6xl font-bold leading-tight">
								TEA Techniques Database
							</h1>
							<p className="text-xl text-muted-foreground">
								A platform for exploring techniques for
								evidencing claims about responsible design,
								development, and deployment of data-driven
								technologies.
							</p>
							<div className="flex flex-wrap gap-4 pt-4">
								<Button asChild size="lg" className="font-medium">
									<Link href="/techniques">
										Explore Techniques
									</Link>
								</Button>
								<Button asChild variant="outline" size="lg">
									<Link href="https://assuranceplatform.azurewebsites.net/">
										Go to TEA Platform
									</Link>
								</Button>
							</div>
						</div>

						{/* Right side: Image showcase with shadow and border */}
						<div className="relative rounded-lg overflow-hidden shadow-xl border border-muted">
							<Image
								src="/hero_alt.png"
								alt="TEA Techniques platform interface"
								width={800}
								height={500}
								className="w-full object-cover"
							/>
						</div>
					</div>
				</section>

				{/* Features Section - Now with more spacing from the hero */}
				<section className="container mx-auto px-4 space-y-10">
					<div className="text-center mb-8">
						<h2 className="text-3xl font-bold">Key Features</h2>
						<p className="text-muted-foreground max-w-2xl mx-auto mt-2">
							Tools and resources to help with ethical and
							responsible AI development
						</p>
					</div>

					<div className="grid grid-cols-1 md:grid-cols-3 gap-6 lg:gap-10">
						<Card className="h-full">
							<CardHeader>
								<FileText className="h-12 w-12 text-primary mb-2" />
								<CardTitle>Structured Documentation</CardTitle>
								<CardDescription>
									Detailed descriptions and references for
									each technique
								</CardDescription>
							</CardHeader>
							<CardContent>
								<p className="text-muted-foreground">
									Each technique includes comprehensive
									information about its purpose, limitations,
									and practical use cases.
								</p>
							</CardContent>
						</Card>

						<Card className="h-full">
							<CardHeader>
								<Database className="h-12 w-12 text-primary mb-2" />
								<CardTitle>Searchable Database</CardTitle>
								<CardDescription>
									Quickly find techniques that match your
									needs
								</CardDescription>
							</CardHeader>
							<CardContent>
								<p className="text-muted-foreground">
									Filter by assurance goals, categories, and
									specific criteria to discover appropriate
									techniques for your project.
								</p>
							</CardContent>
						</Card>

						<Card className="h-full">
							<CardHeader>
								<Globe className="h-12 w-12 text-primary mb-2" />
								<CardTitle>Open Platform</CardTitle>
								<CardDescription>
									Access API documentation and contribute to
									the platform
								</CardDescription>
							</CardHeader>
							<CardContent>
								<p className="text-muted-foreground">
									TEA Techniques is designed to be an open,
									collaborative resource for the AI ethics
									community.
								</p>
							</CardContent>
						</Card>
					</div>
				</section>

				{/* Call to Action */}
				<section className="container mx-auto px-4">
					<div className="bg-muted/50 py-12 px-6 rounded-lg text-center space-y-6">
						<h2 className="text-3xl font-bold">
							Ready to get started?
						</h2>
						<p className="text-xl text-muted-foreground max-w-2xl mx-auto">
							Explore our database of techniques to help ensure your
							AI systems are trustworthy and ethically developed.
						</p>
						<div className="pt-4">
							<Button asChild size="lg">
								<Link href="/techniques">Explore Techniques</Link>
							</Button>
						</div>
					</div>
				</section>
			</div>
		</MainLayout>
	);
}
</file>

<file path="frontend/src/components/common/AuthWrapper.tsx">
"use client";

import { useEffect } from 'react';
import { useRouter, usePathname } from 'next/navigation';
import { useAuth } from '@/lib/context/auth-context';
import { Button } from '@/components/ui/button';

interface AuthWrapperProps {
  children: React.ReactNode;
  authRequired?: boolean;
  adminOnly?: boolean;
}

export default function AuthWrapper({ 
  children, 
  authRequired = false,
  adminOnly = false
}: AuthWrapperProps) {
  const { isAuthenticated, isLoading, user } = useAuth();
  const router = useRouter();
  const pathname = usePathname();

  useEffect(() => {
    // Only redirect after loading is complete
    if (!isLoading) {
      if (authRequired && !isAuthenticated) {
        // If auth is required but user is not authenticated
        router.push(`/login?redirect=${encodeURIComponent(pathname)}`);
      } else if (adminOnly && (!isAuthenticated || !user?.isStaff)) {
        // If admin is required but user is not admin
        router.push('/');
      }
    }
  }, [isAuthenticated, isLoading, authRequired, adminOnly, router, pathname, user]);

  // Show loading state
  if (isLoading && (authRequired || adminOnly)) {
    return (
      <div className="flex items-center justify-center h-[60vh]">
        <div className="text-center">
          <div className="inline-block animate-spin h-8 w-8 border-4 border-gray-300 border-t-primary rounded-full mb-4"></div>
          <p className="text-muted-foreground">Checking authentication...</p>
        </div>
      </div>
    );
  }

  // If authentication is required but user is not authenticated
  if (!isLoading && authRequired && !isAuthenticated) {
    return (
      <div className="flex flex-col items-center justify-center h-[60vh] space-y-6">
        <div className="text-center max-w-md">
          <h1 className="text-2xl font-bold mb-4">Authentication Required</h1>
          <p className="text-muted-foreground mb-6">
            You need to be signed in to access this page. Please log in with your credentials.
          </p>
          <div className="flex flex-col space-y-3">
            <Button 
              onClick={() => router.push(`/login?redirect=${encodeURIComponent(pathname)}`)}
              className="w-full"
            >
              Log in
            </Button>
            <Button 
              variant="outline" 
              onClick={() => window.location.href = '/admin'}
              className="w-full"
            >
              Go to Admin Login
            </Button>
          </div>
        </div>
      </div>
    );
  }

  // If admin is required but user is not admin
  if (!isLoading && adminOnly && (!isAuthenticated || !user?.isStaff)) {
    return (
      <div className="flex flex-col items-center justify-center h-[60vh] space-y-6">
        <div className="text-center max-w-md">
          <h1 className="text-2xl font-bold mb-4">Access Restricted</h1>
          <p className="text-muted-foreground mb-6">
            This page is only accessible to administrators.
          </p>
          <Button variant="outline" onClick={() => router.push('/')}>
            Return to Home
          </Button>
        </div>
      </div>
    );
  }

  // Otherwise, render the children
  return <>{children}</>;
}
</file>

<file path="frontend/src/components/layout/Footer.tsx">
import React from "react";
import Link from "next/link";
import * as Constants from "@/lib/constants";
import { config } from "@/lib/config";

const Footer = () => {
	return (
		<footer className="border-t border-border bg-background">
			<div className="container mx-auto py-8 px-4">
				<div className="grid grid-cols-1 md:grid-cols-3 gap-8">
					<div>
						<h3 className="text-lg font-semibold mb-4">
							{Constants.APP_TITLE}
						</h3>
						<p className="text-muted-foreground text-sm">
							{Constants.APP_DESCRIPTION}
						</p>
					</div>
					<div>
						<h3 className="text-lg font-semibold mb-4">Links</h3>
						<ul className="space-y-2 text-sm">
							<li>
								<Link
									href="/categories"
									className="text-muted-foreground hover:text-foreground"
								>
									Categories
								</Link>
							</li>
							<li>
								<Link
									href="/techniques"
									className="text-muted-foreground hover:text-foreground"
								>
									Browse Techniques
								</Link>
							</li>
							<li>
								<Link
									href="/about"
									className="text-muted-foreground hover:text-foreground"
								>
									About
								</Link>
							</li>
						</ul>
					</div>
					<div>
						<h3 className="text-lg font-semibold mb-4">
							Resources
						</h3>
						<ul className="space-y-2 text-sm">
							<li>
								<Link
									href={config.swaggerUrl}
									className="text-muted-foreground hover:text-foreground"
								>
									API Documentation
								</Link>
							</li>
							<li>
								<a
									href="https://github.com/chrisdburr/tea-techniques"
									target="_blank"
									rel="noopener noreferrer"
									className="text-muted-foreground hover:text-foreground"
								>
									GitHub Repository
								</a>
							</li>
						</ul>
					</div>
				</div>
				<div className="mt-8 border-t border-border pt-8 text-center text-sm text-muted-foreground">
					<p>
						© {new Date().getFullYear()} {Constants.APP_TITLE}. All
						rights reserved.
					</p>
				</div>
			</div>
		</footer>
	);
};

export default Footer;
</file>

<file path="frontend/src/components/layout/MainLayout.tsx">
import React from "react";
import Header from "./Header";
import Footer from "./Footer";
import DismissibleBanner from "@/components/ui/DismissibleBanner";

interface MainLayoutProps {
	children: React.ReactNode;
}

const MainLayout: React.FC<MainLayoutProps> = ({ children }) => {
	return (
		<div className="flex min-h-screen flex-col">
			<DismissibleBanner message="This application is in active development and should not be shared publicly. Features are still being worked on and some content exists as a placeholder only." />
			<Header />
			<main className="flex-1 container mx-auto py-8 px-4">
				{children}
			</main>
			<Footer />
		</div>
	);
};

export default MainLayout;
</file>

<file path="frontend/src/components/ui/alert.tsx">
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const alertVariants = cva(
    "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
    {
        variants: {
            variant: {
                default: "bg-background text-foreground",
                destructive:
                    "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
            },
        },
        defaultVariants: {
            variant: "default",
        },
    }
);

interface AlertProps
    extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof alertVariants> { }

const Alert = React.forwardRef<HTMLDivElement, AlertProps>(
    ({ className, variant, ...props }, ref) => (
        <div
            ref={ref}
            role="alert"
            className={cn(alertVariants({ variant }), className)}
            {...props}
        />
    )
);
Alert.displayName = "Alert";

const AlertTitle = React.forwardRef<
    HTMLHeadingElement,
    React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
    <h5
        ref={ref}
        className={cn("mb-1 font-medium leading-none tracking-tight", className)}
        {...props}
    />
));
AlertTitle.displayName = "AlertTitle";

const AlertDescription = React.forwardRef<
    HTMLParagraphElement,
    React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
    <div
        ref={ref}
        className={cn("text-sm [&_p]:leading-relaxed", className)}
        {...props}
    />
));
AlertDescription.displayName = "AlertDescription";

export { Alert, AlertTitle, AlertDescription };
</file>

<file path="frontend/src/components/ui/DismissibleBanner.tsx">
"use client";

import { useState, useEffect } from "react";
import { X, AlertTriangle } from "lucide-react";
import { Button } from "@/components/ui/button";

interface DismissibleBannerProps {
	message: string;
	id?: string; // For remembering dismissal in sessionStorage
}

export const DismissibleBanner = ({
	message,
	id = "tea-tech-banner",
}: DismissibleBannerProps) => {
	const [isVisible, setIsVisible] = useState(true);

	// Check if banner was previously dismissed in this session
	useEffect(() => {
		const wasDismissed = sessionStorage.getItem(id) === "dismissed";
		if (wasDismissed) {
			setIsVisible(false);
		}
	}, [id]);

	const handleDismiss = () => {
		setIsVisible(false);
		// Remember dismissal in session storage
		sessionStorage.setItem(id, "dismissed");
	};

	if (!isVisible) return null;

	return (
		<div className="w-full bg-amber-50 dark:bg-amber-900/30 border-b border-amber-200 dark:border-amber-800">
			<div className="container mx-auto py-2 px-4">
				<div className="flex items-center justify-between">
					<div className="flex items-center gap-2 text-amber-800 dark:text-amber-200">
						<AlertTriangle className="h-4 w-4 flex-shrink-0" />
						<p className="text-sm font-medium">{message}</p>
					</div>
					<Button
						onClick={handleDismiss}
						variant="ghost"
						size="sm"
						className="text-amber-800 dark:text-amber-200 h-6 w-6 p-0"
						aria-label="Dismiss"
					>
						<X className="h-4 w-4" />
					</Button>
				</div>
			</div>
		</div>
	);
};

export default DismissibleBanner;
</file>

<file path="frontend/src/components/ui/prism-code-block.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { Check, Copy } from 'lucide-react';
import { cn } from '@/lib/utils';
import Prism from 'prismjs';

// Import Prism CSS - you need to import this once in your app
// You can add this to your globals.css or layout.tsx
import 'prismjs/themes/prism-tomorrow.css';

// Load additional languages
import 'prismjs/components/prism-bash';
import 'prismjs/components/prism-jsx';
import 'prismjs/components/prism-tsx';
import 'prismjs/components/prism-typescript';
import 'prismjs/components/prism-json';
import 'prismjs/components/prism-python';

interface PrismCodeBlockProps {
    code: string;
    language?: string;
    className?: string;
}

// Add additional CSS for our code blocks
const codeBlockStyles = `
  .code-block pre {
    margin: 0;
    padding: 1rem;
    overflow: auto;
    border-radius: 0;
    background: #1e1e1e !important;
  }
  .code-block code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size: 0.9rem;
    line-height: 1.5;
  }
`;

// Add the styles to the document head
if (typeof document !== 'undefined') {
    const styleElement = document.createElement('style');
    styleElement.innerHTML = codeBlockStyles;
    document.head.appendChild(styleElement);
}

export const PrismCodeBlock: React.FC<PrismCodeBlockProps> = ({
    code,
    language = 'bash',
    className,
}) => {
    const [copied, setCopied] = useState(false);
    const [highlightedCode, setHighlightedCode] = useState<string>('');

    // Map component prop language values to Prism's expected format
    const languageMap: Record<string, string> = {
        'js': 'javascript',
        'jsx': 'jsx',
        'ts': 'typescript',
        'tsx': 'tsx',
        'py': 'python',
        'python': 'python',
        'bash': 'bash',
        'sh': 'bash',
        'json': 'json',
    };

    // Get the correct language or fallback to plain text
    const prismLanguage = languageMap[language] || language || 'plaintext';

    useEffect(() => {
        // Highlight the code
        if (typeof window !== 'undefined') {
            const highlight = () => {
                if (Prism.languages[prismLanguage]) {
                    const html = Prism.highlight(
                        code,
                        Prism.languages[prismLanguage],
                        prismLanguage
                    );
                    setHighlightedCode(html);
                } else {
                    // Fallback to plain text
                    setHighlightedCode(escapeHtml(code));
                }
            };

            highlight();
        }
    }, [code, prismLanguage]);

    const handleCopy = async () => {
        try {
            await navigator.clipboard.writeText(code);
            setCopied(true);
            setTimeout(() => setCopied(false), 2000);
        } catch (error) {
            console.error('Failed to copy code', error);
        }
    };

    // Helper function to escape HTML special characters
    const escapeHtml = (text: string) => {
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    };

    return (
        <div className={cn('relative rounded-md overflow-hidden my-4 border border-gray-700', className)}>
            {/* Language tab */}
            <div className="flex items-center justify-between bg-gray-900 px-4 py-2 text-xs text-gray-200 border-b border-gray-700">
                <span className="font-mono">
                    {language === 'tsx' || language === 'jsx'
                        ? language.toUpperCase()
                        : language.charAt(0).toUpperCase() + language.slice(1)}
                </span>
                <button
                    onClick={handleCopy}
                    className="p-1.5 rounded-md hover:bg-gray-800 text-gray-300 transition-colors"
                    aria-label={copied ? 'Copied!' : 'Copy code'}
                >
                    {copied ? <Check className="h-3.5 w-3.5" /> : <Copy className="h-3.5 w-3.5" />}
                </button>
            </div>

            <div className="code-block bg-gray-900">
                <pre>
                    <code
                        className={`language-${prismLanguage}`}
                        dangerouslySetInnerHTML={{ __html: highlightedCode }}
                    />
                </pre>
            </div>
        </div>
    );
};

export default PrismCodeBlock;
</file>

<file path="frontend/src/components/ui/skeleton.tsx">
import * as React from "react";
import { cn } from "@/lib/utils";

function Skeleton({
    className,
    ...props
}: React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div
            className={cn("animate-pulse rounded-md bg-muted", className)}
            {...props}
        />
    );
}

export { Skeleton };
</file>

<file path="frontend/src/lib/context/auth-context.tsx">
"use client";

import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { apiClient } from '@/lib/api/client';

// Define the user type
interface User {
  id: number;
  username: string;
  email: string;
  isStaff: boolean;
}

// Define the context type
interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
  login: (username: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  checkAuthStatus: () => Promise<void>;
}

// Create the context with default values
const AuthContext = createContext<AuthContextType>({
  user: null,
  isAuthenticated: false,
  isLoading: true,
  error: null,
  login: async () => {},
  logout: async () => {},
  checkAuthStatus: async () => {},
});

// Create a provider component
export const AuthProvider = ({ children }: { children: ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Check auth status automatically on mount
  useEffect(() => {
    checkAuthStatus();
  }, []);

  // Function to check if the user is already authenticated
  const checkAuthStatus = async () => {
    setIsLoading(true);
    setError(null);
    
    try {
      // We'll check by trying to fetch the current user info
      const response = await apiClient.get('/api/auth/user');
      setUser(response.data);
      setIsLoading(false);
    } catch (error) {
      console.log('Not authenticated or could not verify authentication status');
      setUser(null);
      setIsLoading(false);
    }
  };

  // Function to log in
  const login = async (username: string, password: string) => {
    setIsLoading(true);
    setError(null);
    
    try {
      // First, get CSRF token if needed
      await apiClient.get('/api/auth/csrf');
      
      // Then login
      const response = await apiClient.post('/api/auth/login', {
        username,
        password,
      });
      
      setUser(response.data);
      setIsLoading(false);
    } catch (error: any) {
      console.error('Login error:', error);
      setError(error.response?.data?.detail || 'Authentication failed');
      setIsLoading(false);
      throw error;
    }
  };

  // Function to log out
  const logout = async () => {
    setIsLoading(true);
    
    try {
      await apiClient.post('/api/auth/logout');
      setUser(null);
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      setIsLoading(false);
    }
  };

  // Create a redirectToAdmin helper
  const redirectToAdmin = () => {
    // This function will redirect users to the Django admin login page
    // which is useful for simple authentication scenarios
    if (typeof window !== 'undefined') {
      window.location.href = '/admin/';
    }
  };

  return (
    <AuthContext.Provider
      value={{
        user,
        isAuthenticated: !!user,
        isLoading,
        error,
        login,
        logout,
        checkAuthStatus,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

// Create a hook for using the auth context
export const useAuth = () => useContext(AuthContext);
</file>

<file path="frontend/src/lib/hooks/useApiError.ts">
// src/lib/hooks/useApiError.ts

import { useState } from "react";
import axios, { AxiosError } from "axios";

interface ApiErrorState {
	message: string;
	details?: Record<string, string[]>;
	statusCode?: number;
	errorType?: string;
}

/**
 * Standardized backend error format:
 * {
 *   "detail": "Human-readable error message",
 *   "status_code": 400,
 *   "error_type": "ValidationError",
 *   "errors": {} | null (field-specific errors when applicable)
 * }
 */
interface StandardizedApiError {
	detail: string;
	status_code: number;
	error_type: string;
	errors: Record<string, string[]> | null;
}

export function useApiError() {
	const [error, setError] = useState<ApiErrorState | null>(null);

	const handleError = (err: unknown) => {
		if (axios.isAxiosError(err)) {
			const axiosError = err as AxiosError<unknown>;
			const statusCode = axiosError.response?.status;

			// Network or request cancellation errors
			if (!axiosError.response) {
				setError({
					message: axiosError.message || "Network error occurred",
					statusCode: 0, // No status code for network errors
					errorType: "NetworkError",
				});
				console.error("[API Error] Network error:", axiosError);
				return;
			}

			// Response exists, try to parse the data
			try {
				const responseData = axiosError.response.data;

				// Handle standardized backend error format
				if (
					typeof responseData === "object" &&
					responseData !== null &&
					"detail" in responseData &&
					"status_code" in responseData &&
					"error_type" in responseData
				) {
					// We have a standardized error format
					const standardError = responseData as StandardizedApiError;

					setError({
						message: standardError.detail,
						details: standardError.errors || undefined,
						statusCode: standardError.status_code,
						errorType: standardError.error_type,
					});

					// Log for debugging but with sensitive context
					console.error(
						`[API Error] ${standardError.error_type}: ${standardError.detail}`,
						standardError.errors
							? { fieldErrors: standardError.errors }
							: ""
					);
					return;
				}

				// Handle legacy/non-standardized error formats

				// Case 1: DRF validation errors with field-specific messages
				if (
					typeof responseData === "object" &&
					responseData !== null &&
					// Ensure responseData is treated as an indexable object for this check
					Object.keys(responseData).some((key) => {
						const value = (responseData as Record<string, unknown>)[
							key
						]; // Access safely
						return (
							Array.isArray(value) &&
							value.length > 0 &&
							typeof value[0] === "string"
						);
					})
				) {
					setError({
						message: "Validation error",
						// Assert type here as well for assignment
						details: responseData as Record<string, string[]>,
						statusCode,
						errorType: "ValidationError",
					});
					console.error(
						"[API Error] Validation error:",
						responseData
					);
					return;
				}

				// Case 2: Simple error with 'detail' or 'message' field
				if (typeof responseData === "object" && responseData !== null) {
					// Check for typical DRF error fields
					if (
						"detail" in responseData &&
						typeof responseData.detail === "string"
					) {
						setError({
							message: responseData.detail,
							statusCode,
							errorType: "APIError",
						});
						console.error(
							`[API Error] Detail error: ${responseData.detail}`
						);
						return;
					}

					// Check for message field
					if ("message" in responseData && responseData.message) {
						setError({
							message: String(responseData.message),
							statusCode,
							errorType: "APIError",
						});
						console.error(
							`[API Error] Message error: ${responseData.message}`
						);
						return;
					}
				}

				// Case 3: Plain string error
				if (typeof responseData === "string") {
					setError({
						message: responseData,
						statusCode,
						errorType: "APIError",
					});
					console.error(`[API Error] String error: ${responseData}`);
					return;
				}

				// Unhandled error format - log it for debugging
				console.error(
					"[API Error] Unparseable error format:",
					responseData
				);

				// Fallback for unknown response format
				setError({
					message: `Error ${statusCode}: Request failed`,
					statusCode,
					errorType: "UnknownError",
				});
			} catch (parseError) {
				// Error while trying to process the error response
				console.error(
					"[API Error] Error parsing error response:",
					parseError
				);
				setError({
					message:
						"An error occurred while processing the server response",
					statusCode,
					errorType: "ParseError",
				});
			}
		} else if (err instanceof Error) {
			// Handle regular JS errors
			setError({
				message: err.message || "An unexpected error occurred",
				errorType: err.name,
			});
			console.error(`[API Error] JS Error (${err.name}):`, err.message);
		} else {
			// Handle truly unknown errors
			console.error("[API Error] Unknown error type:", err);
			setError({
				message: "An unknown error occurred",
				errorType: "UnknownError",
			});
		}
	};

	const clearError = () => setError(null);

	return {
		error,
		handleError,
		clearError,
	};
}
</file>

<file path="frontend/src/lib/hooks/useForm.ts">
// src/lib/hooks/useForm.ts
import { useState, ChangeEvent } from 'react';

/**
 * Type for form error messages, indexed by form field names
 */
type FormErrors<T> = Partial<Record<keyof T | 'submit', string>>;

/**
 * Type for field validation functions
 * Each function takes a field value and returns an error message or null
 */
export type FormValidators<T> = {
  [K in keyof T]?: (value: T[K]) => string | null;
};

/**
 * Return type of the useForm hook
 */
interface UseFormReturn<T> {
  /** Current form values */
  values: T;
  
  /** Current form errors */
  errors: FormErrors<T>;
  
  /** Whether the form is currently submitting */
  isSubmitting: boolean;
  
  /** Handler for input changes */
  handleChange: (e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
  
  /** Handler for input blur events (triggers validation) */
  handleBlur: (e: React.FocusEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
  
  /** Handler for select input changes */
  handleSelectChange: (name: keyof T, value: string) => void;
  
  /** Manually set a field value */
  setFieldValue: <K extends keyof T>(name: K, value: T[K]) => void;
  
  /** Manually set an error for a field */
  setFieldError: (name: keyof T | 'submit', error: string) => void;
  
  /** Clear an error for a field */
  clearFieldError: (name: keyof T) => void;
  
  /** Set the form's submitting state */
  setSubmitting: (isSubmitting: boolean) => void;
  
  /** Validate all form fields, returning whether the form is valid */
  validateForm: () => boolean;
  
  /** Reset the form values and errors */
  resetForm: (newValues?: Partial<T>) => void;
}

/**
 * Custom hook for form handling
 * @param initialValues Initial form values
 * @param validators Field validation functions
 * @returns Form state and handlers
 */

export function useForm<T extends object>(
  initialValues: T, 
  validators: FormValidators<T> = {} as FormValidators<T>
): UseFormReturn<T> {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<FormErrors<T>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleChange = (e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    const fieldName = name as keyof T;
    
    // Update the value - we need to allow typing even if the character is the same
    // (e.g., typing 'aa' should work even though it's the same character twice)
    setValues(prev => ({
      ...prev,
      [fieldName]: value,
    }));

    // Clear error for this field when it's changed
    if (errors[fieldName]) {
      clearFieldError(fieldName);
    }
  };

  const handleSelectChange = (name: keyof T, value: string) => {
    // Skip update if the value isn't changing
    if (values[name] === value) return;
    
    // Update the field value
    setValues(prev => ({
      ...prev,
      [name]: value,
    }));

    // Clear error for this field when it's changed
    if (errors[name]) {
      clearFieldError(name);
    }
  };

  const setFieldValue = <K extends keyof T>(name: K, value: T[K]) => {
    // Skip update if the value isn't changing
    if (values[name] === value) return;
    
    setValues(prev => ({
      ...prev,
      [name]: value,
    }));
  };

  const setFieldError = (name: keyof T | 'submit', error: string) => {
    setErrors(prev => ({
      ...prev,
      [name]: error,
    }));
  };

  const clearFieldError = (name: keyof T) => {
    setErrors(prev => {
      const newErrors = { ...prev };
      delete newErrors[name];
      return newErrors;
    });
  };


  const resetForm = (newValues?: Partial<T>) => {
    // When called with newValues (especially in edit mode), we need to ensure values are set
    const updatedValues = { ...initialValues, ...(newValues || {}) };
    
    // Only update if values are actually different
    const hasChanges = Object.keys(updatedValues).some(
      key => updatedValues[key as keyof T] !== values[key as keyof T]
    );
    
    if (hasChanges) {
      setValues(updatedValues);
    }
    
    // Clear any existing errors only if we have errors
    if (Object.keys(errors).length > 0) {
      setErrors({});
    }
  };

  // Updated validateForm to use the stored validators
  /**
   * Validate all form fields using the provided validators
   * 
   * Runs each field's validator function and collects any error messages.
   * Updates the form's error state and returns whether the form is valid.
   * 
   * @returns Boolean indicating if the form is valid (true) or has errors (false)
   */
  const validateForm = () => {
    const newErrors: FormErrors<T> = {};
    
    Object.keys(validators).forEach(key => {
      const fieldKey = key as keyof T;
      const validator = validators[fieldKey];
      
      if (validator) {
        // TypeScript now knows that validator expects T[fieldKey] type
        const errorMessage = validator(values[fieldKey]);
        
        if (errorMessage) {
          newErrors[fieldKey] = errorMessage;
        }
      }
    });
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  /**
   * Handle input blur events by validating the field
   * 
   * When a field loses focus, this runs the validator for that field
   * and updates the error state accordingly.
   * 
   * @param e - The blur event from the input element
   */
  const handleBlur = (e: React.FocusEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name } = e.target;
    const fieldKey = name as keyof T;
    
    // If there's a validator for this field
    if (fieldKey in validators && validators[fieldKey]) {
      const validator = validators[fieldKey];
      if (validator) {
        const errorMessage = validator(values[fieldKey]);
        
        if (errorMessage) {
          setErrors(prev => ({
            ...prev,
            [fieldKey]: errorMessage
          }));
        } else {
          clearFieldError(fieldKey);
        }
      }
    }
  };

  return {
    values,
    errors,
    isSubmitting,
    handleChange,
    handleBlur,
    handleSelectChange,
    setFieldValue,
    setFieldError,
    clearFieldError,
    setSubmitting: setIsSubmitting,
    validateForm,
    resetForm,
  };
}
</file>

<file path="frontend/src/lib/hooks/usePagination.ts">
// src/lib/hooks/usePagination.ts
import { useState, useEffect, useCallback } from "react";
import { useRouter, useSearchParams, usePathname } from "next/navigation";

interface UsePaginationProps {
  totalItems: number;
  pageSize?: number;
  initialPage?: number;
  onPageChange?: (page: number) => void;
}

export function usePagination({
  totalItems,
  pageSize = 15,
  initialPage = 1,
  onPageChange,
}: UsePaginationProps) {
  const router = useRouter();
  const searchParams = useSearchParams();
  const pathname = usePathname();

  // Get initial page from URL or use default
  const [currentPage, setCurrentPage] = useState(initialPage);

  // Calculate total pages
  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize));

  // Effect to update current page when URL changes
  useEffect(() => {
    const pageParam = searchParams.get("page");
    if (pageParam) {
      const pageNum = parseInt(pageParam, 10);
      if (!isNaN(pageNum) && pageNum >= 1 && pageNum <= totalPages) {
        setCurrentPage(pageNum);
      }
    } else {
      // If no page parameter, reset to page 1
      setCurrentPage(1);
    }
  }, [searchParams, totalPages]);

  // Function to handle page change
  const handlePageChange = useCallback((page: number) => {
    // Safety check to prevent accessing non-existent pages
    if (page < 1 || page > totalPages) {
      console.warn(
        `Attempted to access invalid page ${page}. Total pages: ${totalPages}`
      );
      return;
    }

    // Update URL with the new page
    const params = new URLSearchParams(searchParams.toString());
    params.set("page", page.toString());
    router.push(`${pathname}?${params.toString()}`);

    // Call the onPageChange callback if provided
    if (onPageChange) {
      onPageChange(page);
    }

    setCurrentPage(page);
  }, [searchParams, router, pathname, totalPages, onPageChange]);

  return {
    currentPage,
    totalPages,
    handlePageChange,
    firstPage: 1,
    lastPage: totalPages,
    hasPrevPage: currentPage > 1,
    hasNextPage: currentPage < totalPages,
    isPageAccessible: (page: number) => page >= 1 && page <= totalPages,
  };
}
</file>

<file path="frontend/src/mocks/handlers.ts">
import { http, HttpResponse } from 'msw';
import { Technique } from '@/lib/api/useTechniques';

// Mock technique data
const mockTechniques: Technique[] = [
  {
    id: 1,
    name: 'Test Technique 1',
    description: 'Description for test technique 1',
    model_dependency: 'Agnostic',
    category_tags: '', // Add this required field
    example_use_cases: [
      {
        id: 101,
        description: 'Example use case',
        assurance_goal: 1,
        assurance_goal_name: 'Explainability'
      }
    ],
    assurance_goals: [],
    categories: [],
    subcategories: [],
    attribute_values: [], // Updated from attributes to attribute_values
    resources: [],
    limitations: [],
    tags: []
  }
]

export const handlers = [
  // GET /api/techniques/
  http.get('/api/techniques/', () => {
    return HttpResponse.json(mockTechniques);
  }),

  // GET /api/techniques/:id
  http.get('/api/techniques/:id', ({ params }) => {
    const { id } = params;
    const technique = mockTechniques.find(t => t.id === Number(id));
    
    if (!technique) {
      return new HttpResponse(null, { status: 404 });
    }
    
    return HttpResponse.json(technique);
  }),

  // POST /api/techniques/
  http.post('/api/techniques/', async ({ request }) => {
    const newTechnique = await request.json() as Partial<Technique>;
    const technique = {
      id: mockTechniques.length + 1,
      ...newTechnique
    };
    
    return HttpResponse.json(technique, { status: 201 });
  }),

  // PUT /api/techniques/:id
  http.put('/api/techniques/:id', async ({ params, request }) => {
    const { id } = params;
    const updatedData = await request.json() as Partial<Technique>;
    const technique = mockTechniques.find(t => t.id === Number(id));
    
    if (!technique) {
      return new HttpResponse(null, { status: 404 });
    }
    
    const updatedTechnique = { ...technique, ...updatedData };
    return HttpResponse.json(updatedTechnique);
  })
];
</file>

<file path="frontend/src/mocks/server.ts">
// Update to handle MSW v2 
import { setupServer } from 'msw/node';
import { handlers } from './handlers';

// Set up MSW server with our handlers
export const server = setupServer(...handlers);
</file>

<file path="frontend/src/tests/hooks/useFilterParams.test.ts">
import { act, renderHook } from '@testing-library/react';
import { useFilterParams } from '@/lib/hooks/useFilterParams';

// Create object to store mock URL parameters
let mockParams: Record<string, string> = { page: '1' };

// Mock Next.js navigation hooks
jest.mock('next/navigation', () => ({
  useSearchParams: jest.fn(() => ({
    get: jest.fn((key) => mockParams[key] || null),
  })),
  useRouter: jest.fn(() => ({
    push: jest.fn(),
  })),
  usePathname: jest.fn(() => '/techniques'),
}));

describe('useFilterParams', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    // Reset mock params to default state
    mockParams = { page: '1' };
  });

  it('initializes with default values', () => {
    const initialFilters = {
      search: '',
      category: 'all',
      assurance_goal: 'all',
    };

    const { result } = renderHook(() => useFilterParams(initialFilters));

    expect(result.current.filters).toEqual({
      ...initialFilters,
      page: '1',
    });
    expect(result.current.currentPage).toBe(1);
  });

  it('updates a single filter', () => {
    const initialFilters = {
      search: '',
      category: 'all',
      assurance_goal: 'all',
    };

    const { result } = renderHook(() => useFilterParams(initialFilters));

    act(() => {
      result.current.setFilter('search', 'test query');
    });

    expect(result.current.filters.search).toBe('test query');
  });

  it('creates URL params and calls router.push when applying filters', () => {
    const router = require('next/navigation').useRouter();
    const initialFilters = {
      search: '',
      category: 'all',
      assurance_goal: 'all',
    };

    const { result } = renderHook(() => useFilterParams(initialFilters));

    // Update filters
    act(() => {
      result.current.setFilter('search', 'test');
      result.current.setFilter('category', '5');
      result.current.setFilter('assurance_goal', '3');
    });

    // Call applyFilters
    act(() => {
      result.current.applyFilters();
    });

    // Verify router.push was called with correct URL
    expect(router.push).toHaveBeenCalledWith(
      expect.stringContaining('/techniques?')
    );
    expect(router.push).toHaveBeenCalledWith(
      expect.stringContaining('categories=5')
    );
    expect(router.push).toHaveBeenCalledWith(
      expect.stringContaining('assurance_goals=3')
    );
    expect(router.push).toHaveBeenCalledWith(
      expect.stringContaining('search=test')
    );
    expect(router.push).toHaveBeenCalledWith(
      expect.stringContaining('page=1')
    );
  });

  it('resets filters to initial values', () => {
    const router = require('next/navigation').useRouter();
    const initialFilters = {
      search: '',
      category: 'all',
      assurance_goal: 'all',
    };

    const { result } = renderHook(() => useFilterParams(initialFilters));

    // First update some filters
    act(() => {
      result.current.setFilter('search', 'test query');
      result.current.setFilter('category', '5');
    });

    // Then reset
    act(() => {
      result.current.resetFilters();
    });

    // Check that router was called with the correct reset URL
    expect(router.push).toHaveBeenCalledWith('/techniques?page=1');
  });

  it('changes page and updates URL', () => {
    const router = require('next/navigation').useRouter();
    const initialFilters = {
      search: 'test',
      category: '5',
      assurance_goal: '3',
    };

    const { result } = renderHook(() => useFilterParams(initialFilters));

    // Call changePage with new page number
    act(() => {
      result.current.changePage(3);
    });

    // Verify router.push contains the right page parameter
    expect(router.push).toHaveBeenCalledWith(
      expect.stringContaining('page=3')
    );
  });
});
</file>

<file path="frontend/src/tests/hooks/useForm.test.ts">
import { renderHook, act } from '@testing-library/react';
import { useForm, FormValidators } from '@/lib/hooks/useForm';

interface TestFormValues {
  name: string;
  email: string;
  age: number;
}

describe('useForm', () => {
  // Test initial values
  it('initializes with provided values', () => {
    const initialValues: TestFormValues = {
      name: 'John Doe',
      email: 'john@example.com',
      age: 30,
    };

    const { result } = renderHook(() => useForm<TestFormValues>(initialValues));

    expect(result.current.values).toEqual(initialValues);
    expect(result.current.errors).toEqual({});
    expect(result.current.isSubmitting).toBe(false);
  });

  // Test handleChange
  it('updates values via handleChange', () => {
    const initialValues: TestFormValues = {
      name: '',
      email: '',
      age: 0,
    };

    const { result } = renderHook(() => useForm<TestFormValues>(initialValues));

    act(() => {
      result.current.handleChange({
        target: { name: 'name', value: 'Jane Doe' },
      } as React.ChangeEvent<HTMLInputElement>);
    });

    expect(result.current.values.name).toBe('Jane Doe');
  });

  // Test handleSelectChange
  it('updates values via handleSelectChange', () => {
    const initialValues: TestFormValues = {
      name: '',
      email: '',
      age: 0,
    };

    const { result } = renderHook(() => useForm<TestFormValues>(initialValues));

    act(() => {
      result.current.handleSelectChange('age', '25');
    });

    expect(result.current.values.age).toBe('25');
  });

  // Test setFieldValue
  it('updates values via setFieldValue', () => {
    const initialValues: TestFormValues = {
      name: '',
      email: '',
      age: 0,
    };

    const { result } = renderHook(() => useForm<TestFormValues>(initialValues));

    act(() => {
      result.current.setFieldValue('email', 'jane@example.com');
    });

    expect(result.current.values.email).toBe('jane@example.com');
  });

  // Test validation
  it('validates fields using provided validators', () => {
    const initialValues: TestFormValues = {
      name: '',
      email: 'invalid-email',
      age: 15,
    };

    const validators: FormValidators<TestFormValues> = {
      name: (value) => (value ? null : 'Name is required'),
      email: (value) => (
        /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value) ? null : 'Invalid email format'
      ),
      age: (value) => (value >= 18 ? null : 'Must be 18 or older'),
    };

    const { result } = renderHook(() => 
      useForm<TestFormValues>(initialValues, validators)
    );

    act(() => {
      const isValid = result.current.validateForm();
      expect(isValid).toBe(false);
    });

    expect(result.current.errors).toEqual({
      name: 'Name is required',
      email: 'Invalid email format',
      age: 'Must be 18 or older',
    });
  });

  // Test field-level validation on blur
  it('validates individual field on blur', () => {
    const initialValues: TestFormValues = {
      name: '',
      email: 'test@example.com',
      age: 25,
    };

    const validators: FormValidators<TestFormValues> = {
      name: (value) => (value ? null : 'Name is required'),
    };

    const { result } = renderHook(() => 
      useForm<TestFormValues>(initialValues, validators)
    );

    act(() => {
      result.current.handleBlur({
        target: { name: 'name', value: '' }
      } as React.FocusEvent<HTMLInputElement>);
    });

    expect(result.current.errors.name).toBe('Name is required');
    expect(Object.keys(result.current.errors).length).toBe(1); // Only name field has error
  });

  // Test set/clear field error
  it('manually sets and clears field errors', () => {
    const initialValues: TestFormValues = {
      name: 'John Doe',
      email: 'john@example.com',
      age: 30,
    };

    const { result } = renderHook(() => useForm<TestFormValues>(initialValues));

    act(() => {
      result.current.setFieldError('email', 'Email already in use');
    });

    expect(result.current.errors.email).toBe('Email already in use');

    act(() => {
      result.current.clearFieldError('email');
    });

    expect(result.current.errors.email).toBeUndefined();
  });

  // Test resetForm
  it('resets form to initial values', () => {
    const initialValues: TestFormValues = {
      name: '',
      email: '',
      age: 0,
    };

    const { result } = renderHook(() => useForm<TestFormValues>(initialValues));

    // Change some values and add errors
    act(() => {
      result.current.setFieldValue('name', 'Jane Doe');
      result.current.setFieldValue('email', 'jane@example.com');
      result.current.setFieldError('age', 'Invalid age');
    });

    // Reset the form
    act(() => {
      result.current.resetForm();
    });

    // Check values are reset and errors cleared
    expect(result.current.values).toEqual(initialValues);
    expect(result.current.errors).toEqual({});
  });

  // Test resetForm with new values
  it('resets form with new values', () => {
    const initialValues: TestFormValues = {
      name: '',
      email: '',
      age: 0,
    };

    const { result } = renderHook(() => useForm<TestFormValues>(initialValues));

    const newValues = {
      name: 'Jane Doe',
      email: 'jane@example.com',
    };

    // Reset with new values
    act(() => {
      result.current.resetForm(newValues);
    });

    // Check values are updated
    expect(result.current.values).toEqual({
      ...initialValues,
      ...newValues,
    });
  });
});
</file>

<file path="frontend/tests/plan.md">
# Comprehensive Frontend Test Suite for TEA Techniques

A well-designed test suite for the TEA Techniques web application should systematically validate all frontend components and user flows. Here's a comprehensive testing strategy using Jest and React Testing Library:

## Overview of the Test Suite

I've designed a comprehensive testing strategy for the TEA Techniques web application that systematically tests all frontend components. The test suite provides thorough coverage across different levels of testing to ensure the application functions correctly.

### Key Testing Areas:

1. **Unit Tests** - Testing individual components in isolation
2. **Integration Tests** - Testing interactions between connected components
3. **API Integration Tests** - Verifying correct data fetching and error handling  
4. **Page Component Tests** - Testing complete page layouts and functionality
5. **End-to-End Tests** - Testing complete user flows (using Cypress/Playwright)

### Testing Stack

The test suite leverages the following tools:

- **Jest**: JavaScript testing framework
- **React Testing Library**: For testing React components
- **Mock Service Worker (MSW)**: For mocking API responses
- **Cypress/Playwright**: Recommended for end-to-end testing

## Detailed Breakdown of Tests

### Unit Tests for UI Components

These tests verify that individual UI components render correctly and handle user interactions properly:

- **Button Component**: Testing rendering, click events, variants, and disabled state
- **Card Component**: Testing proper rendering of all card sub-components
- **StarRating Component**: Testing correct number of filled/empty stars
- **Header/Footer Components**: Testing navigation links and responsive behavior

### Integration Tests

These tests check how components interact with each other:

- **TechniquesList & TechniquesSidebar**: Testing that filtering works correctly
- **GoalIcon Component**: Testing that the correct icons are rendered for each assurance goal

### API Integration Tests

These tests ensure the application fetches and handles data correctly:

- **API Hooks Testing**: Verify `useTechniques`, `useTechniqueDetail`, and other hooks fetch data correctly
- **Error Handling**: Test how the application handles API errors

### Page Component Tests

These tests verify that complete pages render correctly:

- **Home Page**: Testing all sections render correctly
- **Technique Detail Page**: Testing rendering of technique details, loading, and error states

### End-to-End Testing

For end-to-end tests, the strategy includes using Cypress or Playwright to test complete user flows:

- Navigating through the application
- Applying filters and verifying results
- Viewing technique details
- Testing pagination
- Testing dark mode functionality

## Implementation Notes

1. The test suite includes comprehensive mocking of:
   - Next.js hooks (`useRouter`, `useParams`)
   - API responses
   - Browser APIs (localStorage, matchMedia)

2. All tests follow best practices for React Testing Library:
   - Testing user-visible behavior, not implementation details
   - Using semantic queries (getByRole, getByText)
   - Simulating real user interactions

3. The tests are organized by component type and functionality, making it easy to:
   - Locate specific tests
   - Maintain the test suite as the application evolves
   - Identify the purpose of each test

## Getting Started with Testing

To run the tests, you would:

1. Install testing dependencies if not already included:
   ```bash
   npm install --save-dev @testing-library/react @testing-library/user-event @testing-library/jest-dom jest
   ```

2. Run the tests:
   ```bash
   npm test
   ```

3. For end-to-end tests with Cypress (after installation):
   ```bash
   npm run cypress:open
   ```

This comprehensive test suite will ensure that the TEA Techniques web application functions correctly across all components and user flows, providing confidence in the application's reliability.
</file>

<file path="frontend/tests/test-suite.txt">
/**
 * This file provides a comprehensive test suite plan for the TEA Techniques web application.
 * The tests are organized by component type and functionality.
 */

// Structure:
// 1. Unit Tests - Individual components
// 2. Integration Tests - Component interactions
// 3. API Integration Tests - Data fetching
// 4. End-to-End User Flows

// =====================================================
// 1. UNIT TESTS: Basic Component Rendering
// =====================================================

// src/__tests__/components/ui/button.test.tsx
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { Button } from '@/components/ui/button'

describe('Button Component', () => {
  test('renders correctly with default props', () => {
    render(<Button>Click me</Button>)
    expect(screen.getByRole('button', { name: /click me/i })).toBeInTheDocument()
  })

  test('handles click events', async () => {
    const handleClick = jest.fn()
    render(<Button onClick={handleClick}>Click me</Button>)
    await userEvent.click(screen.getByRole('button', { name: /click me/i }))
    expect(handleClick).toHaveBeenCalledTimes(1)
  })

  test('renders different variants correctly', () => {
    const { rerender } = render(<Button variant="outline">Outline</Button>)
    expect(screen.getByRole('button', { name: /outline/i })).toHaveClass('border')
    
    rerender(<Button variant="destructive">Destructive</Button>)
    expect(screen.getByRole('button', { name: /destructive/i })).toHaveClass('bg-destructive')
  })

  test('supports being disabled', () => {
    render(<Button disabled>Disabled</Button>)
    expect(screen.getByRole('button', { name: /disabled/i })).toBeDisabled()
  })
})

// src/__tests__/components/ui/card.test.tsx
import { render, screen } from '@testing-library/react'
import { Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter } from '@/components/ui/card'

describe('Card Components', () => {
  test('renders Card with all sub-components', () => {
    render(
      <Card>
        <CardHeader>
          <CardTitle>Card Title</CardTitle>
          <CardDescription>Card Description</CardDescription>
        </CardHeader>
        <CardContent>Content</CardContent>
        <CardFooter>Footer</CardFooter>
      </Card>
    )
    
    expect(screen.getByText('Card Title')).toBeInTheDocument()
    expect(screen.getByText('Card Description')).toBeInTheDocument()
    expect(screen.getByText('Content')).toBeInTheDocument()
    expect(screen.getByText('Footer')).toBeInTheDocument()
  })
})

// src/__tests__/components/layout/Header.test.tsx
import { render, screen } from '@testing-library/react'
import Header from '@/components/layout/Header'
import { DarkModeProvider } from '@/lib/context/dark-mode'

// Mock useRouter
jest.mock('next/navigation', () => ({
  useRouter: () => ({
    push: jest.fn(),
  }),
  useSearchParams: () => ({
    get: jest.fn(),
  }),
}))

describe('Header Component', () => {
  test('renders navigation links', () => {
    render(
      <DarkModeProvider>
        <Header />
      </DarkModeProvider>
    )
    
    expect(screen.getByText('TEA Techniques')).toBeInTheDocument()
    expect(screen.getByText('Categories')).toBeInTheDocument()
    expect(screen.getByText('Browse Techniques')).toBeInTheDocument()
    expect(screen.getByText('About')).toBeInTheDocument()
  })
  
  test('renders dark mode toggle', () => {
    render(
      <DarkModeProvider>
        <Header />
      </DarkModeProvider>
    )
    
    // Look for the button that controls dark mode
    const darkModeButton = screen.getByRole('button', { name: /Switch to Dark Mode|Switch to Light Mode/i })
    expect(darkModeButton).toBeInTheDocument()
  })

  test('mobile menu toggle works', async () => {
    // First, mock window.innerWidth to simulate mobile view
    Object.defineProperty(window, 'innerWidth', { value: 500, writable: true })
    window.dispatchEvent(new Event('resize'))
    
    render(
      <DarkModeProvider>
        <Header />
      </DarkModeProvider>
    )
    
    // Find and click the mobile menu button
    const menuButton = screen.getByRole('button', { name: /toggle menu/i })
    await userEvent.click(menuButton)
    
    // Check if mobile menu is shown
    expect(screen.getByText('Browse Techniques')).toBeVisible()
  })
})

// src/__tests__/components/layout/Footer.test.tsx
import { render, screen } from '@testing-library/react'
import Footer from '@/components/layout/Footer'

describe('Footer Component', () => {
  test('renders app title and links', () => {
    render(<Footer />)
    
    expect(screen.getByText('TEA Techniques Database')).toBeInTheDocument()
    expect(screen.getByText('Categories')).toBeInTheDocument()
    expect(screen.getByText('Browse Techniques')).toBeInTheDocument()
    expect(screen.getByText('About')).toBeInTheDocument()
    expect(screen.getByText('API Documentation')).toBeInTheDocument()
    expect(screen.getByText('GitHub Repository')).toBeInTheDocument()
  })
  
  test('renders copyright info with current year', () => {
    render(<Footer />)
    
    const currentYear = new Date().getFullYear().toString()
    expect(screen.getByText(new RegExp(`© ${currentYear} TEA Techniques Database`, 'i'))).toBeInTheDocument()
  })
})

// src/__tests__/components/ui/star-rating.test.tsx
import { render, screen } from '@testing-library/react'
import { StarRating } from '@/components/ui/star-rating'

describe('StarRating Component', () => {
  test('renders correct number of filled stars', () => {
    render(<StarRating rating={3} maxRating={5} />)
    
    // This test is somewhat tricky because of how the stars are rendered
    // Check for filled stars vs empty stars
    const stars = screen.getAllByRole('img', { hidden: true }) // SVG icons are often hidden from screen readers
    
    // You might need to adjust this based on your actual DOM structure
    const filledStars = stars.filter(star => star.className.includes('fill-yellow'))
    const emptyStars = stars.filter(star => !star.className.includes('fill-yellow'))
    
    expect(filledStars).toHaveLength(3)
    expect(emptyStars).toHaveLength(2)
  })
  
  test('handles edge cases for ratings', () => {
    const { rerender } = render(<StarRating rating={0} maxRating={5} />)
    expect(screen.queryAllByTestId('filled-star')).toHaveLength(0)
    
    rerender(<StarRating rating={-1} maxRating={5} />)
    expect(screen.queryAllByTestId('filled-star')).toHaveLength(0)
    
    rerender(<StarRating rating={6} maxRating={5} />)
    expect(screen.queryAllByTestId('filled-star')).toHaveLength(5)
  })
})

// =====================================================
// 2. INTEGRATION TESTS: Component Interactions
// =====================================================

// src/__tests__/components/technique/TechniquesList.test.tsx
import { render, screen, waitFor } from '@testing-library/react'
import TechniquesList from '@/components/technique/TechniquesList'
import { QueryClientProvider, QueryClient } from '@tanstack/react-query'
import * as hooks from '@/lib/api/hooks'

// Mock the hooks used in the TechniquesList component
jest.mock('@/lib/api/hooks', () => ({
  ...jest.requireActual('@/lib/api/hooks'),
  useTechniques: jest.fn(),
  useAssuranceGoals: jest.fn(),
  useCategories: jest.fn(),
}))

describe('TechniquesList Component', () => {
  let queryClient: QueryClient

  beforeEach(() => {
    queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          retry: false,
        },
      },
    })
    
    // Mock the hook results
    jest.spyOn(hooks, 'useTechniques').mockReturnValue({
      data: {
        count: 2,
        results: [
          {
            id: 1,
            name: 'Test Technique 1',
            description: 'Description 1',
            model_dependency: 'Model-Agnostic',
            category_tags: '#category/subcategory',
            assurance_goals: [{ id: 1, name: 'Explainability', description: 'Desc' }],
            categories: [{ id: 1, name: 'Category 1', description: 'Desc', assurance_goal: 1, assurance_goal_name: 'Explainability' }],
            subcategories: [],
            tags: [],
            attribute_values: [],
            resources: [],
            example_use_cases: [],
            limitations: [],
          },
          {
            id: 2,
            name: 'Test Technique 2',
            description: 'Description 2',
            model_dependency: 'Model-Specific',
            category_tags: '#category/subcategory',
            assurance_goals: [{ id: 2, name: 'Fairness', description: 'Desc' }],
            categories: [{ id: 2, name: 'Category 2', description: 'Desc', assurance_goal: 2, assurance_goal_name: 'Fairness' }],
            subcategories: [],
            tags: [],
            attribute_values: [],
            resources: [],
            example_use_cases: [],
            limitations: [],
          },
        ],
      },
      isLoading: false,
      error: null,
    } as any)
    
    jest.spyOn(hooks, 'useAssuranceGoals').mockReturnValue({
      data: {
        results: [
          { id: 1, name: 'Explainability', description: 'Desc' },
          { id: 2, name: 'Fairness', description: 'Desc' },
        ],
      },
      isLoading: false,
      error: null,
    } as any)
    
    jest.spyOn(hooks, 'useCategories').mockReturnValue({
      data: {
        results: [
          { id: 1, name: 'Category 1', description: 'Desc', assurance_goal: 1, assurance_goal_name: 'Explainability' },
          { id: 2, name: 'Category 2', description: 'Desc', assurance_goal: 2, assurance_goal_name: 'Fairness' },
        ],
      },
      isLoading: false,
      error: null,
    } as any)
  })

  test('renders list of techniques', async () => {
    render(
      <QueryClientProvider client={queryClient}>
        <TechniquesList />
      </QueryClientProvider>
    )
    
    await waitFor(() => {
      expect(screen.getByText('Test Technique 1')).toBeInTheDocument()
      expect(screen.getByText('Test Technique 2')).toBeInTheDocument()
    })
  })
  
  test('shows loading state', async () => {
    jest.spyOn(hooks, 'useTechniques').mockReturnValueOnce({
      isLoading: true,
      error: null,
    } as any)
    
    render(
      <QueryClientProvider client={queryClient}>
        <TechniquesList />
      </QueryClientProvider>
    )
    
    expect(screen.getByText(/loading/i)).toBeInTheDocument()
  })
  
  test('shows error state', async () => {
    jest.spyOn(hooks, 'useTechniques').mockReturnValueOnce({
      isLoading: false,
      error: new Error('Failed to fetch techniques'),
    } as any)
    
    render(
      <QueryClientProvider client={queryClient}>
        <TechniquesList />
      </QueryClientProvider>
    )
    
    expect(screen.getByText(/error loading techniques/i)).toBeInTheDocument()
  })
  
  test('filters work correctly', async () => {
    render(
      <QueryClientProvider client={queryClient}>
        <TechniquesList />
      </QueryClientProvider>
    )
    
    // Find and click a filter
    const explainabilityFilter = screen.getByText('Explainability')
    await userEvent.click(explainabilityFilter)
    
    // The useTechniques mock should be called with updated filters
    expect(hooks.useTechniques).toHaveBeenCalledWith(
      expect.objectContaining({ assurance_goals: ['1'] }),
      expect.any(Number)
    )
  })
})

// src/__tests__/components/technique/TechniquesSidebar.test.tsx
import { render, screen } from '@testing-library/react'
import TechniquesSidebar from '@/components/technique/TechniquesSidebar'

describe('TechniquesSidebar Component', () => {
  const mockFilters = {
    search: '',
    assurance_goals: [],
    categories: [],
    model_dependency: [],
    complexity_max: 5,
    computational_cost_max: 5,
  }
  
  const mockGoals = [
    { id: 1, name: 'Explainability', description: 'Desc' },
    { id: 2, name: 'Fairness', description: 'Desc' },
  ]
  
  const mockCategories = [
    { id: 1, name: 'Category 1', description: 'Desc', assurance_goal: 1, assurance_goal_name: 'Explainability' },
    { id: 2, name: 'Category 2', description: 'Desc', assurance_goal: 2, assurance_goal_name: 'Fairness' },
  ]
  
  const mockSetFilters = jest.fn()
  const mockApplyFilters = jest.fn()
  const mockResetFilters = jest.fn()
  const mockSetIsMobileOpen = jest.fn()

  test('renders filter sections correctly', () => {
    render(
      <TechniquesSidebar
        filters={mockFilters}
        setFilters={mockSetFilters}
        applyFilters={mockApplyFilters}
        resetFilters={mockResetFilters}
        assuranceGoals={mockGoals}
        categories={mockCategories}
        isDataLoading={false}
        isMobileOpen={true}
        setIsMobileOpen={mockSetIsMobileOpen}
      />
    )
    
    expect(screen.getByText('Filters')).toBeInTheDocument()
    expect(screen.getByText('Assurance Goals')).toBeInTheDocument()
    expect(screen.getByText('Categories')).toBeInTheDocument()
    expect(screen.getByText('Model Dependency')).toBeInTheDocument()
    expect(screen.getByText('Ratings')).toBeInTheDocument()
  })
  
  test('reset button calls resetFilters', async () => {
    render(
      <TechniquesSidebar
        filters={mockFilters}
        setFilters={mockSetFilters}
        applyFilters={mockApplyFilters}
        resetFilters={mockResetFilters}
        assuranceGoals={mockGoals}
        categories={mockCategories}
        isDataLoading={false}
        isMobileOpen={true}
        setIsMobileOpen={mockSetIsMobileOpen}
      />
    )
    
    const resetButton = screen.getByText('Reset')
    await userEvent.click(resetButton)
    
    expect(mockResetFilters).toHaveBeenCalledTimes(1)
  })
  
  test('filter checkboxes update filter state', async () => {
    render(
      <TechniquesSidebar
        filters={mockFilters}
        setFilters={mockSetFilters}
        applyFilters={mockApplyFilters}
        resetFilters={mockResetFilters}
        assuranceGoals={mockGoals}
        categories={mockCategories}
        isDataLoading={false}
        isMobileOpen={true}
        setIsMobileOpen={mockSetIsMobileOpen}
      />
    )
    
    // Find a goal checkbox
    const explainabilityCheckbox = screen.getByLabelText('Explainability')
    await userEvent.click(explainabilityCheckbox)
    
    // toggleArrayFilter should have been called with the appropriate arguments
    expect(mockApplyFilters).toHaveBeenCalled()
  })
})

// src/__tests__/components/technique/GoalIcon.test.tsx
import { render, screen } from '@testing-library/react'
import GoalIcon from '@/components/technique/GoalIcon'

describe('GoalIcon Component', () => {
  test('renders the correct icon for each goal', () => {
    const goals = ['Explainability', 'Fairness', 'Security', 'Safety', 'Reliability', 'Transparency', 'Privacy']
    
    goals.forEach(goal => {
      const { rerender } = render(<GoalIcon goalName={goal} />)
      
      // Since icons are SVGs, check the presence of an SVG element
      expect(screen.getByRole('img', { hidden: true })).toBeInTheDocument()
      
      rerender(<></>)
    })
  })
  
  test('renders a default icon for unknown goals', () => {
    render(<GoalIcon goalName="Unknown Goal" />)
    
    // Should render the default HelpCircle icon
    expect(screen.getByRole('img', { hidden: true })).toBeInTheDocument()
  })
})

// =====================================================
// 3. API INTEGRATION TESTS
// =====================================================

// src/__tests__/lib/api/hooks.test.tsx
import { renderHook, waitFor } from '@testing-library/react'
import { QueryClientProvider, QueryClient } from '@tanstack/react-query'
import { 
  useTechniques, 
  useTechniqueDetail,
  useAssuranceGoals,
  useCategories 
} from '@/lib/api/hooks'
import { apiClient } from '@/lib/api/client'

// Mock axios client
jest.mock('@/lib/api/client', () => ({
  apiClient: {
    get: jest.fn(),
    post: jest.fn(),
    put: jest.fn(),
    delete: jest.fn(),
  },
}))

describe('API Hooks', () => {
  let queryClient: QueryClient
  let wrapper: React.FC<{ children: React.ReactNode }>
  
  beforeEach(() => {
    queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          retry: false,
        },
      },
    })
    
    wrapper = ({ children }) => (
      <QueryClientProvider client={queryClient}>
        {children}
      </QueryClientProvider>
    )
    
    jest.clearAllMocks()
  })
  
  test('useTechniques fetches techniques successfully', async () => {
    const mockData = {
      count: 2,
      results: [
        { id: 1, name: 'Technique 1' },
        { id: 2, name: 'Technique 2' },
      ],
    }
    
    // Mock the API response
    jest.spyOn(apiClient, 'get').mockResolvedValue({ data: mockData })
    
    const { result } = renderHook(() => useTechniques(), { wrapper })
    
    // Initially loading
    expect(result.current.isLoading).toBe(true)
    
    // Wait for data to resolve
    await waitFor(() => expect(result.current.isLoading).toBe(false))
    
    // Check data is returned correctly
    expect(result.current.data).toEqual(mockData)
    
    // Verify API called with correct parameters
    expect(apiClient.get).toHaveBeenCalled()
  })
  
  test('useTechniqueDetail fetches technique details', async () => {
    const mockTechnique = {
      id: 1,
      name: 'Technique 1',
      description: 'Description 1',
      // ... other technique properties
    }
    
    jest.spyOn(apiClient, 'get').mockResolvedValue({ data: mockTechnique })
    
    const { result } = renderHook(() => useTechniqueDetail(1), { wrapper })
    
    await waitFor(() => expect(result.current.isLoading).toBe(false))
    
    expect(result.current.data).toEqual(mockTechnique)
    expect(apiClient.get).toHaveBeenCalledWith('/api/techniques/1')
  })
  
  test('useTechniqueDetail handles errors correctly', async () => {
    jest.spyOn(apiClient, 'get').mockRejectedValue(new Error('Network error'))
    
    const { result } = renderHook(() => useTechniqueDetail(1), { wrapper })
    
    await waitFor(() => expect(result.current.isLoading).toBe(false))
    
    expect(result.current.error).toBeTruthy()
    expect(apiClient.get).toHaveBeenCalledWith('/api/techniques/1')
  })
})

// =====================================================
// 4. PAGE COMPONENT TESTS
// =====================================================

// src/__tests__/app/page.test.tsx
import { render, screen } from '@testing-library/react'
import HomePage from '@/app/page'

// Mock hooks and next/navigation as needed
jest.mock('next/navigation', () => ({
  useRouter: () => ({
    push: jest.fn(),
  }),
  useSearchParams: () => ({
    get: jest.fn(),
  }),
}))

describe('Home Page', () => {
  test('renders hero section', () => {
    render(<HomePage />)
    
    expect(screen.getByText('TEA Techniques Database')).toBeInTheDocument()
    expect(screen.getByText(/A platform for exploring techniques/i)).toBeInTheDocument()
    expect(screen.getByRole('link', { name: /Explore Techniques/i })).toBeInTheDocument()
  })
  
  test('renders feature section', () => {
    render(<HomePage />)
    
    expect(screen.getByText('Key Features')).toBeInTheDocument()
    expect(screen.getByText('Structured Documentation')).toBeInTheDocument()
    expect(screen.getByText('Searchable Database')).toBeInTheDocument()
    expect(screen.getByText('Open Platform')).toBeInTheDocument()
  })
  
  test('renders call to action section', () => {
    render(<HomePage />)
    
    expect(screen.getByText('Ready to get started?')).toBeInTheDocument()
    expect(screen.getByRole('link', { name: /Explore Techniques/i })).toBeInTheDocument()
  })
})

// src/__tests__/app/techniques/[id]/page.test.tsx
import { render, screen, waitFor } from '@testing-library/react'
import TechniqueDetailPage from '@/app/techniques/[id]/page'
import * as hooks from '@/lib/api/hooks'

// Mock useParams
jest.mock('next/navigation', () => ({
  useParams: () => ({ id: '1' }),
  useRouter: () => ({
    push: jest.fn(),
  }),
  useSearchParams: () => ({
    get: jest.fn(),
  }),
}))

// Mock hooks
jest.mock('@/lib/api/hooks', () => ({
  useTechniqueDetail: jest.fn(),
}))

describe('Technique Detail Page', () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })
  
  test('renders technique details correctly', async () => {
    const mockTechnique = {
      id: 1,
      name: 'Test Technique',
      description: 'This is a test technique description',
      model_dependency: 'Model-Agnostic',
      category_tags: '#category/subcategory',
      assurance_goals: [{ id: 1, name: 'Explainability', description: 'Desc' }],
      categories: [{ id: 1, name: 'Category 1', description: 'Desc', assurance_goal: 1, assurance_goal_name: 'Explainability' }],
      subcategories: [],
      tags: [],
      attribute_values: [],
      resources: [],
      example_use_cases: [],
      limitations: [],
    }
    
    jest.spyOn(hooks, 'useTechniqueDetail').mockReturnValue({
      data: mockTechnique,
      isLoading: false,
      error: null,
    } as any)
    
    render(<TechniqueDetailPage />)
    
    expect(screen.getByText('Test Technique')).toBeInTheDocument()
    expect(screen.getByText('This is a test technique description')).toBeInTheDocument()
    expect(screen.getByText('Model-Agnostic')).toBeInTheDocument()
    expect(screen.getByText('Explainability')).toBeInTheDocument()
  })
  
  test('shows loading state', async () => {
    jest.spyOn(hooks, 'useTechniqueDetail').mockReturnValue({
      isLoading: true,
      error: null,
    } as any)
    
    render(<TechniqueDetailPage />)
    
    expect(screen.getByText(/loading technique details/i)).toBeInTheDocument()
  })
  
  test('shows error state', async () => {
    jest.spyOn(hooks, 'useTechniqueDetail').mockReturnValue({
      isLoading: false,
      error: new Error('Failed to fetch technique'),
      data: null,
    } as any)
    
    render(<TechniqueDetailPage />)
    
    expect(screen.getByText(/Error Loading Technique/i)).toBeInTheDocument()
  })
})

// =====================================================
// 5. END-TO-END TESTING: Full User Flows
// =====================================================

/**
 * For end-to-end tests, consider using Cypress or Playwright
 * to test full user flows in a real browser environment.
 * 
 * Example E2E tests might include:
 * 
 * 1. Navigating from home to techniques page
 * 2. Applying filters and seeing filtered results
 * 3. Viewing technique details and navigating back
 * 4. Using pagination to browse techniques
 * 5. Testing dark mode toggle functionality
 * 
 * Below is a Cypress test example (you would need to install Cypress first)
 */

// cypress/e2e/browse-techniques.cy.ts
/*
describe('Browse Techniques', () => {
  it('should navigate to techniques page and apply filters', () => {
    // Visit the home page
    cy.visit('/')
    
    // Click on "Explore Techniques" button
    cy.contains('Explore Techniques').click()
    
    // Verify we're on the techniques page
    cy.url().should('include', '/techniques')
    
    // Open the filter sidebar if needed
    cy.get('[aria-label="Show filters"]').click()
    
    // Apply a filter (e.g., select "Explainability")
    cy.contains('Explainability').click()
    
    // Verify URL contains the filter
    cy.url().should('include', 'assurance_goals=')
    
    // Verify filtered results
    cy.get('[data-testid="technique-card"]').should('exist')
    
    // Click on a technique to view details
    cy.get('[data-testid="technique-card"]').first().click()
    
    // Verify we're on the detail page
    cy.url().should('match', /\/techniques\/\d+/)
    
    // Verify technique details are displayed
    cy.contains('Technique Attributes').should('be.visible')
  })
})
*/

// Testing context providers
// src/__tests__/lib/context/dark-mode.test.tsx
import { render, screen } from '@testing-library/react'
import { DarkModeProvider, useDarkMode, DarkModeToggle } from '@/lib/context/dark-mode'

// Create a test component that uses the dark mode context
const TestComponent = () => {
  const { isDarkMode, toggleDarkMode } = useDarkMode()
  return (
    <div>
      <span>Dark Mode: {isDarkMode ? 'On' : 'Off'}</span>
      <button onClick={toggleDarkMode}>Toggle</button>
    </div>
  )
}

describe('Dark Mode Context', () => {
  beforeEach(() => {
    // Mock localStorage
    Object.defineProperty(window, 'localStorage', {
      value: {
        getItem: jest.fn(),
        setItem: jest.fn(),
      },
      writable: true,
    })
    
    // Mock matchMedia
    Object.defineProperty(window, 'matchMedia', {
      value: jest.fn().mockImplementation(query => ({
        matches: false,
        media: query,
        onchange: null,
        addListener: jest.fn(),
        removeListener: jest.fn(),
        addEventListener: jest.fn(),
        removeEventListener: jest.fn(),
        dispatchEvent: jest.fn(),
      })),
      writable: true,
    })
    
    // Mock document.documentElement
    Object.defineProperty(document, 'documentElement', {
      value: {
        classList: {
          add: jest.fn(),
          remove: jest.fn(),
        },
      },
      writable: true,
    })
  })
  
  test('provides dark mode context to children', async () => {
    render(
      <DarkModeProvider>
        <TestComponent />
      </DarkModeProvider>
    )
    
    // Initially dark mode should be off (default)
    expect(screen.getByText('Dark Mode: Off')).toBeInTheDocument()
    
    // Toggle dark mode
    await userEvent.click(screen.getByText('Toggle'))
    
    // Now dark mode should be on
    expect(screen.getByText('Dark Mode: On')).toBeInTheDocument()
    
    // Check if localStorage was called with the correct values
    expect(localStorage.setItem).toHaveBeenCalledWith('darkMode', 'true')
    
    // Check if the class was added to the document element
    expect(document.documentElement.classList.add).toHaveBeenCalledWith('dark')
  })
  
  test('DarkModeToggle component works correctly', async () => {
    render(
      <DarkModeProvider>
        <DarkModeToggle />
      </DarkModeProvider>
    )
    
    // Find the toggle button
    const toggleButton = screen.getByRole('button')
    expect(toggleButton).toBeInTheDocument()
    
    // Initially should show the moon icon (for light mode)
    expect(toggleButton.querySelector('svg')).toBeInTheDocument()
    
    // Click the toggle
    await userEvent.click(toggleButton)
    
    // Now should show the sun icon (for dark mode)
    expect(toggleButton.querySelector('svg')).toBeInTheDocument()
    
    // Check if the class was added to the document element
    expect(document.documentElement.classList.add).toHaveBeenCalledWith('dark')
  })
})
</file>

<file path="frontend/jest.setup.ts">
import '@testing-library/jest-dom';

// MSW setup is disabled temporarily to allow tests to run
// We're manually mocking all API calls in our tests

// Mock handlers that would be provided by MSW
beforeAll(() => {
  console.log('Setting up test environment');
});

// Clean up after each test
afterEach(() => {
  console.log('Cleaning up after test');
});

// Final cleanup
afterAll(() => {
  console.log('Test suite completed');
});
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "typeRoots": ["./node_modules/@types", "./src/types"],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="nginx/tea-techniques.conf.template">
server {
    listen 80;
    server_name ${NGINX_SERVER_NAME};

    access_log /var/log/nginx/tea-techniques-access.log;
    error_log /var/log/nginx/tea-techniques-error.log;

    # Frontend routes
    location / {
        proxy_pass http://frontend:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }

    # Backend API routes
    location /api/ {
        proxy_pass http://backend:8000;
        proxy_set_header Host localhost:8000;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Django admin
    location /admin/ {
        proxy_pass http://backend:8000;
        proxy_set_header Host localhost:8000;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Static files
    location /static/ {
        proxy_pass http://backend:8000;
        proxy_set_header Host localhost:8000;
    }

    # Swagger docs
    location /swagger/ {
        proxy_pass http://backend:8000;
        proxy_set_header Host localhost:8000;
    }

    # Health check endpoint
    location /health {
        return 200 'OK';
        add_header Content-Type text/plain;
    }
}
</file>

<file path=".env.tailscale">
# .env.tailscale (For TAILSCALE deployment)

# Backend settings
SECRET_KEY=your_actual_production_secret_key_here # CHANGE THIS
DJANGO_SETTINGS_MODULE=config.settings.production # Use production settings
DEBUG=False
ALLOWED_HOSTS=your-domain.ts.net,backend,nginx # Restrict to Tailscale domain + service names
CORS_ALLOWED_ORIGINS=https://your-domain.ts.net
CSRF_TRUSTED_ORIGINS=https://your-domain.ts.net

# Database settings (used by backend service)
DB_NAME=techniques
DB_USER=postgres
DB_PASSWORD=postgres_production_password # CHANGE THIS
DB_HOST=db
DB_PORT=5432

# Frontend settings
NODE_ENV=production
BACKEND_URL=http://backend:8000

# Public URLs (relative paths are fine)
NEXT_PUBLIC_API_URL=/api
NEXT_PUBLIC_SWAGGER_URL=/swagger/

# Nginx settings (for config generation)
NGINX_SERVER_NAME=your-domain.ts.net # Use the Tailscale domain here
</file>

<file path="CONTRIBUTING.md">
# Contributing Guide

## Overview

Thank you for your interest in contributing to the TEA Techniques project! This guide will help you understand the contribution workflow and ensure your contributions are aligned with the project's standards.

## Getting Started

### Prerequisites

Before you begin, please ensure you have:

1. Read the [README.md](README.md) for a project overview
2. Set up your development environment as described in [DEVELOPMENT-WORKFLOW.md](docs/DEVELOPMENT-WORKFLOW.md)
3. Familiarised yourself with the [Model Architecture](docs/MODEL-ARCHITECTURE.md) and [Frontend Guide](docs/FRONTEND-GUIDE.md)

### Code of Conduct

This project adheres to a code of conduct that promotes a welcoming and inclusive environment. By participating, you are expected to uphold this code.

## Contribution Workflow

### 1. Issue Selection

All contributions should start with an issue:

- Check existing [issues](https://github.com/chrisdburr/tea-techniques/issues) for something you'd like to work on
- If your idea isn't covered by an existing issue, create a new one
- If the issue already exists, please comment on the issue to express your interest in working on it
- Please wait for the project maintainers to respond and assign the issue to you

### 2. Branching Strategy

Once an issue is assigned to you:

1. Create a new branch from `main` with a descriptive name:

   ```bash
   git checkout -b feature/descriptive-name
   # or
   git checkout -b fix/descriptive-name
   ```

2. Use the following branch naming convention:
   - `feature/` - For new features or enhancements
   - `fix/` - For bug fixes
   - `docs/` - For documentation changes
   - `refactor/` - For code refactoring
   - `test/` - For adding or modifying tests

### 3. Development Guidelines

#### Backend (Django)

- Follow the [Django Style Guide](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/)
- Use PascalCase for class names, snake_case for variables and functions
- Write tests for all new functionality
- Document API endpoints and models

#### Frontend (Next.js)

- Follow [TypeScript best practices](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html)
- Use Functional Components with Hooks
- Use TypeScript interfaces from `src/lib/types.ts`
- Follow the component structure in `FRONTEND-GUIDE.md`
- Ensure responsive design

#### General Guidelines

- Keep commits small and focused
- Write clear commit messages
- Document complex logic
- Follow existing patterns in the codebase

### 4. Testing

All code changes should include appropriate tests:

#### Backend Tests

```bash
cd backend
poetry run pytest
```

#### Frontend Tests

```bash
cd frontend
npm run test
```

### 5. Pull Request Process

When your changes are ready:

1. Ensure all tests pass
2. Update documentation as needed
3. Push your branch to your fork
4. Create a pull request to the `main` branch of the main repository
5. Provide a clear PR description explaining:
   - What the PR does
   - How to test the changes
   - Screenshots (for UI changes)
   - Related issues

Example PR template:

```markdown
## Description

Brief description of the changes

## Related Issue

Fixes #123

## Type of Change

- [ ] Bug fix
- [ ] New feature
- [ ] Documentation update
- [ ] Refactoring
- [ ] Performance improvement

## How to Test

1. Steps to test
2. Expected result

## Screenshots (if appropriate)

## Additional Notes

Any additional information
```

### 6. Code Review

All PRs require review before merging:

- Address all review comments
- Keep discussions constructive and focused on the code
- Be open to feedback and willing to make changes

### 7. Merging

Once approved, a maintainer will merge your PR. The typical merge strategy is squash and merge to keep the commit history clean.

## Data Contributions

To contribute new techniques or update existing ones:

1. Review the [Data Management Guide](docs/DATA-MANAGEMENT.md)
2. Follow the schema defined in the JSON templates
3. Submit a PR with your changes to the data files

## Documentation Contributions

Documentation improvements are highly valued:

1. Ensure information is accurate and clear
2. Follow the existing documentation structure
3. Include links to related documentation where helpful
4. Update screenshots if UI changes are significant

## Issue Reporting

If you find a bug or have a feature request:

1. Check if it's already reported
2. Use the issue template
3. Include as much detail as possible:
   - Steps to reproduce
   - Expected vs. actual behavior
   - Screenshots if applicable
   - Environment details

## Getting Help

If you need help with your contribution:

- Comment on the relevant issue
- Reach out to maintainers
- Join community discussions

## Recognition

All contributors will be acknowledged in the project.

<!-- TODO: Add all-contributors support. -->

## Related Links

- [Model Architecture](docs/MODEL-ARCHITECTURE.md)
- [Frontend Guide](docs/FRONTEND-GUIDE.md)
- [Testing Guide](docs/TESTING.md)
- [Data Management Guide](docs/DATA-MANAGEMENT.md)
</file>

<file path="backend/api/management/commands/reset_database.py">
# backend/api/management/commands/reset_database.py
import os
import subprocess
from pathlib import Path
from django.core.management.base import BaseCommand
from django.contrib.auth.models import User
from django.conf import settings
from django.db import connections


class Command(BaseCommand):
    help = "Reset the database and recreate migrations"

    def add_arguments(self, parser):
        parser.add_argument(
            "--force", action="store_true", help="Skip confirmation prompt"
        )
        parser.add_argument(
            "--create-admin",
            action="store_true",
            default=True,
            help="Create an admin user (admin/admin)",
        )

    def handle(self, *args, **options):
        force = options.get("force", False)
        create_admin = options.get("create_admin", True)

        # Get the base directory
        BASE_DIR = Path(settings.BASE_DIR)

        # Check if user wants to proceed with reset
        if not force:
            response = input(
                "This will COMPLETELY RESET your database. Are you sure? (y/n): "
            )
            if response.lower() != "y":
                self.stdout.write("Operation cancelled.")
                return

        # Reset database
        self.reset_database(BASE_DIR)

        # Create admin user if specified
        if create_admin:
            self.create_admin_user()

        self.stdout.write(self.style.SUCCESS("✅ Database reset complete!"))

    def reset_database(self, BASE_DIR):
        """Reset the database and migrations"""
        self.stdout.write(self.style.WARNING("\n===== DATABASE RESET PROCESS ====="))

        # Clear existing migrations to avoid conflicts
        migrations_dir = BASE_DIR / "api" / "migrations"
        migration_count = 0
        for file_path in migrations_dir.glob("*.py"):
            if file_path.name != "__init__.py":
                file_path.unlink()
                migration_count += 1
        self.stdout.write(f"✓ Cleared {migration_count} migration files")

        # Create new migrations based on current models
        self.stdout.write("\n----- Creating fresh migrations -----")
        self.run_command("python manage.py makemigrations")

        # Apply migrations to set up database schema
        self.stdout.write("\n----- Creating database schema -----")
        self.run_command("python manage.py migrate")

    def create_admin_user(self):
        """Create admin user if not exists"""
        self.stdout.write("\n----- Creating admin user -----")
        if not User.objects.filter(username="admin").exists():
            User.objects.create_superuser("admin", "admin@example.com", "admin")
            self.stdout.write("✓ Created admin user (username: admin, password: admin)")
        else:
            self.stdout.write("✓ Admin user already exists")

    def run_command(self, cmd):
        """Run a shell command and display its output"""
        self.stdout.write(f"Running: {cmd}")
        # Pass the current environment with any updates to subprocesses
        env = os.environ.copy()
        subprocess.run(cmd, shell=True, check=True, env=env)
</file>

<file path="backend/api/management/commands/tailscale_setup.py">
# backend/api/management/commands/tailscale_setup.py
import os
import subprocess
from pathlib import Path
from django.core.management.base import BaseCommand
from django.conf import settings
from django.db import connections


class Command(BaseCommand):
    help = "Special setup for Tailscale deployments with PostgreSQL"

    def handle(self, *args, **options):
        # Get the base directory
        BASE_DIR = Path(settings.BASE_DIR)
        
        # Close existing connections to ensure we use the new config
        connections.close_all()
        
        self.stdout.write(self.style.SUCCESS("Using PostgreSQL database for Tailscale deployment"))
        
        # Run migrations
        self.stdout.write("\n----- Applying migrations to database -----")
        try:
            self.run_command("python manage.py migrate")
        except Exception as e:
            self.stdout.write(self.style.ERROR(f"Migration error: {str(e)}"))
            self.stdout.write(self.style.WARNING("Trying to continue anyway..."))
        
        # Import techniques with more robust error handling
        self.stdout.write("\n----- Importing techniques data -----")
        try:
            self.run_command("python manage.py import_techniques")
        except Exception as e:
            self.stdout.write(self.style.ERROR(f"Error during import: {str(e)}"))
            # Try an alternative approach - direct import
            self.stdout.write(self.style.WARNING("Trying alternative import method..."))
            from django.core import management
            management.call_command('import_techniques', force=True)
        
        # Verify data
        try:
            from api.models import Technique
            technique_count = Technique.objects.count()
            self.stdout.write(self.style.SUCCESS(f"✓ Successfully imported {technique_count} techniques"))
        except Exception as e:
            self.stdout.write(self.style.ERROR(f"Error checking technique count: {str(e)}"))
        
        # Create admin user
        from django.contrib.auth.models import User
        if not User.objects.filter(username="admin").exists():
            User.objects.create_superuser("admin", "admin@example.com", "admin")
            self.stdout.write("✓ Created admin user (username: admin, password: admin)")
        
        self.stdout.write(self.style.SUCCESS("\n✅ Tailscale deployment setup complete!"))
    
    def run_command(self, cmd):
        """Run a shell command and display its output with better error handling"""
        self.stdout.write(f"Running: {cmd}")
        env = os.environ.copy()
        
        try:
            # First attempt with quieter output
            result = subprocess.run(
                cmd, 
                shell=True, 
                check=True, 
                env=env,
                capture_output=True,
                text=True
            )
            self.stdout.write(self.style.SUCCESS("Command completed successfully"))
            return result
        except subprocess.CalledProcessError as e:
            self.stdout.write(self.style.ERROR(f"Command failed with exit code {e.returncode}"))
            self.stdout.write(self.style.ERROR(f"STDERR: {e.stderr}"))
            self.stdout.write(self.style.ERROR(f"STDOUT: {e.stdout}"))
            raise
</file>

<file path="backend/api/utils.py">
# backend/api/utils.py

from __future__ import annotations

from rest_framework.views import exception_handler
from rest_framework.response import Response
from rest_framework import status
from rest_framework.exceptions import APIException
import logging
from typing import Any, Dict, List, Optional, Union, cast

logger = logging.getLogger(__name__)


def custom_exception_handler(exc: Exception, context: Dict[str, Any]) -> Optional[Response]:
    """
    Custom exception handler for REST framework that standardizes error responses.
    
    Returns a consistent error format for all exceptions:
    {
        "detail": "Human-readable error message",
        "status_code": 400,
        "error_type": "ValidationError",
        "errors": {} | null (field-specific errors when applicable)
    }
    """
    # Call REST framework's default exception handler first
    response = exception_handler(exc, context)

    # If response is None, there was an unhandled exception
    if response is None:
        logger.error(f"Unhandled exception: {str(exc)}")
        return Response(
            {
                "detail": "Internal server error occurred",
                "status_code": status.HTTP_500_INTERNAL_SERVER_ERROR,
                "error_type": exc.__class__.__name__,
                "errors": None
            },
            status=status.HTTP_500_INTERNAL_SERVER_ERROR,
        )

    # Standardize the response format
    field_errors = None
    detail_message = "An error occurred"
    
    if isinstance(response.data, dict):
        # Case 1: Validation errors with field-specific messages
        if "non_field_errors" in response.data or any(
            isinstance(response.data.get(field), list) for field in response.data
        ):
            # This is likely a validation error with field-specific messages
            field_errors = response.data
            
            # Create a user-friendly summary message
            if "non_field_errors" in response.data:
                detail_message = "; ".join(response.data["non_field_errors"])
            else:
                detail_message = "Validation error"
                
        # Case 2: Response with 'detail' field
        elif "detail" in response.data:
            detail_message = str(response.data["detail"])
            # Check if there are nested errors to extract
            if isinstance(response.data.get("errors"), dict):
                field_errors = response.data["errors"]
    
    # Prepare the standardized response format
    standardized_response = {
        "detail": detail_message,
        "status_code": response.status_code,
        "error_type": exc.__class__.__name__,
        "errors": field_errors
    }
    
    # Replace the original response data with our standardized format
    response.data = standardized_response
    
    return response
</file>

<file path="backend/data/techniques_schema.json">
{
	"$schema": "http://json-schema.org/draft-07/schema#",
	"title": "TEA Techniques Schema",
	"description": "Schema for the TEA Techniques dataset which catalogs ML/AI techniques with relevant attributes",
	"type": "array",
	"items": {
		"type": "object",
		"properties": {
			"id": {
				"type": "integer",
				"description": "Unique identifier for the technique"
			},
			"name": {
				"type": "string",
				"description": "Name of the technique"
			},
			"description": {
				"type": "string",
				"description": "Description of what the technique does and how it works"
			},
			"model_dependency": {
				"type": "string",
				"enum": ["Model-Agnostic", "Model-Specific", "Organizational"],
				"description": "Whether the technique works with any model or requires specific model types"
			},
			"applicable_models": {
				"type": "array",
				"items": {
					"type": "string"
				},
				"description": "Model types this technique is specifically applicable to"
			},
			"assurance_goals": {
				"type": "array",
				"items": {
					"type": "string"
				},
				"description": "Primary goals related to AI assurance (e.g., Explainability, Fairness, Privacy, etc.)"
			},
			"attributes": {
				"type": "array",
				"items": {
					"type": "object",
					"properties": {
						"type": {
							"type": "string",
							"description": "Type of attribute"
						},
						"value": {
							"type": "string",
							"description": "Value of the attribute"
						}
					},
					"required": ["type", "value"]
				},
				"description": "Structured attributes of the technique, including explanatory scope (global/local)"
			},
			"example_use_cases": {
				"type": "array",
				"items": {
					"type": "object",
					"properties": {
						"description": {
							"type": "string",
							"description": "Description of the use case"
						},
						"goal": {
							"type": "string",
							"description": "The assurance goal this use case addresses"
						}
					},
					"required": ["description"]
				},
				"description": "Examples of how the technique can be used in practice"
			},
			"limitations": {
				"type": "array",
				"items": {
					"oneOf": [
						{
							"type": "string",
							"description": "Simple limitation description (legacy format)"
						},
						{
							"type": "object",
							"properties": {
								"description": {
									"type": "string",
									"description": "Description of the limitation"
								}
							},
							"required": ["description"],
							"description": "Structured limitation object (preferred format)"
						}
					]
				},
				"description": "Limitations and drawbacks of the technique"
			},
			"resources": {
				"type": "array",
				"items": {
					"type": "object",
					"properties": {
						"type": {
							"type": "string",
							"description": "Type of resource"
						},
						"title": {
							"type": "string",
							"description": "Title of the resource"
						},
						"url": {
							"type": "string",
							"format": "uri",
							"description": "URL of the resource"
						},
						"description": {
							"type": "string",
							"description": "Description of the resource"
						},
						"authors": {
							"oneOf": [
								{
									"type": "array",
									"items": {
										"type": "string"
									}
								},
								{
									"type": "string"
								}
							],
							"description": "Authors of the resource"
						},
						"publication_date": {
							"type": "string",
							"description": "Publication date of the resource"
						},
						"source_type": {
							"type": "string",
							"description": "Type of source"
						}
					},
					"required": ["title", "url"]
				},
				"description": "Resources related to the technique (papers, libraries, etc.)"
			},
			"complexity_rating": {
				"type": ["integer", "null"],
				"minimum": 1,
				"maximum": 5,
				"description": "Rating of implementation complexity on a scale from 1 to 5"
			},
			"computational_cost_rating": {
				"type": ["integer", "null"],
				"minimum": 1,
				"maximum": 5,
				"description": "Rating of computational cost on a scale from 1 to 5"
			},
			"category_tags": {
				"type": "string",
				"description": "DEPRECATED: Hashtag-formatted categorization. Use categories and subcategories fields instead."
			},
			"categories": {
				"type": "array",
				"items": {
					"type": "object",
					"properties": {
						"name": {
							"type": "string",
							"description": "Name of the category"
						},
						"assurance_goal": {
							"type": "string",
							"description": "The assurance goal this category belongs to"
						}
					},
					"required": ["name"]
				},
				"description": "List of categories this technique belongs to"
			},
			"subcategories": {
				"type": "array",
				"items": {
					"type": "object",
					"properties": {
						"name": {
							"type": "string",
							"description": "Name of the subcategory"
						},
						"category": {
							"type": "string", 
							"description": "The parent category for this subcategory"
						},
						"assurance_goal": {
							"type": "string",
							"description": "The assurance goal this subcategory belongs to"
						}
					},
					"required": ["name", "category"]
				},
				"description": "List of subcategories this technique belongs to"
			}
		},
		"required": ["name", "description", "model_dependency"]
	}
}
</file>

<file path="backend/data/techniques.json">
[
  {
    "id": 1,
    "name": "SHapley Additive exPlanations (SHAP)",
    "description": "SHAP explains the impact of each feature on a prediction based on Shapley values from cooperative game theory, explicitly assuming feature independence, thus quantifying contributions to predictions in a globally consistent and locally accurate manner.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#feature-analysis/importance-and-attribution",
    "categories": [
      {
        "name": "feature-analysis",
        "assurance_goal": "Explainability"
      }
    ],
    "subcategories": [
      {
        "name": "importance-and-attribution",
        "category": "feature-analysis",
        "assurance_goal": "Explainability"
      }
    ],
    "complexity_rating": 3,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      },
      {
        "type": "Explanatory Scope",
        "value": "Local"
      }
    ],
    "example_use_cases": [
      {
        "description": "Explaining why a complex model (like a neural network) made a specific prediction by showing how each feature influenced that prediction.",
        "goal": "Explainability"
      },
      {
        "description": "Identifying which factors contributed most to a loan approval decision in a financial model using SHAP values.",
        "goal": "Explainability"
      }
    ],
    "resources": [
      {
        "title": "shap",
        "url": "https://github.com/shap/shap",
        "source_type": "software_package",
        "authors": [
          "shap"
        ],
        "publication_date": "2016-11-22"
      },
      {
        "title": "Welcome to the SHAP documentation — SHAP latest documentation",
        "url": "https://shap.readthedocs.io/",
        "source_type": "documentation"
      },
      {
        "title": "Introduction to SHapley Additive exPlanations (SHAP) — XAI Tutorials",
        "url": "https://xai-tutorials.readthedocs.io/en/latest/_model_agnostic_xai/shap.html",
        "source_type": "tutorial"
      },
      {
        "title": "Explanation of Machine Learning Models Using Shapley Additive Explanation and Application for Real Data in Hospital",
        "url": "http://arxiv.org/pdf/2112.11071v2",
        "source_type": "technical_paper",
        "authors": [
          "Yasunobu Nohara",
          "Koutarou Matsumoto",
          "Hidehisa Soejima",
          "Naoki Nakashima"
        ],
        "publication_date": "2021-12-21"
      },
      {
        "title": "Additive-feature-attribution methods: a review on explainable artificial intelligence for fluid dynamics and heat transfer",
        "url": "http://arxiv.org/pdf/2409.11992v1",
        "source_type": "review_paper",
        "authors": [
          "Andrés Cremades",
          "Sergio Hoyas",
          "Ricardo Vinuesa"
        ],
        "publication_date": "2024-09-18"
      }
    ],
    "applicable_models": [],
    "limitations": [
      {
        "description": "Assumes feature independence, so results can be less reliable when features are highly correlated."
      },
      {
        "description": "Computationally intensive for large models or datasets (calculating many Shapley values is slow)."
      }
    ]
  },
  {
    "id": 2,
    "name": "Permutation Importance",
    "description": "Permutation importance measures a feature's importance by shuffling its values and observing the impact on model performance. If the model's accuracy drops significantly when a feature is permuted, that feature is considered important.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#feature-analysis/importance-and-attribution",
    "categories": [
      {
        "name": "feature-analysis",
        "assurance_goal": "Explainability"
      }
    ],
    "subcategories": [
      {
        "name": "importance-and-attribution",
        "category": "feature-analysis",
        "assurance_goal": "Explainability"
      }
    ],
    "complexity_rating": 2,
    "computational_cost_rating": 2,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Assessing which features are most important in a trained Random Forest by measuring performance drop when each feature's values are shuffled.",
        "goal": "Explainability"
      },
      {
        "description": "Checking that a model is not relying on an irrelevant field by confirming that shuffling that field doesn't change the model's accuracy.",
        "goal": "Explainability"
      }
    ],
    "resources": [
      {
        "title": "Permutation Importance — ELI5 0.11.0 documentation",
        "url": "https://eli5.readthedocs.io/en/latest/blackbox/permutation_importance.html",
        "source_type": "documentation"
      },
      {
        "title": "classification - XGBoost Feature Importance, Permutation ...",
        "url": "https://datascience.stackexchange.com/questions/65608/xgboost-feature-importance-permutation-importance-and-model-evaluation-criteri",
        "source_type": "tutorial"
      },
      {
        "title": "Asymptotic Unbiasedness of the Permutation Importance Measure in Random Forest Models",
        "url": "http://arxiv.org/pdf/1912.03306v1",
        "source_type": "technical_paper",
        "authors": [
          "Burim Ramosaj",
          "Markus Pauly"
        ],
        "publication_date": "2019-12-05"
      },
      {
        "title": "lofo-importance",
        "url": "https://github.com/aerdem4/lofo-importance",
        "source_type": "software_package",
        "authors": [
          "aerdem4"
        ],
        "publication_date": "2019-01-14"
      }
    ],
    "applicable_models": [],
    "limitations": [
      {
        "description": "Can be misleading when features are correlated, and computationally expensive on high-dimensional datasets due to repetitive model evaluations."
      }
    ]
  },
  {
    "id": 3,
    "name": "Mean Decrease Impurity",
    "description": "Mean Decrease Impurity evaluates feature importance by calculating the reduction in impurity across all splits in tree-based models, typically biased towards numerical features with many distinct values or categories.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#feature-analysis/importance-and-attribution",
    "complexity_rating": 2,
    "computational_cost_rating": 1,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Determining important features in Random Forest classification tasks.",
        "goal": "Explainability"
      }
    ],
    "resources": [
      {
        "type": "Transparency",
        "title": "Feature Importance Measures in Random Forests (Scikit-learn)",
        "url": "https://scikit-learn.org/stable/auto_examples/ensemble/plot_forest_importances.html"
      },
      {
        "title": "optuna.importance.MeanDecreaseImpurityImportanceEvaluator ...",
        "url": "https://optuna.readthedocs.io/en/stable/reference/generated/optuna.importance.MeanDecreaseImpurityImportanceEvaluator.html",
        "source_type": "documentation"
      },
      {
        "title": "A Debiased MDI Feature Importance Measure for Random Forests",
        "url": "http://arxiv.org/pdf/1906.10845v2",
        "source_type": "technical_paper",
        "authors": [
          "Xiao Li",
          "Yu Wang",
          "Sumanta Basu",
          "Karl Kumbier",
          "Bin Yu"
        ],
        "publication_date": "2019-06-26"
      },
      {
        "title": "Variable Importance in Random Forests | Towards Data Science",
        "url": "https://towardsdatascience.com/variable-importance-in-random-forests-20c6690e44e0/",
        "source_type": "tutorial"
      }
    ],
    "applicable_models": [
      "Decision Trees",
      "Random Forests",
      "Gradient Boosting Models"
    ],
    "limitations": [
      "[{\"description\": \"Biased towards features with more splits or categories; only applicable to tree-based models and can overestimate importance of high-cardinality features.\"}]"
    ]
  },
  {
    "id": 4,
    "name": "Gini Importance",
    "description": "Gini importance sums the total reduction in Gini impurity across all splits, essentially identical to Mean Decrease Impurity (MDI), sharing its biases and limitations.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#feature-analysis/importance-and-attribution",
    "complexity_rating": 2,
    "computational_cost_rating": 1,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Selecting important features when building tree-based classification models.",
        "goal": "Explainability"
      }
    ],
    "resources": [
      {
        "type": "Transparency",
        "title": "Feature Importance Measures in Random Forests (Scikit-learn)",
        "url": "https://scikit-learn.org/stable/auto_examples/ensemble/plot_forest_importances.html"
      },
      {
        "title": "Unbiased variable importance for random forests",
        "url": "http://arxiv.org/pdf/2003.02106v2",
        "source_type": "technical_paper",
        "authors": [
          "Markus Loecher"
        ],
        "publication_date": "2020-03-04"
      },
      {
        "title": "Best Practice to Calculate and Interpret Model Feature Importance ...",
        "url": "https://towardsdatascience.com/best-practice-to-calculate-and-interpret-model-feature-importance-14f0e11ee660/",
        "source_type": "tutorial"
      },
      {
        "title": "random-forest-importances",
        "url": "https://github.com/parrt/random-forest-importances",
        "source_type": "software_package",
        "authors": [
          "parrt"
        ],
        "publication_date": "2018-03-22"
      },
      {
        "title": "lightgbm.plot_importance — LightGBM 4.6.0.99 documentation",
        "url": "https://lightgbm.readthedocs.io/en/latest/pythonapi/lightgbm.plot_importance.html",
        "source_type": "documentation"
      }
    ],
    "applicable_models": [
      "Decision Trees",
      "Random Forests"
    ],
    "limitations": [
      "[{\"description\": \"Tends to inflate importance for features with many values; like MDI, it is specific to tree models and not reliable for comparing across different model types.\"}]"
    ]
  },
  {
    "id": 5,
    "name": "Coefficient Magnitudes (in Linear Models)",
    "description": "Examines the absolute values of coefficients in linear models to judge feature influence. Features with larger absolute coefficients have a stronger impact on the prediction, and the sign of a coefficient shows if it pushes the outcome up or down.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#feature-analysis/importance-and-attribution",
    "complexity_rating": 1,
    "computational_cost_rating": 1,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Interpreting which features influence housing price predictions in linear regression.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Linear Regression",
      "Logistic Regression",
      "Ridge Regression",
      "Lasso Regression"
    ],
    "limitations": [
      "[{\"description\": \"Only valid for linear relationships; can be affected by feature scaling and multicollinearity, and does not capture non-linear importance.\"}]"
    ]
  },
  {
    "id": 6,
    "name": "Integrated Gradients",
    "description": "Integrated Gradients attributes each feature's contribution by accumulating the gradients of the model's output with respect to that feature as the input moves from a baseline value to its actual value. This results in a score for each feature that reflects how much it influenced the prediction compared to a reference baseline.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#feature-analysis/importance-and-attribution",
    "complexity_rating": 4,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Local"
      }
    ],
    "example_use_cases": [
      {
        "description": "Understanding pixel contributions in image classification with deep neural networks.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "General Neural Networks",
      "CNNs",
      "RNNs",
      "Transformers"
    ],
    "limitations": [
      "[{\"description\": \"Requires a meaningful baseline input; results can be sensitive to the choice of baseline and model must be differentiable, limiting use with non-differentiable components.\"}]"
    ]
  },
  {
    "id": 7,
    "name": "DeepLIFT",
    "description": "DeepLIFT assigns credit (or blame) to each input feature by comparing a neuron's activation to a reference (baseline) and tracking the difference backward through the network. It attributes the change in the output to changes in each input feature relative to what the output would be at the reference input.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#feature-analysis/importance-and-attribution",
    "complexity_rating": 4,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Local"
      }
    ],
    "example_use_cases": [
      {
        "description": "Explaining why a neural network classifies an image as a specific object by tracing neuron activations.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "General Neural Networks",
      "CNNs",
      "RNNs"
    ],
    "limitations": [
      "[{\"description\": \"Needs careful configuration for each network architecture; may produce inconsistent scores if multiple reference points are possible, and not all model types supported.\"}]"
    ]
  },
  {
    "id": 8,
    "name": "Layer-wise Relevance Propagation (LRP)",
    "description": "LRP explains a model's prediction by propagating the result backwards through the network and assigning a relevance score to each input feature. Starting from the predicted output, it distributes the 'relevance' of that output to neurons in each preceding layer, all the way back to the input features, indicating how each feature contributed.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#feature-analysis/importance-and-attribution",
    "complexity_rating": 5,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Local"
      }
    ],
    "example_use_cases": [
      {
        "description": "Visualising important regions in medical images for disease diagnosis using deep learning models.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "General Neural Networks",
      "CNNs",
      "RNNs"
    ],
    "limitations": [
      "[{\"description\": \"Requires tailored rules for each layer type; results can sometimes be hard to interpret (negative relevances), and implementation is complex for new architectures.\"}]"
    ]
  },
  {
    "id": 9,
    "name": "Variable Importance in Random Forests (MDA MDG)",
    "description": "Random Forest algorithms can provide two types of feature importance: Mean Decrease Accuracy (MDA) measures how model accuracy decreases when a feature is permuted, while Mean Decrease Gini (MDG) measures how each feature contributes to node purity in the forest. Together, they provide different perspectives on which features drive the model's decisions.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#feature-analysis/importance-and-attribution",
    "complexity_rating": 2,
    "computational_cost_rating": 2,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Identifying key predictors in a Random Forest model for credit scoring.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Random Forests"
    ],
    "limitations": [
      "[{\"description\": \"Permutation importance (MDA) shares limitations with correlated features; Gini importance (MDG) biases towards continuous or high-cardinality features.\"}]"
    ]
  },
  {
    "id": 10,
    "name": "Contextual Decomposition",
    "description": "Contextual Decomposition interprets neural network predictions by breaking down the model's output into parts attributed to specific input features or groups of features. It isolates the contribution of a particular input (or a combination of inputs) to the final prediction, taking into account the context provided by the other inputs.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#feature-analysis/importance-and-attribution",
    "complexity_rating": 5,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Local"
      }
    ],
    "example_use_cases": [
      {
        "description": "Explaining sentiment predictions in text by attributing scores to words or phrases.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "LSTMs",
      "RNNs"
    ],
    "limitations": [
      "[{\"description\": \"Primarily designed for LSTMs; not widely implemented in standard libraries, requiring custom code, and may not scale well to very deep or different model types.\"}]"
    ]
  },
  {
    "id": 11,
    "name": "Taylor Decomposition",
    "description": "Taylor Decomposition explains a prediction by using a Taylor series expansion of the model's prediction function around a given input. It breaks the prediction into components attributed to each feature (and combinations of features) by interpreting the series terms, giving an approximate contribution of each feature to the output.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#feature-analysis/importance-and-attribution",
    "complexity_rating": 5,
    "computational_cost_rating": 4,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Local"
      }
    ],
    "example_use_cases": [
      {
        "description": "Attributing feature contributions in complex models for specific predictions.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "General Neural Networks"
    ],
    "limitations": [
      "[{\"description\": \"The approach is mathematically complex and can be computationally intensive; approximations may introduce error and it's mainly theoretical with limited tooling.\"}]"
    ]
  },
  {
    "id": 12,
    "name": "Sobol Indices",
    "description": "Sobol Indices are global sensitivity analysis measures that quantify how much each input variable (and combinations of variables) contribute to the output's variance. They provide values for individual features and feature interactions, indicating the proportion of output variation each is responsible for in the model.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#feature-analysis/interaction-analysis",
    "complexity_rating": 4,
    "computational_cost_rating": 5,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Understanding parameter impacts in environmental modeling outputs.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Requires a large number of model evaluations for accurate estimation; assumes independent input distributions and may be difficult to apply to high-dimensional inputs.\"}]"
    ]
  },
  {
    "id": 13,
    "name": "Feature Interaction Detection (H-statistic)",
    "description": "The H-statistic measures the strength of interaction between two features in a model by comparing their combined effect on the prediction to the sum of their individual effects. A higher H-statistic for a feature pair means the model's prediction cannot be explained by additive effects of the two features alone, indicating a significant interaction.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#feature-analysis/interaction-analysis",
    "complexity_rating": 4,
    "computational_cost_rating": 4,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Identifying significant interactions in healthcare predictive models.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Only captures pairwise interactions (or one feature vs all); relies on partial dependence which can be misleading if features are correlated or have complex interactions.\"}]"
    ]
  },
  {
    "id": 14,
    "name": "Local Interpretable Model-Agnostic Explanations (LIME)",
    "description": "LIME explains an individual prediction by training a simple surrogate model around that specific data point. It perturbs the input data point to create synthetic data, gets the complex model's predictions for these new points, and then fits an interpretable model (like a small linear model) on this local dataset. The surrogate's parameters (or rules) then highlight which features of the original data point influenced the prediction the most in that locality.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#model-approximation/local-surrogates",
    "complexity_rating": 2,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Local"
      }
    ],
    "example_use_cases": [
      {
        "description": "Explaining why a customer was denied a loan by approximating the model's decision locally.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Explanations can vary with repeated runs due to randomness; the linear surrogate may not be faithful if the model behavior is highly non-linear in that locality.\"}]"
    ]
  },
  {
    "id": 15,
    "name": "Ridge Regression Surrogates",
    "description": "This technique approximates a complex model by training a ridge regression (a linear model with L2 regularization) on the original model's predictions. The ridge regression serves as a global surrogate that balances fidelity and interpretability, capturing the main linear relationships that the complex model learned while ignoring noise due to regularization.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#model-approximation/global-surrogates",
    "complexity_rating": 3,
    "computational_cost_rating": 2,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Summarizing complex model behavior for regulatory reporting in finance.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"The surrogate only approximates the original model, potentially losing important non-linear behavior; requires a representative dataset to train the surrogate model.\"}]"
    ]
  },
  {
    "id": 16,
    "name": "Partial Dependence Plots (PDP)",
    "description": "Partial Dependence Plots illustrate how the predicted outcome changes as one (or two) features vary, averaging out the effects of all other features. They show the marginal effect of selected features on the model prediction by plotting the average prediction as a function of those features.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#visualization-techniques/feature-visualization",
    "complexity_rating": 2,
    "computational_cost_rating": 2,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Understanding how changes in age affect predicted disease risk in medical models.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Assumes features are independent of others (due to averaging); can be misleading when features are correlated, and only shows average effects, not instance-specific.\"}]"
    ]
  },
  {
    "id": 17,
    "name": "Accumulated Local Effects Plots (ALE)",
    "description": "ALE plots show how features influence predictions, like PDPs, but they do so by calculating local changes in the prediction as the feature moves through its range. They accumulate these local effects and account for the presence of other features, making ALE plots more robust than PDPs when features are correlated.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#visualization-techniques/feature-visualization",
    "complexity_rating": 3,
    "computational_cost_rating": 2,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Exploring the effect of house size on price predictions in real estate models with correlated features.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"More complex to compute than PDP; still provides only average effects and can be harder to interpret for higher-order interactions beyond pairs.\"}]"
    ]
  },
  {
    "id": 18,
    "name": "Individual Conditional Expectation Plots (ICE)",
    "description": "ICE plots display the predicted output for individual instances as a function of a feature, with all other features held fixed for each instance. Each line on an ICE plot represents one instance's prediction trajectory as the feature of interest changes, revealing whether different instances are affected differently by that feature.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#visualization-techniques/feature-visualization",
    "complexity_rating": 2,
    "computational_cost_rating": 2,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Local"
      }
    ],
    "example_use_cases": [
      {
        "description": "Visualizing how customers' predicted spending changes with income in consumer behavior models.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Plots can become cluttered with many instances; does not inherently summarize the overall effect without visual inspection, and still assumes fixed other features.\"}]"
    ]
  },
  {
    "id": 19,
    "name": "Saliency Maps",
    "description": "Saliency maps highlight parts of an input (such as pixels in an image) that strongly influence the model's prediction. Typically computed via the gradient of the output with respect to the input, they produce a heatmap where brighter regions indicate greater influence on the model's decision.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#visualization-techniques/model-behavior-visualization",
    "complexity_rating": 3,
    "computational_cost_rating": 2,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Local"
      }
    ],
    "example_use_cases": [
      {
        "description": "Identifying regions contributing to tumor diagnosis in medical images.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "CNNs",
      "Vision Models"
    ],
    "limitations": [
      "[{\"description\": \"Often noisy and sensitive to small perturbations; highlights may not correspond to human-understandable features, and they only indicate local gradient, not causal importance.\"}]"
    ]
  },
  {
    "id": 20,
    "name": "Gradient-weighted Class Activation Mapping (Grad-CAM)",
    "description": "Grad-CAM produces a coarse localization map highlighting image regions important for a classification. It works by using the gradients of a target class flowing into the last convolutional layer of a CNN to weight the feature maps, and then projects these weights back to the image space as a heatmap of influential regions.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#visualization-techniques/model-behavior-visualization",
    "complexity_rating": 3,
    "computational_cost_rating": 2,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Local"
      }
    ],
    "example_use_cases": [
      {
        "description": "Visualizing parts of an image leading to a 'dog' classification in image recognition models.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "CNNs",
      "Vision Models"
    ],
    "limitations": [
      "[{\"description\": \"Requires access to internal feature maps; resolution is limited to coarse feature map size, and it is specific to CNN-based vision models with recognizable layers.\"}]"
    ]
  },
  {
    "id": 21,
    "name": "Occlusion Sensitivity",
    "description": "Occlusion sensitivity tests which parts of the input are important by occluding (masking or removing) them and seeing how the model's prediction changes. For example, portions of an image can be covered up in a sliding window fashion; if the model's confidence drops significantly when a certain region is occluded, that region was important for the prediction.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#visualization-techniques/model-behavior-visualization",
    "complexity_rating": 2,
    "computational_cost_rating": 4,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Local"
      }
    ],
    "example_use_cases": [
      {
        "description": "Understanding which words affect sentiment prediction by masking them in NLP models.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "CNNs",
      "Vision Models",
      "Text Models"
    ],
    "limitations": [
      "[{\"description\": \"Computationally expensive if many parts need to be occluded; choice of occlusion size can bias results, and it may not capture interactions if multiple parts jointly matter.\"}]"
    ]
  },
  {
    "id": 22,
    "name": "Attention Mechanisms in Neural Networks",
    "description": "Attention mechanisms allow models, especially in sequence tasks like NLP, to weight different parts of the input when making predictions. Visualizing or examining the learned attention weights can provide insight into which parts of the input the model found most relevant for a given output. By looking at these attention heatmaps, we can interpret which parts of the input were most influential for the model's decision.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#visualization-techniques/model-behavior-visualization",
    "complexity_rating": 2,
    "computational_cost_rating": 1,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Local"
      }
    ],
    "example_use_cases": [
      {
        "description": "Analyzing which words a transformer model focuses on during machine translation tasks.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Transformers",
      "Attention-based Models",
      "LLMs"
    ],
    "limitations": [
      "[{\"description\": \"Attention weights are not always strongly correlated with importance; focusing solely on attention can be misleading ('attention is not explanation' debate) and only applies to models with attention layers.\"}]"
    ]
  },
  {
    "id": 23,
    "name": "Factor Analysis",
    "description": "Factor analysis is a technique to discover latent variables (factors) that collectively explain the patterns observed in many features. It models each observed feature as a linear combination of a few underlying factors, thereby reducing dimensionality and potentially revealing the hidden structure or themes in the data.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#model-simplification/dimensionality-reduction",
    "complexity_rating": 3,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Discovering underlying factors in psychological survey data for social science research.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Assumes linear relationships and normality; results (factors) can be abstract and not directly interpretable, and requires deciding on number of factors and rotation method.\"}]"
    ]
  },
  {
    "id": 24,
    "name": "Principal Component Analysis (PCA)",
    "description": "PCA is a dimensionality reduction method that transforms the original features into a new set of orthogonal components (principal components) ordered by how much variance they explain in the data. By keeping only the top components, PCA provides a simpler representation of the data that captures the most important variance, which can aid visualization or reduce complexity.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#visualization-techniques/dimensionality-reduction-visualization",
    "complexity_rating": 2,
    "computational_cost_rating": 2,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Visualizing high-dimensional gene expression data in bioinformatics.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Principal components are linear combinations that may not correspond to clear real-world concepts; only captures linear variance and can be affected by scaling of features.\"}]"
    ]
  },
  {
    "id": 25,
    "name": "t-SNE",
    "description": "t-SNE (t-distributed Stochastic Neighbor Embedding) is a non-linear dimensionality reduction technique that visualizes high-dimensional data in 2D or 3D. It preserves local similarities, meaning points that are close in the original space remain close in the reduced space, making it effective for showing clusters and patterns that might not be visible with linear methods.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#visualization-techniques/dimensionality-reduction-visualization",
    "complexity_rating": 3,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Visualizing clusters in high-dimensional word embeddings.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Results can vary between runs; may distort global structure in favor of local clustering and requires tuning (perplexity, iterations) to avoid misleading patterns.\"}]"
    ]
  },
  {
    "id": 26,
    "name": "UMAP",
    "description": "UMAP is a non-linear dimensionality reduction technique, similar to t-SNE, aimed at visualizing high-dimensional data in 2D or 3D. It tends to preserve both local structure and some global structure of the data better than t-SNE, often producing more interpretable overall layouts of clusters.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#visualization-techniques/dimensionality-reduction-visualization",
    "complexity_rating": 3,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Visualizing patterns in user behavior data for marketing analysis.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Choice of parameters (neighbors, min distance) affects outcome; like t-SNE, it can sometimes be difficult to interpret distances in the reduced space in terms of original features.\"}]"
    ]
  },
  {
    "id": 27,
    "name": "Prototype and Criticism Models",
    "description": "This approach identifies representative examples (prototypes) of the dataset and outlier or hard-to-represent examples (criticisms). Prototypes capture the typical patterns the model or data exhibits, while criticisms highlight where those patterns fail to cover, giving insight into the diversity and exceptions in the data or model behavior.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#example-based-methods/prototype-and-criticism-methods",
    "complexity_rating": 4,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Selecting representative customer profiles for targeted marketing.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Determining prototypes/criticisms can be computationally complex for large datasets; results depend on the metric chosen and might not capture all important aspects of data variability.\"}]"
    ]
  },
  {
    "id": 28,
    "name": "Influence Functions",
    "description": "Influence functions estimate how a model's predictions would change if a particular training point were removed. By using a second-order Taylor approximation, they identify which training examples have the most influence (positive or negative) on a given prediction. This helps identify training data points that are most responsible for a particular prediction or for a model's behavior, which can be useful for debugging or understanding model decisions.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#example-based-methods/prototype-and-criticism-methods",
    "complexity_rating": 5,
    "computational_cost_rating": 5,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Debugging model predictions by identifying influential training data points.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Requires access to and differentiation through the training process; can be intractable for large models due to needing Hessian computations, and may not be accurate if model is highly non-convex.\"}]"
    ]
  },
  {
    "id": 29,
    "name": "Contrastive Explanation Method (CEM)",
    "description": "CEM explains model decisions by producing contrastive examples: it finds the minimal changes to an input that would switch the model's prediction. It outputs pertinent negatives (what could be removed from the input to change the prediction) and pertinent positives (what minimal additional features would be needed to reach the same decision) as a way to highlight what is essential in the input for that prediction.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#example-based-methods/counterfactual-explanations",
    "complexity_rating": 5,
    "computational_cost_rating": 4,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Local"
      }
    ],
    "example_use_cases": [
      {
        "description": "Explaining loan rejections by showing what changes would lead to approval.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Solving for pertinent positives/negatives requires iterative optimization per instance; results can be sensitive to parameter settings and might yield unrealistic contrastive inputs if constraints are not tight.\"}]"
    ]
  },
  {
    "id": 31,
    "name": "ANCHOR",
    "description": "ANCHOR generates precision if-then rules as explanations for individual predictions. It finds a minimal set of conditions (on input features) that 'anchor' the prediction, meaning that if those conditions are met, the model will almost always give the same prediction. These anchor rules are designed to be easily understood and highly predictive for that specific instance.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#rule-extraction/decision-rules",
    "complexity_rating": 3,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Local"
      }
    ],
    "example_use_cases": [
      {
        "description": "Generating rules to explain individual predictions in text classification.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Only provides explanations for individual predictions (local rules); may struggle with continuous features (usually requires discretization) and might not find an anchor if conditions are too strict.\"}]"
    ]
  },
  {
    "id": 32,
    "name": "RuleFit",
    "description": "RuleFit is a method that creates an interpretable model by combining linear terms with decision rules. It first extracts potential rules from ensemble trees, then builds a sparse linear model where those rules (binary conditions) and original features are used as predictors, with regularization to keep the model simple. The final model is a linear combination of a small set of rules and original features, balancing interpretability with predictive power.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#rule-extraction/decision-rules",
    "complexity_rating": 3,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Building interpretable models for predicting customer churn with rule-based explanations.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"The resulting model can still have many rules, complicating interpretability; performance may lag behind black-box models if too few rules are allowed for simplicity.\"}]"
    ]
  },
  {
    "id": 33,
    "name": "Monte Carlo Dropout",
    "description": "Monte Carlo Dropout uses dropout at prediction time to estimate model uncertainty. By running multiple forward passes with random dropout activated and observing the variation in outputs, it provides a distribution of predictions. A consistent prediction across runs indicates high confidence, while widely varying predictions indicate uncertainty.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#uncertainty-and-reliability/confidence-estimation",
    "complexity_rating": 3,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Estimating prediction uncertainty in medical diagnosis models.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Neural Networks with Dropout"
    ],
    "limitations": [
      "[{\"description\": \"Only captures model uncertainty, not data uncertainty; requires multiple forward passes and results depend on dropout rate, which must be same as training to be meaningful.\"}]"
    ]
  },
  {
    "id": 34,
    "name": "Out-of-DIstribution detector for Neural networks (ODIN)",
    "description": "ODIN is a technique to detect when an input to a neural network is something very different from what it was trained on (out-of-distribution). It works by scaling the model's outputs (using a temperature parameter) and adding a small perturbation to inputs to better separate the confidence scores for normal vs out-of-distribution examples. By examining the adjusted confidence score, ODIN can flag inputs that are likely far from the training distribution.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#uncertainty-and-reliability/outlier-detection",
    "complexity_rating": 4,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Detecting unusual inputs that a classifier wasn't trained on, like identifying when an image recognition model is shown a completely new object class.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Neural Networks"
    ],
    "limitations": [
      "[{\"description\": \"Requires tuning (temperature and perturbation magnitude) which may vary across different out-of-distribution types; may still struggle with adversarial examples or inputs very similar to training data.\"}]"
    ]
  },
  {
    "id": 35,
    "name": "Permutation Tests",
    "description": "Permutation tests assess the significance of an observed result (like model accuracy or feature importance) by comparing it to what would happen purely by chance. This is done by randomly shuffling labels or data many times and calculating the result each time, building a distribution of outcomes under the null hypothesis (no real relationship). If the actual result is far out in the tail of this distribution, it is deemed statistically significant.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#uncertainty-and-reliability/statistical-testing",
    "complexity_rating": 3,
    "computational_cost_rating": 4,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Validating that a feature is truly important by comparing its importance score to what would be expected from random noise.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Computationally expensive, especially for large datasets or models with long inference times; requires many permutations to get reliable p-values for strict significance thresholds.\"}]"
    ]
  },
  {
    "id": 37,
    "name": "Demographic Parity (Disparate Impact Assessment)",
    "description": "Demographic parity requires that prediction rates are the same across different demographic groups—for example, loan approval rates should be equal across racial categories. This metric helps identify algorithmic bias that could perpetuate or amplify social inequalities. By comparing outcome distributions across groups, it provides a straightforward way to detect potentially discriminatory patterns in model predictions.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#fairness-assessment/group-fairness-metrics",
    "complexity_rating": 1,
    "computational_cost_rating": 1,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Checking if a job candidate screening algorithm selects candidates from different gender groups at equal rates.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Can force ignoring relevant features that legitimately correlate with protected attributes; may reduce accuracy and can conflict with individual fairness notions.\"}]"
    ]
  },
  {
    "id": 38,
    "name": "Fairness-Aware Data Preprocessing",
    "description": "Fairness-aware preprocessing transforms training data to remove or reduce bias before model training. Techniques include reweighting examples, transforming features to obscure protected attributes, or generating synthetic data with more balanced characteristics. By addressing bias at the data level, these methods can improve fairness across multiple downstream models without requiring model-specific modifications.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#fairness-mitigation/data-preprocessing",
    "complexity_rating": 3,
    "computational_cost_rating": 2,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Rebalancing a historical hiring dataset to counter past discrimination before training a resume screening model.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"May reduce model accuracy; difficult to identify and remove all sources of bias, and some approaches can introduce new biases or distort important relationships.\"}]"
    ]
  },
  {
    "id": 39,
    "name": "Adversarial Debiasing",
    "description": "Adversarial debiasing trains a model to maximize prediction accuracy while simultaneously preventing an adversarial component from being able to predict sensitive attributes from the model's representations. By learning representations that are predictive of the target but not of protected characteristics, the model's decisions become less influenced by demographic factors, reducing discriminatory outcomes.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#fairness-mitigation/inprocessing",
    "complexity_rating": 4,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Training a resume screening model that makes hiring recommendations while ensuring representations don't enable prediction of applicants' gender or ethnicity.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Neural Networks"
    ],
    "limitations": [
      "[{\"description\": \"More complex to implement than standard models; may require careful tuning to balance task performance and fairness objectives, and effectiveness depends on adversary quality.\"}]"
    ]
  },
  {
    "id": 40,
    "name": "Counterfactual Fairness",
    "description": "Counterfactual fairness ensures that a model's prediction for an individual would remain the same in a counterfactual world where their sensitive attributes were different. It uses causal modeling to distinguish between legitimate and discriminatory influences of protected characteristics. This approach addresses fairness at an individual level, ensuring people aren't treated differently based solely on demographic factors that should be irrelevant to the decision.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#fairness-assessment/individual-fairness-metrics",
    "complexity_rating": 5,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Ensuring a credit scoring model gives the same result for a person regardless of what their race would have been, while still accounting for legitimate factors affected by systemic inequalities.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Requires specifying causal relationships, which can be subjective; may be mathematically impossible to satisfy along with other fairness definitions, and implementation is complex.\"}]"
    ]
  },
  {
    "id": 41,
    "name": "Fairness Constraints and Regularization",
    "description": "This approach incorporates fairness objectives directly into the model training process by adding constraints or regularization terms. The model learns to balance predictive performance with fairness criteria, such as minimizing disparate treatment across groups. By adjusting how heavily fairness is weighted against accuracy, developers can control the trade-off to meet application-specific needs.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#fairness-mitigation/inprocessing",
    "complexity_rating": 4,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Training a college admissions prediction model with a fairness constraint that penalizes the model if it gives systematically lower scores to certain demographic groups.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Requires careful tuning of fairness-accuracy trade-offs; constraints may lead to reduced performance, and optimization can be more complex than standard training.\"}]"
    ]
  },
  {
    "id": 42,
    "name": "Multi-calibration and Multi-accuracy",
    "description": "Multi-calibration ensures that a model's predictions are well-calibrated not just overall, but across all identifiable subgroups and intersections of groups. Similarly, multi-accuracy requires a model to be accurate across all subgroups. These approaches address the problem of models that perform well on average but fail for minority groups, ensuring reliable predictions for everyone regardless of their demographic characteristics.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#fairness-mitigation/postprocessing",
    "complexity_rating": 4,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Ensuring a medical risk prediction model has accurate confidence scores across all combinations of age, sex, and ethnicity groups, not just for the majority population.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"May require substantial data for reliable calibration across many subgroups; computational cost increases with number of groups considered, and improvement procedure can be complex.\"}]"
    ]
  },
  {
    "id": 43,
    "name": "Individual Fairness Metrics",
    "description": "Individual fairness metrics ensure that similar individuals receive similar outcomes, regardless of group membership. They define a distance function in the feature space and require that individuals who are close according to this distance receive similar predictions. This approach focuses on treating each person fairly rather than just achieving statistical parity between groups, addressing fairness at a more granular level.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#fairness-assessment/individual-fairness-metrics",
    "complexity_rating": 4,
    "computational_cost_rating": 2,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Ensuring that job candidates with similar qualifications receive similar scores from a resume screening algorithm, regardless of demographic factors.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Requires defining an appropriate similarity metric, which can be subjective; can be difficult to satisfy alongside group fairness metrics, and evaluation requires more computation.\"}]"
    ]
  },
  {
    "id": 44,
    "name": "Sensitivity Analysis for Fairness",
    "description": "Sensitivity analysis for fairness examines how model outputs change when sensitive attributes or their correlates are varied. By systematically altering certain inputs and observing prediction changes, it reveals if and how much protected characteristics influence decisions. This approach helps identify potential discrimination even in models that don't explicitly use sensitive attributes but might rely on correlated proxies.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#fairness-assessment/causal-analysis",
    "complexity_rating": 3,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Testing whether a lending model's decisions change significantly when only the applicant's zip code (which may correlate with race) is altered, while keeping all other factors constant.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"May require domain expertise to identify relevant proxies for sensitive attributes; can be computationally intensive for complex models, and choosing comparison points involves subjective judgment.\"}]"
    ]
  },
  {
    "id": 45,
    "name": "Synthetic Data Generation",
    "description": "Synthetic data generation creates artificial datasets that maintain the statistical properties and patterns of real data without containing actual information from real individuals. By using techniques like differential privacy or generative models, teams can develop, test, and share ML models without exposing sensitive information. This approach balances data utility with privacy protection, enabling collaboration while minimizing re-identification risks.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Privacy"
    ],
    "category_tags": "#data-protection/synthetic-data",
    "complexity_rating": 4,
    "computational_cost_rating": 4,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Creating realistic but synthetic electronic health records for developing and testing medical diagnosis algorithms without exposing real patient data.",
        "goal": "Privacy"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"May not capture all nuances of real data, potentially reducing model performance; generating high-quality synthetic data can be challenging, and some approaches may still leak information.\"}]"
    ]
  },
  {
    "id": 46,
    "name": "Federated Learning",
    "description": "Federated learning trains models across multiple devices or servers without exchanging the underlying data, only sharing model updates. Data remains on the local devices, preserving privacy while still enabling collaborative learning from distributed datasets. By keeping sensitive information local and only sharing model parameters or gradients, organizations can build effective models while respecting privacy boundaries and data sovereignty requirements.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Privacy"
    ],
    "category_tags": "#privacypreserving-training/distributed-learning",
    "complexity_rating": 4,
    "computational_cost_rating": 5,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Developing a smartphone keyboard prediction model by learning from users' typing patterns without their text ever leaving their devices.",
        "goal": "Privacy"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Communication overhead can be significant; heterogeneous client data may lead to training instability, and the approach still has potential privacy vulnerabilities to inference attacks.\"}]"
    ]
  },
  {
    "id": 47,
    "name": "Differential Privacy",
    "description": "Differential privacy adds carefully calibrated noise to data or model outputs to mathematically guarantee that individual data points cannot be identified. It provides a formal privacy framework with a tunable privacy budget (epsilon) that controls the privacy-utility trade-off. By quantifying and limiting information leakage, differential privacy enables robust privacy protection while still extracting valuable insights from sensitive data.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Privacy"
    ],
    "category_tags": "#privacypreserving-training/training-with-privacy-guarantees",
    "complexity_rating": 5,
    "computational_cost_rating": 3,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Adding privacy protection to a census data analysis model to ensure individual households cannot be identified while still obtaining accurate population statistics.",
        "goal": "Privacy"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Adds noise that reduces model accuracy; setting the privacy budget requires careful consideration, and strong privacy guarantees may significantly impact utility.\"}]"
    ]
  },
  {
    "id": 48,
    "name": "Homomorphic Encryption",
    "description": "Homomorphic encryption allows computation on encrypted data without decrypting it first, producing encrypted results that, when decrypted, match the results of performing the same operations on the plaintext. This enables secure outsourced computation where sensitive data remains encrypted throughout processing. By allowing ML operations on encrypted data, it provides strong privacy guarantees for applications involving highly sensitive information.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Privacy"
    ],
    "category_tags": "#privacypreserving-inference/encrypted-computation",
    "complexity_rating": 5,
    "computational_cost_rating": 5,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Enabling a cloud-based medical diagnosis service to process encrypted patient data and return encrypted results without ever seeing the actual medical information.",
        "goal": "Privacy"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Extremely computationally expensive, often orders of magnitude slower than unencrypted computation; limited operations supported efficiently, and implementation requires cryptographic expertise.\"}]"
    ]
  },
  {
    "id": 49,
    "name": "Prediction Intervals",
    "description": "Prediction intervals provide a range within which a future observation is likely to fall with a specified probability. Unlike single-point predictions, they quantify the uncertainty in a model's predictions, giving upper and lower bounds that account for both the inherent noise in the data and the model's uncertainty. This helps users understand how precise and reliable a prediction really is.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Reliability"
    ],
    "category_tags": "#uncertainty-and-reliability/confidence-estimation",
    "complexity_rating": 3,
    "computational_cost_rating": 3,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Providing realistic ranges for sales forecasts to help business planning under uncertainty.",
        "goal": "Reliability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Requires assumptions about error distribution; can be overconfident if model is miscalibrated, data distribution shifts, or assumptions are violated.\"}]"
    ]
  },
  {
    "id": 50,
    "name": "Quantile Regression",
    "description": "Quantile regression estimates different percentiles of the prediction's conditional distribution rather than just the mean. By modeling multiple quantiles (e.g., 10th, 50th, and 90th percentiles), it provides insights into the full range of possible outcomes and how features differently affect various parts of the outcome distribution. This helps understand prediction uncertainty and how the relationships might vary across different segments of the data.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Reliability"
    ],
    "category_tags": "#uncertainty-and-reliability/conditional-prediction",
    "complexity_rating": 3,
    "computational_cost_rating": 2,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Modeling how housing prices vary across different market segments, by estimating how factors affect low-end, median, and luxury properties differently.",
        "goal": "Reliability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Regression Models",
      "Quantile Regression Forests"
    ],
    "limitations": [
      "[{\"description\": \"Can be computationally intensive to fit multiple quantiles; may yield crossing quantiles without constraints, creating logically inconsistent prediction intervals.\"}]"
    ]
  },
  {
    "id": 51,
    "name": "Conformal Prediction",
    "description": "Conformal prediction creates prediction sets that contain the true outcome with a guaranteed coverage probability. Unlike traditional confidence intervals, conformal prediction makes minimal assumptions and works with any model type. It provides rigorous uncertainty quantification by using past prediction errors on similar examples to calibrate the size of prediction intervals, ensuring they have the specified coverage rate (e.g., 95% of intervals contain the true value).",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Reliability"
    ],
    "category_tags": "#uncertainty-and-reliability/distributionfree-prediction",
    "complexity_rating": 4,
    "computational_cost_rating": 2,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Creating prediction intervals for medical test results that have a provable 95% coverage rate, regardless of the underlying model complexity.",
        "goal": "Reliability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Intervals can be unnecessarily wide if nonconformity scores vary greatly across the data; requires a held-out calibration set which reduces data available for training.\"}]"
    ]
  },
  {
    "id": 52,
    "name": "Empirical Calibration",
    "description": "Empirical calibration adjusts a model's predicted probabilities to match observed frequencies. For example, if events predicted with 80% confidence only occur 60% of the time, calibration would correct this overconfidence. Common techniques include Platt scaling and isotonic regression, which learn transformations that map the model's raw scores to well-calibrated probabilities, improving the reliability of confidence measures for downstream decisions.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Reliability"
    ],
    "category_tags": "#uncertainty-and-reliability/probability-calibration",
    "complexity_rating": 2,
    "computational_cost_rating": 2,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Adjusting a credit default prediction model's probabilities to ensure that loan applicants with a predicted 30% default risk actually default 30% of the time, improving decision-making.",
        "goal": "Reliability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Requires held-out calibration data; calibration can degrade over time if data distribution shifts, and might sacrifice discrimination power for calibration in some cases.\"}]"
    ]
  },
  {
    "id": 53,
    "name": "Temperature Scaling",
    "description": "Temperature scaling is a simple but effective calibration method for neural networks that divides the logits (pre-softmax outputs) by a single scalar parameter called temperature. This parameter is optimized on a validation set to minimize calibration error. Higher temperatures smooth out confidence, making the model less overconfident. It preserves the model's accuracy while improving its calibration, ensuring probability estimates better reflect true likelihoods.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Reliability"
    ],
    "category_tags": "#uncertainty-and-reliability/probability-calibration",
    "complexity_rating": 1,
    "computational_cost_rating": 1,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Adjusting a deep learning image classifier's confidence scores to be realistic, ensuring that when it's 90% confident, it's right 90% of the time.",
        "goal": "Reliability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Neural Networks",
      "Classification Models"
    ],
    "limitations": [
      "[{\"description\": \"Only addresses calibration at the dataset level; doesn't fix miscalibration that varies across subgroups or feature values, and does not improve the rank ordering of predictions.\"}]"
    ]
  },
  {
    "id": 54,
    "name": "Deep Ensembles",
    "description": "Deep ensembles combine predictions from multiple neural networks trained independently with different random initializations. By capturing model uncertainty through the diversity of the ensemble's predictions, they provide more reliable uncertainty estimates and better out-of-distribution detection than single models. The disagreement between ensemble members naturally indicates prediction uncertainty, improving both accuracy and calibration.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Reliability"
    ],
    "category_tags": "#uncertainty-and-reliability/ensemble-methods",
    "complexity_rating": 3,
    "computational_cost_rating": 5,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Improving self-driving car safety by using multiple neural networks to detect obstacles, where disagreement between models signals uncertainty and triggers extra caution.",
        "goal": "Reliability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Neural Networks"
    ],
    "limitations": [
      "[{\"description\": \"Computationally expensive to train and deploy multiple complete models; may still provide overconfident predictions for inputs far from the training distribution.\"}]"
    ]
  },
  {
    "id": 55,
    "name": "Bootstrapping",
    "description": "Bootstrapping estimates uncertainty by resampling data with replacement many times, training a model on each sample, and analyzing the variation in predictions. This approach provides confidence intervals and stability measures without making strong statistical assumptions. By showing how predictions change with different data samples, it reveals how sensitive the model is to the specific training examples it sees.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Reliability"
    ],
    "category_tags": "#uncertainty-and-reliability/resampling-methods",
    "complexity_rating": 3,
    "computational_cost_rating": 4,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Estimating uncertainty in financial risk models by resampling historical data to understand how predictions might vary under different historical scenarios.",
        "goal": "Reliability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Computationally expensive to train multiple models; does not account for uncertainty in model structure or for systematically missing data patterns.\"}]"
    ]
  },
  {
    "id": 56,
    "name": "Jackknife Resampling",
    "description": "Jackknife resampling assesses model stability by systematically leaving out one (or a few) data points at a time and retraining the model. This approach reveals how individual points influence results and provides an estimate of the standard error. By examining the distribution of predictions across these leave-one-out models, it identifies unusually influential points and characterizes prediction uncertainty.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Reliability"
    ],
    "category_tags": "#uncertainty-and-reliability/resampling-methods",
    "complexity_rating": 3,
    "computational_cost_rating": 5,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Evaluating how removing individual countries from a global climate model affects predictions, to identify which regions have outsized influence on the results.",
        "goal": "Reliability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Extremely computationally intensive for large datasets, as it requires training n models for n data points; may underestimate uncertainty compared to other methods.\"}]"
    ]
  },
  {
    "id": 57,
    "name": "Cross-validation",
    "description": "Cross-validation evaluates model performance and stability by partitioning data into multiple subsets. The model is trained and tested repeatedly on different train-test splits, revealing how performance varies across different subsamples of data. This provides a realistic assessment of how well the model will generalize to new data and helps quantify prediction uncertainty, making it a fundamental technique for reliable model evaluation.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Reliability"
    ],
    "category_tags": "#performance-assessment/validation-methods",
    "complexity_rating": 2,
    "computational_cost_rating": 3,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Using 10-fold cross-validation to estimate a healthcare prediction model's true accuracy and assess if performance is consistent across different patient subgroups.",
        "goal": "Reliability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Time-consuming for large datasets or complex models; standard cross-validation can give optimistic estimates if there are dependencies in the data (e.g., time series).\"}]"
    ]
  },
  {
    "id": 58,
    "name": "Statistical Hypothesis Testing",
    "description": "Statistical hypothesis testing systematically evaluates whether observed effects or differences could have occurred by chance. By calculating test statistics and p-values, it determines if results are statistically significant given a null hypothesis. This approach brings rigor to model evaluation and comparison, helping to distinguish real patterns from random fluctuations when assessing model performance or feature importance.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Reliability"
    ],
    "category_tags": "#performance-assessment/significance-testing",
    "complexity_rating": 3,
    "computational_cost_rating": 2,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Determining if one machine learning model significantly outperforms another, or if the observed performance difference could be due to chance.",
        "goal": "Reliability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Vulnerable to p-hacking and multiple testing problems; significance doesn't always imply practical importance, and test validity depends on distribution assumptions.\"}]"
    ]
  },
  {
    "id": 59,
    "name": "Area Under Precision-Recall Curve (AUPRC)",
    "description": "AUPRC measures model performance by plotting precision against recall at various classification thresholds and calculating the area under the resulting curve. Unlike accuracy or AUC-ROC, it's particularly valuable for imbalanced datasets where the minority class is of primary interest. By focusing on the trade-off between precision and recall, it provides a more informative assessment for use cases where false positives and false negatives have different costs.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Reliability"
    ],
    "category_tags": "#performance-assessment/metric-selection",
    "complexity_rating": 2,
    "computational_cost_rating": 2,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Evaluating fraud detection models where genuine transactions far outnumber fraudulent ones, to ensure fraud is caught without overwhelming reviewers with false alarms.",
        "goal": "Reliability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"More sensitive to class distribution than ROC curves; comparing models across datasets with different class balances can be misleading.\"}]"
    ]
  },
  {
    "id": 60,
    "name": "Precision Metrics for High-Risk Domains",
    "description": "In high-risk domains, specialized metrics focus on worst-case performance and extreme error cases rather than averages. These include metrics like maximum error, 99th percentile error, and failure rate above critical thresholds. By explicitly measuring performance in the most challenging situations, these metrics ensure models meet safety requirements and help identify potentially catastrophic failure modes.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Reliability"
    ],
    "category_tags": "#performance-assessment/edge-case-evaluation",
    "complexity_rating": 3,
    "computational_cost_rating": 3,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Evaluating an autonomous vehicle's detection system by measuring its worst-case performance in challenging visibility conditions, rather than average-case performance.",
        "goal": "Reliability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"May require more test cases and data to accurately estimate tail performance; optimizing for extreme cases can sometimes harm average performance.\"}]"
    ]
  },
  {
    "id": 61,
    "name": "Internal Review Boards",
    "description": "Internal review boards evaluate ML projects for ethical and safety concerns before development or deployment. Comprised of cross-functional experts (technical, legal, ethics, domain specialists), they review use cases, potential harms, mitigation strategies, and monitoring plans. By formalizing ethical review processes, they help organizations identify risks early and ensure responsible AI development practices.",
    "model_dependency": "Organizational",
    "assurance_goals": [
      "Safety"
    ],
    "category_tags": "#governance-mechanisms/review-processes",
    "complexity_rating": 4,
    "computational_cost_rating": 1,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Reviewing a proposed criminal risk assessment tool to evaluate potential discriminatory impacts and privacy implications before development begins.",
        "goal": "Safety"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Can slow development timelines; effectiveness depends on board composition and authority, and organizations may face pressure to approve revenue-generating projects.\"}]"
    ]
  },
  {
    "id": 62,
    "name": "Red Teaming",
    "description": "Red teaming involves dedicated adversarial testing of ML systems by specialists who try to find flaws, vulnerabilities, harmful outputs, or ways to circumvent safety measures. Drawing on security practices, red teams probe systems from multiple angles, including prompt engineering, adversarial examples, and edge case testing. This approach reveals non-obvious risks before deployment and helps build more robust, safer AI systems.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Safety"
    ],
    "category_tags": "#testing-methods/adversarial-testing",
    "complexity_rating": 4,
    "computational_cost_rating": 3,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Having a specialized team attempt to make a content moderation AI generate harmful outputs by using creative prompting techniques.",
        "goal": "Safety"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Requires specialized expertise and significant resources; can only find issues that testers think to look for, and systems may remain vulnerable to novel attack types.\"}]"
    ]
  },
  {
    "id": 63,
    "name": "Anomaly Detection",
    "description": "Anomaly detection identifies unusual behaviors, inputs, or outputs that deviate significantly from normal patterns. Applied to ML systems, it can flag unexpected model predictions, suspicious inputs, or drift in behavior. By continuously monitoring for anomalies in production, organizations can catch potential issues early, investigate causes, and prevent harm from system misuse or malfunction.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Safety"
    ],
    "category_tags": "#monitoring-methods/runtime-monitoring",
    "complexity_rating": 3,
    "computational_cost_rating": 3,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Detecting unusual patterns of API calls to a machine translation service that might indicate attempts to extract harmful outputs or attack the model.",
        "goal": "Safety"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Setting appropriate thresholds is challenging; may generate false alarms in legitimate edge cases, and novel anomalies might not match patterns the system is trained to detect.\"}]"
    ]
  },
  {
    "id": 64,
    "name": "Human-in-the-Loop Safeguards",
    "description": "Human-in-the-loop safeguards integrate human oversight into model operations, requiring human review of high-risk or uncertain predictions before actions are taken. This approach combines model efficiency with human judgment for sensitive decisions. By designating appropriate intervention points and routing challenging cases to human experts, organizations can better manage the risks of automated decisions while still benefiting from ML capabilities.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Safety"
    ],
    "category_tags": "#operational-procedures/human-oversight",
    "complexity_rating": 2,
    "computational_cost_rating": 2,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Requiring human moderator approval before taking down content that an AI system has flagged for potential policy violations.",
        "goal": "Safety"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Scales poorly with high request volumes; introduces latency into the decision process, and humans may experience fatigue or defer too easily to automation.\"}]"
    ]
  },
  {
    "id": 65,
    "name": "Confidence Thresholding",
    "description": "Confidence thresholding routes predictions to different handling paths based on the model's confidence level. High-confidence predictions proceed automatically, while low-confidence cases receive extra scrutiny, human review, or fallback handling. By establishing appropriate thresholds for different risk levels, organizations can balance automation benefits with prudent safeguards, ensuring greater oversight where uncertainty is high.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Safety"
    ],
    "category_tags": "#operational-procedures/filtering-pipeline",
    "complexity_rating": 2,
    "computational_cost_rating": 1,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Only allowing a medical diagnosis system to make recommendations automatically when its confidence exceeds 95%, routing less certain cases to human physicians.",
        "goal": "Safety"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Many models have poorly calibrated confidence scores; threshold selection can be challenging, and some risky predictions may still have high confidence.\"}]"
    ]
  },
  {
    "id": 66,
    "name": "Runtime Monitoring and Circuit Breakers",
    "description": "Runtime monitoring tracks key system metrics and prediction patterns in production, with automated circuit breakers that can throttle, disable, or revert ML systems when anomalies exceed thresholds. This approach provides real-time protection against unexpected behavior. By continuously monitoring inputs, outputs, and system health, organizations can quickly detect and respond to potential issues before they cause significant harm.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Safety"
    ],
    "category_tags": "#monitoring-methods/runtime-monitoring",
    "complexity_rating": 3,
    "computational_cost_rating": 2,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Automatically disabling an automated trading system if it starts making a volume of trades that exceeds historical patterns by a large margin.",
        "goal": "Safety"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Setting appropriate thresholds requires careful calibration; false alarms can disrupt service unnecessarily, and some harmful behaviors may still fall within monitored metrics ranges.\"}]"
    ]
  },
  {
    "id": 67,
    "name": "Model Cards",
    "description": "Model cards are standardized documentation templates that provide essential information about ML models, including their intended uses, performance metrics across different conditions and demographic groups, training data characteristics, and known limitations. By creating transparency about a model's behavior and appropriate contexts, they help prevent misuse and enable users to make informed decisions about when and how to apply the model.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Transparency"
    ],
    "category_tags": "#documentation-standards/model-governance",
    "complexity_rating": 2,
    "computational_cost_rating": 1,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Creating comprehensive documentation for a facial recognition API that clearly describes performance differences across skin tones and lighting conditions.",
        "goal": "Transparency"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Creating thorough model cards requires significant effort; information may become outdated as models are updated, and some organizations may provide incomplete information.\"}]"
    ]
  },
  {
    "id": 68,
    "name": "Datasheets for Datasets",
    "description": "Datasheets for datasets document a dataset's creation, composition, intended uses, and maintenance. They include information about collection methods, preprocessing steps, recommended uses, potential biases, and legal/ethical considerations. By providing this context, datasheets improve transparency, help users make informed decisions about dataset suitability, and encourage dataset creators to reflect on responsible practices throughout the data lifecycle.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Transparency"
    ],
    "category_tags": "#documentation-standards/model-governance",
    "complexity_rating": 2,
    "computational_cost_rating": 1,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Creating comprehensive documentation for a public facial image dataset, detailing consent procedures, demographic representation, and appropriate use guidelines.",
        "goal": "Transparency"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Requires time and effort to create and maintain; information may become outdated if the dataset evolves, and there's no enforced standard for completeness.\"}]"
    ]
  },
  {
    "id": 69,
    "name": "System Documentation Templates",
    "description": "System documentation templates provide standardized frameworks for describing ML systems beyond just models and datasets. They capture information about infrastructure, deployment environments, monitoring systems, failure modes, and maintenance procedures. By ensuring comprehensive documentation of the entire ML pipeline, they support better governance, reproducibility, and safety, serving both technical and non-technical stakeholders.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Transparency"
    ],
    "category_tags": "#documentation-standards/model-governance",
    "complexity_rating": 3,
    "computational_cost_rating": 1,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Documenting an automated trading system's components, monitoring protocols, and emergency shutdown procedures to support operational safety and regulatory compliance.",
        "goal": "Transparency"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Maintaining comprehensive documentation can be time-consuming; different stakeholders may require different levels of detail, and templates may not fit all types of ML systems equally well.\"}]"
    ]
  },
  {
    "id": 70,
    "name": "ML System Lineage",
    "description": "ML system lineage tracks the complete history of models, datasets, and experiments through a system's lifecycle. It records which datasets were used to train each model version, what hyperparameters were set, who approved changes, and when models were deployed. By maintaining this audit trail, organizations can reproduce past results, track sources of performance issues, and demonstrate regulatory compliance when needed.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Transparency"
    ],
    "category_tags": "#documentation-standards/versioning-and-provenance",
    "complexity_rating": 3,
    "computational_cost_rating": 2,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Maintaining complete records of model versions and datasets for a medical diagnosis system to support regulatory audits and trace the origin of any prediction issues.",
        "goal": "Transparency"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Implementing comprehensive lineage tracking requires dedicated infrastructure; can generate large volumes of metadata, and requires discipline from all team members to maintain.\"}]"
    ]
  },
  {
    "id": 71,
    "name": "Automated Documentation Generation",
    "description": "Automated documentation generation extracts information directly from code, models, and data pipelines to create and maintain up-to-date documentation. It can capture model architectures, data schemas, feature importance, performance metrics, and lineage information without manual writing. By reducing the burden of documentation maintenance, it helps teams keep comprehensive records that remain accurate as systems evolve.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Transparency"
    ],
    "category_tags": "#documentation-standards/documentation-automation",
    "complexity_rating": 3,
    "computational_cost_rating": 2,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Automatically generating model cards each time a new model version is trained, with updated performance metrics and data statistics.",
        "goal": "Transparency"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"May miss context and insights that human documentation would include; quality depends on instrumentation comprehensiveness, and unstructured information is harder to capture.\"}]"
    ]
  },
  {
    "id": 72,
    "name": "Model Distillation",
    "description": "Model distillation compresses a large, complex model (the teacher) into a smaller, simpler model (the student) that approximates the original's behavior. The student model learns from the teacher's outputs rather than the raw data. This technique makes models more interpretable, deployable, and efficient while preserving most of the original performance. It helps balance the benefits of complex models with the practical requirements of responsible deployment.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Transparency"
    ],
    "category_tags": "#model-simplification/knowledge-distillation",
    "complexity_rating": 3,
    "computational_cost_rating": 4,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Compressing a large computer vision model with billions of parameters into a smaller model that can run on mobile devices while being easier to inspect.",
        "goal": "Transparency"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Neural Networks"
    ],
    "limitations": [
      "[{\"description\": \"Student models typically lose some performance compared to teacher models; the distillation process may still produce black-box models if not combined with interpretable architectures.\"}]"
    ]
  },
  {
    "id": 73,
    "name": "Model Extraction",
    "description": "Model extraction creates a simpler, interpretable model (like a decision tree) that approximates a complex black-box model's behavior. Unlike distillation which transfers knowledge during training, extraction works with already-trained models by analyzing their inputs and outputs. This technique helps understand what patterns a black-box model has learned and provides explanations that stakeholders can understand without technical expertise.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Transparency"
    ],
    "category_tags": "#model-simplification/posthoc-approximation",
    "complexity_rating": 3,
    "computational_cost_rating": 3,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Converting a complex neural network credit score model into a set of human-readable rules to explain to regulators and applicants how decisions are made.",
        "goal": "Transparency"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Extracted models may not faithfully represent the original if it's highly complex; accuracy and fidelity trade off against simplicity, and training data for extraction may not be diverse enough.\"}]"
    ]
  },
  {
    "id": 74,
    "name": "Feature Importance Ranking",
    "description": "Feature importance ranking identifies and orders the most influential features in a model's predictions, typically using techniques like permutation importance, SHAP values, or built-in model metrics. By quantifying each feature's impact, it provides transparency into what factors drive the model's decisions. This helps stakeholders understand the model's focus and can reveal whether it relies on reasonable factors or potentially problematic ones.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Transparency"
    ],
    "category_tags": "#feature-analysis/importance-ranking",
    "complexity_rating": 2,
    "computational_cost_rating": 2,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Revealing that customer purchase history and product views are the top features in an e-commerce recommendation system, rather than demographic information.",
        "goal": "Transparency"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Different importance metrics can yield conflicting rankings; importance doesn't reveal feature interactions, and global rankings may not explain individual predictions.\"}]"
    ]
  },
  {
    "id": 75,
    "name": "Monotonicity Constraints",
    "description": "Monotonicity constraints ensure that a model's predictions always increase (or decrease) as a specific feature increases, enforcing a consistent directional relationship. For instance, income can only positively affect loan approval chances. This technique makes models more intuitive and transparent, as users can understand how changing a particular input will affect the output, without unexpected reversals or non-linear behaviors.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Transparency"
    ],
    "category_tags": "#interpretable-design/constraint-based-models",
    "complexity_rating": 3,
    "computational_cost_rating": 2,
    "attributes": [],
    "example_use_cases": [
      {
        "description": "Ensuring a credit scoring model always treats higher income as a positive factor (or at least never as a negative factor) for creditworthiness assessment.",
        "goal": "Transparency"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"May reduce model accuracy if true relationships are non-monotonic; requires domain knowledge to identify which features should be monotonic, and increases training complexity.\"}]"
    ]
  },
  {
    "id": 76,
    "name": "Decision Trees and Rule Lists",
    "description": "Decision trees and rule lists create models that make predictions through a series of interpretable if-then rules arranged in a flowchart-like structure. Each decision point is based on a clear condition about a feature, and the path to any prediction can be traced and explained in natural language. These inherently transparent models allow stakeholders to understand exactly how inputs lead to outputs.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Transparency"
    ],
    "category_tags": "#interpretable-design/inherently-interpretable-models",
    "complexity_rating": 2,
    "computational_cost_rating": 1,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Building a loan approval system using a decision tree with clear rules based on income, credit history, and debt ratio that can be explained to applicants.",
        "goal": "Transparency"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Decision Trees",
      "Rule-based Models"
    ],
    "limitations": [
      "[{\"description\": \"Often less accurate than complex models for difficult problems; deep trees can still be hard to interpret, and training can be unstable with small data changes.\"}]"
    ]
  },
  {
    "id": 77,
    "name": "Linear/Logistic Models with Few Features",
    "description": "Linear and logistic regression models with a small number of carefully selected features provide transparent predictions through simple, weighted combinations of inputs. Each coefficient represents a feature's impact, and the entire model can be expressed as a single equation. By prioritizing simplicity and selecting the most important features, these models balance interpretability with adequate performance for many applications.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Transparency"
    ],
    "category_tags": "#interpretable-design/inherently-interpretable-models",
    "complexity_rating": 1,
    "computational_cost_rating": 1,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Using a simple logistic regression with 5-10 key features for a medical screening test, where clinicians need to understand and explain the factors behind each risk assessment.",
        "goal": "Transparency"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Linear Regression",
      "Logistic Regression"
    ],
    "limitations": [
      "[{\"description\": \"May miss complex nonlinear relationships or interactions; predictive performance often lower than more complex models for difficult problems.\"}]"
    ]
  },
  {
    "id": 78,
    "name": "Generalized Additive Models (GAMs)",
    "description": "GAMs extend linear models by allowing flexible, nonlinear relationships between individual features and the target while maintaining the additive structure that keeps them interpretable. Each feature's effect is modeled separately as a smooth function, visualized as a curve showing how the feature influences predictions across its range. This approach balances the transparency of linear models with the ability to capture more complex patterns.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Transparency"
    ],
    "category_tags": "#interpretable-design/inherently-interpretable-models",
    "complexity_rating": 3,
    "computational_cost_rating": 2,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Predicting hospital readmission risk with a GAM that shows how the risk varies nonlinearly with patient age while still keeping the model transparent enough for clinical use.",
        "goal": "Transparency"
      }
    ],
    "resources": [],
    "applicable_models": [
      "GAMs"
    ],
    "limitations": [
      "[{\"description\": \"Cannot capture complex interactions between features unless explicitly modeled; setup requires deciding which features need nonlinear treatment, and fitting process is more complex than linear models.\"}]"
    ]
  },
  {
    "id": 79,
    "name": "Naive Bayes and Probabilistic Models",
    "description": "Naive Bayes and related probabilistic models make predictions based on Bayes' theorem and conditional probabilities, with an assumption that features are conditionally independent. Their transparency comes from the straightforward probabilistic reasoning, where each feature's contribution to the prediction is clearly defined as a likelihood. By explicitly modeling the probability of outcomes given evidence, these models provide intuitive explanations for how inputs affect predictions.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Transparency"
    ],
    "category_tags": "#interpretable-design/inherently-interpretable-models",
    "complexity_rating": 2,
    "computational_cost_rating": 1,
    "attributes": [
      {
        "type": "Explanatory Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Using a Naive Bayes classifier for email spam detection that can explain its decisions by showing which words increased the probability of the spam classification.",
        "goal": "Transparency"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Naive Bayes",
      "Probabilistic Classifiers"
    ],
    "limitations": [
      "[{\"description\": \"Independence assumption often violated in real data, leading to miscalibrated probabilities; performance typically lower than more complex models for tasks with intricate patterns.\"}]"
    ]
  },
  {
    "id": 80,
    "name": "Variable Importance in Random Forests (MDA, MDG)",
    "description": "Calculates feature importance by measuring the Mean Decrease Accuracy or Mean Decrease Gini when a feature is excluded from Random Forest models.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#feature-analysis/importance-and-attribution",
    "complexity_rating": 2,
    "computational_cost_rating": 2,
    "attributes": [
      {
        "type": "Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Identifying key predictors in a Random Forest model for credit scoring.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Random Forests"
    ],
    "limitations": [
      "[{\"description\": \"Permutation importance (MDA) shares limitations with correlated features; Gini importance (MDG) biases towards continuous or high-cardinality features.\"}]"
    ]
  },
  {
    "id": 81,
    "name": "Bayesian Networks",
    "description": "Probabilistic graphical models representing variables and their conditional dependencies for causal reasoning.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#example-based-methods/causal-analysis",
    "complexity_rating": 4,
    "computational_cost_rating": 4,
    "attributes": [
      {
        "type": "Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Modeling causal relationships in gene regulatory networks.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Bayesian Networks",
      "Probabilistic Graphical Models"
    ],
    "limitations": [
      "[{\"description\": \"Learning the network structure from data is NP-hard for many variables; causal conclusions require correct model specification and may be invalid if important variables are omitted.\"}]"
    ]
  },
  {
    "id": 82,
    "name": "Fairness Metrics (e.g., Equalized Odds, Demographic Parity)",
    "description": "Evaluates models for fairness by measuring disparities in predictions across different demographic groups.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#fairness-explanations/bias-detection-and-mitigation",
    "complexity_rating": 2,
    "computational_cost_rating": 1,
    "attributes": [
      {
        "type": "Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Ensuring a hiring model does not discriminate based on gender or ethnicity.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Each metric addresses a specific notion of fairness and may conflict with others; they require true outcome labels for evaluation and do not directly tell how to fix bias.\"}]"
    ]
  },
  {
    "id": 83,
    "name": "Model Pruning",
    "description": "Simplifies neural networks by removing less important weights or neurons, reducing complexity while retaining performance.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#model-simplification/model-pruning",
    "complexity_rating": 3,
    "computational_cost_rating": 2,
    "attributes": [
      {
        "type": "Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Reducing model size for deployment on mobile devices without significant loss in accuracy.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Neural Networks"
    ],
    "limitations": [
      "[{\"description\": \"Over-pruning can significantly reduce accuracy; finding the right pruning threshold is trial-and-error, and pruned models may still be complex to interpret if remaining structure is not simple.\"}]"
    ]
  },
  {
    "id": 84,
    "name": "Knowledge Distillation",
    "description": "Trains a simpler 'student' model to replicate the behavior of a complex 'teacher' model, resulting in a more interpretable model.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#model-simplification/model-distillation",
    "complexity_rating": 3,
    "computational_cost_rating": 4,
    "attributes": [
      {
        "type": "Scope",
        "value": "Global"
      }
    ],
    "example_use_cases": [
      {
        "description": "Simplifying a deep neural network for faster inference in real-time applications.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Student model performance depends on teacher quality and training technique; distilled model might still be a black box (though simpler) and requires additional training data or time.\"}]"
    ]
  },
  {
    "id": 85,
    "name": "Attention Visualisation in Transformers",
    "description": "Visualizes attention weights in transformer-based models to show how the model focuses on different input parts during prediction.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#visualization-techniques/model-behavior-visualization",
    "complexity_rating": 2,
    "computational_cost_rating": 1,
    "attributes": [
      {
        "type": "Scope",
        "value": "Local"
      }
    ],
    "example_use_cases": [
      {
        "description": "Understanding which words a transformer model focuses on during machine translation tasks.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Transformers",
      "LLMs"
    ],
    "limitations": [
      "[{\"description\": \"Similar to other attention interpretations: not always clear if high attention means importance; only applicable to transformer-based models and doesn't explain the model's reasoning beyond attention weights.\"}]"
    ]
  },
  {
    "id": 86,
    "name": "Neuron Activation Analysis",
    "description": "Analyzes activation patterns of neurons in large language models (LLMs) to interpret their roles and the concepts they represent.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#feature-analysis/importance-and-attribution",
    "complexity_rating": 5,
    "computational_cost_rating": 4,
    "attributes": [
      {
        "type": "Scope",
        "value": "Global"
      },
      {
        "type": "Scope",
        "value": "Local"
      }
    ],
    "example_use_cases": [
      {
        "description": "Identifying neurons responsible for syntax or semantics in language models.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "LLMs",
      "Neural Networks"
    ],
    "limitations": [
      "[{\"description\": \"Interpreting individual neurons requires analyzing large numbers of activations; insights are often qualitative, and important behavior may be distributed across many neurons rather than single ones.\"}]"
    ]
  },
  {
    "id": 87,
    "name": "Prompt Sensitivity Analysis",
    "description": "Studies how variations in input prompts affect LLM outputs to understand model behavior and sensitivity.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#example-based-methods/prototype-and-criticism-methods",
    "complexity_rating": 3,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Scope",
        "value": "Local"
      }
    ],
    "example_use_cases": [
      {
        "description": "Evaluating how different phrasings influence an LLM's answers in question-answering tasks.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "LLMs"
    ],
    "limitations": [
      "[{\"description\": \"Only surfaces sensitivity to tested prompt variations; may not cover all aspects of model behavior, and systematic prompt generation can be time-consuming or incomplete.\"}]"
    ]
  },
  {
    "id": 88,
    "name": "Causal Mediation Analysis in Language Models",
    "description": "Investigates causal relationships within LLMs by assessing how interventions on specific components affect outputs.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#example-based-methods/causal-analysis",
    "complexity_rating": 5,
    "computational_cost_rating": 4,
    "attributes": [
      {
        "type": "Scope",
        "value": "Global"
      },
      {
        "type": "Scope",
        "value": "Local"
      }
    ],
    "example_use_cases": [
      {
        "description": "Understanding how adjusting embeddings changes model responses in language generation tasks.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "LLMs"
    ],
    "limitations": [
      "[{\"description\": \"Requires defining interventions on internal components, which needs expert knowledge of model architecture; results depend on correctness of causal assumptions and can be challenging to interpret conclusively.\"}]"
    ]
  },
  {
    "id": 89,
    "name": "Feature Attribution with Integrated Gradients in NLP",
    "description": "Applies Integrated Gradients to attribute importance of input tokens in LLMs for specific predictions, often producing visualizations.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#feature-analysis/importance-and-attribution",
    "complexity_rating": 4,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Scope",
        "value": "Local"
      }
    ],
    "example_use_cases": [
      {
        "description": "Identifying words influencing text sentiment classification or topic modeling.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "LLMs",
      "NLP Models"
    ],
    "limitations": [
      "[{\"description\": \"Long text inputs mean integrating over many steps which is slow; attributions can be diffuse across many tokens, and choosing a neutral baseline (e.g., empty or padding text) is non-trivial.\"}]"
    ]
  },
  {
    "id": 90,
    "name": "Concept Activation Vectors (CAVs)",
    "description": "Represents human-understandable concepts as vectors in the model's latent space to analyze their influence on predictions.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#feature-analysis/importance-and-attribution",
    "complexity_rating": 4,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Scope",
        "value": "Global"
      },
      {
        "type": "Scope",
        "value": "Local"
      }
    ],
    "example_use_cases": [
      {
        "description": "Assessing how concepts like 'negativity' affect language model outputs.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Relies on having clearly defined concept examples; concept directions might not exist clearly in the model's internal space, and one must choose which layer to examine, affecting results.\"}]"
    ]
  },
  {
    "id": 91,
    "name": "In-Context Learning Analysis",
    "description": "Examines how LLMs learn from examples provided in the input prompt, revealing capacity for few-shot learning.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Explainability"
    ],
    "category_tags": "#example-based-methods/prototype-and-criticism-methods",
    "complexity_rating": 4,
    "computational_cost_rating": 2,
    "attributes": [
      {
        "type": "Scope",
        "value": "Local"
      }
    ],
    "example_use_cases": [
      {
        "description": "Analyzing the effect of examples on an LLM's ability to perform a new task like translation.",
        "goal": "Explainability"
      }
    ],
    "resources": [],
    "applicable_models": [
      "LLMs"
    ],
    "limitations": [
      "[{\"description\": \"Observational analysis without guaranteed causal insight; any findings can be specific to the tested tasks or prompts, making general conclusions about model behavior difficult.\"}]"
    ]
  },
  {
    "id": 92,
    "name": "Reweighing",
    "description": "Assigns weights to instances in the training data to ensure different groups are equally represented in all labels.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#preprocessing-techniques/data-transformation",
    "complexity_rating": 2,
    "computational_cost_rating": 1,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Balancing gender representation in credit approval datasets before training a classifier.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Does not remove bias present in features; simply changing weights can lead to higher variance if some groups are underrepresented, and it assumes labels are unbiased which might not hold.\"}]"
    ]
  },
  {
    "id": 93,
    "name": "Disparate Impact Remover",
    "description": "Edits feature values to reduce dependence between features and protected attributes, aiming to mitigate disparate impact.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#preprocessing-techniques/data-transformation",
    "complexity_rating": 3,
    "computational_cost_rating": 2,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Adjusting salary features to reduce gender bias in income prediction models.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Altering features could reduce model accuracy if important information is removed; addresses only measured attributes and might not eliminate bias through proxies.\"}]"
    ]
  },
  {
    "id": 94,
    "name": "Learning Fair Representations",
    "description": "Learns latent representations that encode data well but obfuscate information about protected attributes.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#inprocessing-techniques/fair-representation-learning",
    "complexity_rating": 4,
    "computational_cost_rating": 4,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Creating unbiased data representations for hiring algorithms.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Requires training a complex model (encoder) with adversarial or constrained objectives; balancing reconstruction and fairness is tricky and may lead to loss of useful information.\"}]"
    ]
  },
  {
    "id": 95,
    "name": "Fairness GAN",
    "description": "Employs Generative Adversarial Networks to generate fair representations of data that obfuscate protected attributes.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#inprocessing-techniques/fair-representation-learning",
    "complexity_rating": 5,
    "computational_cost_rating": 5,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Creating unbiased datasets for training fair image recognition models.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [
      "GANs"
    ],
    "limitations": [
      "[{\"description\": \"GAN training is notoriously difficult to stabilize; ensuring fairness might come at the cost of utility, and it needs a large dataset to train the generator and discriminator effectively.\"}]"
    ]
  },
  {
    "id": 96,
    "name": "Optimised Pre-Processing",
    "description": "Modifies training data features and labels to induce fairness while preserving data utility.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#preprocessing-techniques/data-transformation",
    "complexity_rating": 4,
    "computational_cost_rating": 4,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Adjusting criminal justice data to reduce racial bias before training models.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"May involve solving complex optimization problems; could distort data relationships in ways that degrade model performance if not carefully calibrated to preserve utility.\"}]"
    ]
  },
  {
    "id": 97,
    "name": "Relabelling",
    "description": "Changes labels of certain instances in training data to reduce bias, often based on fairness constraints.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#preprocessing-techniques/data-transformation",
    "complexity_rating": 3,
    "computational_cost_rating": 2,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Modifying labels in loan default datasets to mitigate historical biases.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Altering labels risks introducing new biases or reducing prediction accuracy; deciding which instances to relabel can require a fairness criterion and ground truth fairness assessment.\"}]"
    ]
  },
  {
    "id": 98,
    "name": "Preferential Sampling",
    "description": "Re-samples data with preference for certain groups to achieve fair representation in training datasets.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#preprocessing-techniques/data-transformation",
    "complexity_rating": 2,
    "computational_cost_rating": 2,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Oversampling minority groups in medical data to train unbiased models.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Over-sampling can cause overfitting to minority examples; under-sampling can drop important data from majority group, and it doesn't adjust the model if it inherently treats groups differently.\"}]"
    ]
  },
  {
    "id": 99,
    "name": "Fairness Through Unawareness",
    "description": "Ensures the model does not use protected attributes in decisions; however, indirect bias may persist.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#preprocessing-techniques/data-transformation",
    "complexity_rating": 1,
    "computational_cost_rating": 1,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Removing gender as a feature in employee promotion predictions.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Ignoring protected attributes doesn't guarantee fairness; proxies for the protected attribute in other features can still lead to biased outcomes.\"}]"
    ]
  },
  {
    "id": 100,
    "name": "Adversarial Debiasing for Text",
    "description": "Applies adversarial debiasing techniques specifically to textual data to mitigate biases in language models.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#inprocessing-techniques/adversarial-debiasing",
    "complexity_rating": 4,
    "computational_cost_rating": 4,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Reducing gender bias in sentiment analysis models by adversarial training on text data.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [
      "NLP Models",
      "LLMs"
    ],
    "limitations": [
      "[{\"description\": \"Text data can carry subtle biases in language; adversarial removal of bias might strip out important linguistic context, and the technique inherits all challenges of adversarial training.\"}]"
    ]
  },
  {
    "id": 101,
    "name": "Fair Adversarial Networks",
    "description": "Extends adversarial debiasing by incorporating fairness into deep learning via adversarial training.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#inprocessing-techniques/adversarial-debiasing",
    "complexity_rating": 5,
    "computational_cost_rating": 4,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Reducing bias in facial recognition systems with adversarial networks.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Neural Networks"
    ],
    "limitations": [
      "[{\"description\": \"Extending adversarial debiasing to deep networks can be very complex to implement; requires careful tuning of loss trade-offs, and interpretations of fairness improvement can be opaque.\"}]"
    ]
  },
  {
    "id": 102,
    "name": "Prejudice Remover Regulariser",
    "description": "Incorporates a fairness penalty into the learning objective to penalize models that encode biases with respect to protected attributes.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#inprocessing-techniques/fairnessconstrained-optimisation",
    "complexity_rating": 3,
    "computational_cost_rating": 2,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Training logistic regression models with fairness constraints for university admissions.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Logistic Regression",
      "Other Regularizable Models"
    ],
    "limitations": [
      "[{\"description\": \"Requires setting a hyperparameter for fairness penalty; too high can severely hurt accuracy, too low has little effect. Only applicable to models that can incorporate such a regularizer (e.g., logistic regression).\"}]"
    ]
  },
  {
    "id": 103,
    "name": "Meta Fair Classifier",
    "description": "Modifies any classifier to optimize for fairness metrics using a meta-learning algorithm.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#inprocessing-techniques/fairnessconstrained-optimisation",
    "complexity_rating": 5,
    "computational_cost_rating": 4,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Applying fairness optimization to models in employee evaluation systems.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Meta-learning approach can be complex to implement and require extensive hyperparameter tuning; may result in longer training times and complexity that makes the method less accessible.\"}]"
    ]
  },
  {
    "id": 104,
    "name": "Exponentiated Gradient Reduction",
    "description": "Formulates fairness as a constrained optimization problem, using exponentiated gradient methods to find optimal classifiers.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#inprocessing-techniques/fairnessconstrained-optimisation",
    "complexity_rating": 4,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Training fair classifiers for employment screening processes.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Involves iterative retraining of a classifier with adjusted weights; might require a convex base learner for theoretical guarantees, and can be sensitive to convergence criteria.\"}]"
    ]
  },
  {
    "id": 105,
    "name": "Fair Transfer Learning",
    "description": "Adapts models trained on one domain to another while preserving fairness constraints across domains.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#inprocessing-techniques/fair-representation-learning",
    "complexity_rating": 5,
    "computational_cost_rating": 4,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Transferring fairness-aware models from one region's data to another in healthcare analytics.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Transfer Learning Models",
      "Fine-tuned Models"
    ],
    "limitations": [
      "[{\"description\": \"Fairness achieved in one domain might not directly translate to another if data distributions differ; approach can be complicated to design and may need careful tuning to preserve fairness across domains.\"}]"
    ]
  },
  {
    "id": 106,
    "name": "Adaptive Sensitive Reweighting",
    "description": "Dynamically adjusts weights during training based on model performance across different groups.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#inprocessing-techniques/fairnessconstrained-optimisation",
    "complexity_rating": 4,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Balancing performance in speech recognition across accents and dialects.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Requires monitoring model performance across groups in training, which can introduce instability; if not tuned properly, could oscillate or focus too much on one group at a time.\"}]"
    ]
  },
  {
    "id": 107,
    "name": "Multi-Accuracy Boosting",
    "description": "Improves accuracy uniformly across groups by correcting errors where the model performs poorly for certain groups.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#inprocessing-techniques/fairnessconstrained-optimisation",
    "complexity_rating": 5,
    "computational_cost_rating": 4,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Enhancing model performance for underrepresented groups in disease prediction.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Targets error patterns in subgroups which requires identifying those groups or error regions; could increase complexity of the model and may overfit if very granular corrections are made.\"}]"
    ]
  },
  {
    "id": 108,
    "name": "Equalised Odds Post-Processing",
    "description": "Adjusts output probabilities to equalise true positive and false positive rates across groups.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#postprocessing-techniques/outcome-adjustment",
    "complexity_rating": 3,
    "computational_cost_rating": 2,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Ensuring fairness in recidivism risk assessments used in judicial decisions.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Adjusting outputs can reduce model confidence or require randomization in decisions; may sacrifice individual consistency (similar cases get different outcomes to satisfy group rates).\"}]"
    ]
  },
  {
    "id": 109,
    "name": "Threshold Optimiser",
    "description": "Adjusts decision thresholds for different groups to satisfy fairness constraints post-training.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#postprocessing-techniques/outcome-adjustment",
    "complexity_rating": 3,
    "computational_cost_rating": 1,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Ensuring equal acceptance rates in college admissions across demographics.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Requires a held-out set to determine thresholds per group; if distributions shift, thresholds may need recalibration. Also, using different thresholds per group can raise legal or ethical concerns in deployment.\"}]"
    ]
  },
  {
    "id": 110,
    "name": "Reject Option Classification",
    "description": "Changes decisions where the model is least certain, favoring the disadvantaged group within this uncertain region.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#postprocessing-techniques/outcome-adjustment",
    "complexity_rating": 3,
    "computational_cost_rating": 2,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Mitigating bias in hiring decisions by adjusting uncertain predictions.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Only applicable when model uncertainty can be estimated; choosing the 'reject' region and how to reassign decisions can be subjective and might reject too many instances if tuned conservatively.\"}]"
    ]
  },
  {
    "id": 111,
    "name": "Calibration with Equality of Opportunity",
    "description": "Adjusts probabilities to achieve equal true positive rates across groups while maintaining calibration within each group.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#postprocessing-techniques/calibration-methods",
    "complexity_rating": 4,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Balancing opportunity in credit scoring across different ethnic groups.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Achieving calibration within each group while equalizing true positive rates can be at odds with overall calibration; it may involve solving for probabilities in a way that lowers overall model calibration or accuracy.\"}]"
    ]
  },
  {
    "id": 112,
    "name": "Statistical Parity Difference",
    "description": "Measures the difference in positive outcome rates between protected and unprotected groups.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#fairness-metrics-and-evaluation/group-fairness-metrics",
    "complexity_rating": 1,
    "computational_cost_rating": 1,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Evaluating fairness in hiring models by comparing selection rates across genders.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Ignores true labels or qualification differences; can be satisfied by trivial strategies (like random decisions) and does not ensure individual fairness.\"}]"
    ]
  },
  {
    "id": 113,
    "name": "Disparate Impact",
    "description": "Assesses whether decisions disproportionately affect members of a protected group, typically requiring a ratio between rates.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#fairness-metrics-and-evaluation/group-fairness-metrics",
    "complexity_rating": 1,
    "computational_cost_rating": 1,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Checking for bias in loan approvals where minority groups are less likely to be approved.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Typically uses the 80% rule which is an arbitrary threshold; focuses only on selection rates and not on accuracy or errors, so a model could satisfy disparate impact yet still be unfair in errors.\"}]"
    ]
  },
  {
    "id": 114,
    "name": "Demographic Parity",
    "description": "Evaluates if the outcome is independent of the protected attributes, aiming for equal outcome rates across groups.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#fairness-metrics-and-evaluation/group-fairness-metrics",
    "complexity_rating": 2,
    "computational_cost_rating": 1,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Ensuring job advertisements are shown equally across genders.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"If groups truly differ in label distribution, enforcing parity can harm utility; like statistical parity, it can be achieved in ways that ignore actual qualification (e.g., giving positive decisions randomly to meet rates).\"}]"
    ]
  },
  {
    "id": 115,
    "name": "Equal Opportunity Difference",
    "description": "Computes the difference in true positive rates between groups, assessing fairness in terms of equal opportunity.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#fairness-metrics-and-evaluation/group-fairness-metrics",
    "complexity_rating": 2,
    "computational_cost_rating": 1,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Assessing fairness in medical diagnosis models across age groups.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Addresses only true positive rates, ignoring false positive disparities; requires accurate ground truth labels for the positive class, and improving TPR for one group might increase FPR for that group.\"}]"
    ]
  },
  {
    "id": 116,
    "name": "Average Odds Difference",
    "description": "Calculates the average difference in false positive and true positive rates between groups.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#fairness-metrics-and-evaluation/group-fairness-metrics",
    "complexity_rating": 2,
    "computational_cost_rating": 1,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Measuring bias in criminal risk assessment tools.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Combines multiple error rates which may obscure specific issues (a model could have one high and one low disparity and still average out); still needs ground truth labels and a balanced trade-off with accuracy.\"}]"
    ]
  },
  {
    "id": 117,
    "name": "Individual Fairness Metric (Consistency)",
    "description": "Evaluates whether similar individuals receive similar predictions, assessing fairness at an individual level.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#fairness-metrics-and-evaluation/individual-fairness-metrics",
    "complexity_rating": 3,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Individual Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Ensuring similar credit applicants receive similar loan decisions.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Requires a domain-specific similarity metric between individuals; hard to define and validate, and ensuring consistency can conflict with achieving good group-level metrics.\"}]"
    ]
  },
  {
    "id": 118,
    "name": "Algorithmic Fairness using K-NN",
    "description": "Uses K-nearest neighbors to assess individual fairness by comparing predictions among similar instances.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#fairness-metrics-and-evaluation/individual-fairness-metrics",
    "complexity_rating": 3,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Individual Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Evaluating fairness in personalized recommendation systems.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Relies on the quality of the distance metric; high-dimensional data can make nearest neighbor comparisons noisy (curse of dimensionality), and it doesn't directly fix the model, just evaluates it.\"}]"
    ]
  },
  {
    "id": 119,
    "name": "Counterfactual Fairness (Causal Modeling)",
    "description": "Ensures predictions remain the same in a counterfactual world where protected attributes are altered.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#causal-fairness-methods/counterfactual-fairness",
    "complexity_rating": 4,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Individual Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Assessing fairness in loan approvals by simulating changes in applicant's race.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Structural Causal Models",
      "Causal Inference Models"
    ],
    "limitations": [
      "[{\"description\": \"Requires a causal model of the data (including how protected attributes influence other features) which might be difficult to obtain; results depend on the correctness of this causal model.\"}]"
    ]
  },
  {
    "id": 120,
    "name": "Path-Specific Counterfactual Fairness",
    "description": "Considers specific causal pathways, allowing fairness interventions on certain paths.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#causal-fairness-methods/counterfactual-fairness",
    "complexity_rating": 5,
    "computational_cost_rating": 4,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Individual Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Modeling fair decisions in advertising without altering legitimate causal effects.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Structural Causal Models"
    ],
    "limitations": [
      "[{\"description\": \"Requires identifying which causal pathways are 'allowable' and which are not—a subjective decision; analyzing specific paths adds complexity to the causal model and the fairness criterion.\"}]"
    ]
  },
  {
    "id": 121,
    "name": "Causal Fairness Assessment with Do-Calculus",
    "description": "Utilizes causal inference techniques to assess and mitigate bias by computing interventional distributions.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#causal-fairness-methods/causal-inference",
    "complexity_rating": 5,
    "computational_cost_rating": 4,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Causal Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Understanding bias in hiring decisions through causal relationships.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Causal Inference Models"
    ],
    "limitations": [
      "[{\"description\": \"Strongly dependent on having a correct causal graph; using do-calculus in practice can be computationally intense and challenging outside of relatively simple models or well-specified causal relationships.\"}]"
    ]
  },
  {
    "id": 122,
    "name": "Diversity Constraints in Recommendations",
    "description": "Incorporates diversity and fairness constraints in recommendation systems for varied and fair content exposure.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#inprocessing-techniques/fairnessconstrained-optimisation",
    "complexity_rating": 4,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Ensuring fair representation of genres in music recommendation platforms.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Recommendation Systems",
      "Collaborative Filtering",
      "Content-Based Recommenders"
    ],
    "limitations": [
      "[{\"description\": \"May reduce accuracy or relevance of recommendations if forced diversity conflicts with user preferences; implementing constraints can complicate the recommendation algorithm and objective function.\"}]"
    ]
  },
  {
    "id": 123,
    "name": "Bayesian Fairness Regularization",
    "description": "Applies Bayesian methods to include fairness as a prior, allowing probabilistic interpretation of fairness constraints.",
    "model_dependency": "Model-Specific",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#inprocessing-techniques/fairnessconstrained-optimisation",
    "complexity_rating": 5,
    "computational_cost_rating": 4,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Group Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Applying fairness regularization in Bayesian models for credit risk assessment.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [
      "Bayesian Models"
    ],
    "limitations": [
      "[{\"description\": \"Selecting appropriate prior distributions for fairness is non-trivial; Bayesian methods can be computationally intensive (e.g., requiring sampling) and outcomes can be sensitive to prior assumptions.\"}]"
    ]
  },
  {
    "id": 124,
    "name": "SHAP Values for Fairness",
    "description": "Uses SHAP (SHapley Additive exPlanations) to attribute model predictions to input features, helping to identify bias contributions.",
    "model_dependency": "Model-Agnostic",
    "assurance_goals": [
      "Fairness"
    ],
    "category_tags": "#interpretability-and-explainability/feature-attribution-methods",
    "complexity_rating": 3,
    "computational_cost_rating": 3,
    "attributes": [
      {
        "type": "Fairness Approach",
        "value": "Individual Fairness"
      }
    ],
    "example_use_cases": [
      {
        "description": "Explaining biased predictions in loan approvals by examining feature contributions.",
        "goal": "Fairness"
      }
    ],
    "resources": [],
    "applicable_models": [],
    "limitations": [
      "[{\"description\": \"Identifies feature contributions to bias but doesn't automatically mitigate it; interpretation requires understanding SHAP outputs, and correlated features can distribute bias attribution, complicating conclusions.\"}]"
    ]
  }
]
</file>

<file path="backend/.env.example">
# Backend environment variables
# Copy this file to .env and update with your specific values

# Django configuration
SECRET_KEY=change-this-in-production
# Use 'config.settings.development', 'config.settings.production', 'config.settings.sqlite', 'config.settings.docker'
DJANGO_SETTINGS_MODULE=config.settings.development

# PostgreSQL database configuration
DB_NAME=techniques
DB_USER=postgres
DB_PASSWORD=postgres
DB_HOST=localhost  # Use 'db' when running in Docker
DB_PORT=5432

# CORS settings for frontend access (comma-separated list)
CORS_ALLOWED_ORIGINS=http://localhost:3000,http://127.0.0.1:3000,http://frontend:3000
</file>

<file path="backend/Dockerfile">
FROM python:3.12-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    libpq-dev \
    postgresql-client \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY pyproject.toml poetry.lock ./
RUN pip install poetry && \
    poetry config virtualenvs.create false && \
    poetry install --only main --no-interaction --no-ansi && \
    pip install gunicorn && \
    pip install whitenoise

# Copy project files
COPY . .

# Create directories for scripts and static files
RUN mkdir -p /app/scripts /app/static /app/staticfiles

# Copy entrypoint script and set permissions
COPY entrypoint.sh /app/entrypoint.sh
RUN chmod +x /app/entrypoint.sh

# Set default settings module for Docker
ENV DJANGO_SETTINGS_MODULE=config.settings.docker

# Add health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=30s --retries=5 \
    CMD curl -f http://localhost:8000/api/health/ || exit 1

EXPOSE 8000

CMD ["/app/entrypoint.sh"]
</file>

<file path="docs/TESTING.md">
# TEA Techniques Testing Guide

> [!NOTE]
> This guide explains the testing setup for both frontend and backend components, as well as cross-environment integration testing.
>
> For information on the development workflow surrounding testing, please see the [Development Workflow](DEVELOPMENT-WORKFLOW.md) documentation.

## Frontend Testing

The frontend uses Jest and React Testing Library for component and API testing.

### Setup

> [!TIP] 
> The testing environment is configured with:
> - Jest for test running and assertions
> - React Testing Library for component testing
> - MSW (Mock Service Worker) for API mocking

### Running Tests

To run the frontend tests:

```bash
cd frontend
pnpm run test
```

To run tests in watch mode during development:

```bash
cd frontend
pnpm run test:watch
```

## Backend Testing

The backend uses pytest and Django's testing tools for model and API testing.

### Setup

> [!TIP]
> The testing environment is configured with:
> - pytest and pytest-django for test running
> - Factory Boy for test data generation
> - pytest-cov for test coverage

### Running Tests

To run the backend tests:

```bash
cd backend
poetry run pytest
```

For test coverage report:

```bash
cd backend
poetry run pytest --cov=api
```

## Related Documentation

- [Development Workflow](DEVELOPMENT-WORKFLOW.md) - How testing fits into the development process
- [Contributing Guide](CONTRIBUTING.md) - Guidelines for test-driven development
- [Frontend Guide](FRONTEND-GUIDE.md) - Frontend architecture being tested
- [Model Architecture](MODEL-ARCHITECTURE.md) - Backend models being tested
</file>

<file path="frontend/src/lib/api/errorUtils.ts">
import axios, { AxiosError } from "axios";

// Types for standardized error logging
interface ErrorLogDetails {
  hookName: string;
  type: string;
  message: string;
  statusCode?: number;
  responseData?: unknown;
  requestInfo?: {
    method?: string;
    url?: string;
    params?: unknown;
    data?: unknown;
  };
}

/**
 * Enhanced error logger for API errors that provides structured logging 
 * and detailed information about the error context.
 */
export function logApiError(hookName: string, error: unknown): void {
  // Base error log object
  const errorLog: ErrorLogDetails = {
    hookName,
    type: "UnknownError",
    message: "Unknown error occurred"
  };
  
  // Process Axios errors
  if (axios.isAxiosError(error)) {
    const axiosError = error as AxiosError;
    
    // Update error type and message
    errorLog.type = "AxiosError";
    errorLog.message = axiosError.message;
    
    // Add request details if available
    if (axiosError.config) {
      errorLog.requestInfo = {
        method: axiosError.config.method?.toUpperCase(),
        url: axiosError.config.url,
        params: axiosError.config.params,
        data: axiosError.config.data
      };
    }
    
    // Add response details if available
    if (axiosError.response) {
      errorLog.statusCode = axiosError.response.status;
      errorLog.responseData = axiosError.response.data;
      
      // Improve error type based on status code
      if (axiosError.response.status >= 400 && axiosError.response.status < 500) {
        errorLog.type = "ClientError";
      } else if (axiosError.response.status >= 500) {
        errorLog.type = "ServerError";
      }
      
      // Try to extract standardized error type if available
      if (
        axiosError.response.data &&
        typeof axiosError.response.data === "object" &&
        axiosError.response.data !== null &&
        "error_type" in axiosError.response.data &&
        typeof axiosError.response.data.error_type === "string"
      ) {
        errorLog.type = axiosError.response.data.error_type;
      }
    } else if (axiosError.request) {
      // Request was made but no response received (likely network issue)
      errorLog.type = "NetworkError";
    }
  } else if (error instanceof Error) {
    // Handle standard JS errors
    errorLog.type = error.name;
    errorLog.message = error.message;
  } else if (error !== null && error !== undefined) {
    // Handle non-standard error objects
    errorLog.message = String(error);
  }
  
  // Log the structured error details
  console.error(`[API Error][${errorLog.hookName}] ${errorLog.type}: ${errorLog.message}`, {
    details: errorLog,
    originalError: error
  });
  
  // Add extra logging for unexpected error formats to help with debugging
  if (
    errorLog.responseData && 
    typeof errorLog.responseData === "object" && 
    errorLog.responseData !== null &&
    !("detail" in errorLog.responseData) && 
    !("error_type" in errorLog.responseData) &&
    !("errors" in errorLog.responseData)
  ) {
    console.warn(`[API Error][${errorLog.hookName}] Unexpected error format detected:`, errorLog.responseData);
  }
}
</file>

<file path="frontend/src/lib/context/dark-mode.tsx">
"use client";

import React, {
	createContext,
	useState,
	useContext,
	useEffect,
	ReactNode,
} from "react";
import { Moon, Sun } from "lucide-react";

type DarkModeContextType = {
	isDarkMode: boolean;
	toggleDarkMode: () => void;
};

const DarkModeContext = createContext<DarkModeContextType>({
	isDarkMode: false,
	toggleDarkMode: () => {},
});

export const DarkModeProvider: React.FC<{ children: ReactNode }> = ({
	children,
}) => {
	const [isDarkMode, setIsDarkMode] = useState(false);

	// Check for saved preference or system preference on initial load
	useEffect(() => {
		const savedMode = localStorage.getItem("darkMode");
		const prefersDarkMode = window.matchMedia(
			"(prefers-color-scheme: dark)"
		).matches;

		if (savedMode !== null) {
			setIsDarkMode(savedMode === "true");
		} else {
			setIsDarkMode(prefersDarkMode);
		}
	}, []);

	// Apply dark mode class to document
	useEffect(() => {
		if (isDarkMode) {
			document.documentElement.classList.add("dark");
			localStorage.setItem("darkMode", "true");
		} else {
			document.documentElement.classList.remove("dark");
			localStorage.setItem("darkMode", "false");
		}
	}, [isDarkMode]);

	const toggleDarkMode = () => {
		setIsDarkMode(!isDarkMode);
	};

	return (
		<DarkModeContext.Provider value={{ isDarkMode, toggleDarkMode }}>
			{children}
		</DarkModeContext.Provider>
	);
};

// Custom hook for easy dark mode access
export const useDarkMode = () => useContext(DarkModeContext);

// Dark Mode Toggle Component
export const DarkModeToggle: React.FC = () => {
	const { isDarkMode, toggleDarkMode } = useDarkMode();

	return (
		<button
			onClick={toggleDarkMode}
			className="p-2 rounded-full bg-gray-200 dark:bg-gray-700"
			aria-label={
				isDarkMode ? "Switch to Light Mode" : "Switch to Dark Mode"
			}
		>
			{isDarkMode ? (
				<Sun className="h-5 w-5 text-white" />
			) : (
				<Moon className="h-5 w-5 text-gray-800" />
			)}
		</button>
	);
};
</file>

<file path="frontend/src/lib/hooks/useFilterParams.ts">
// src/lib/hooks/useFilterParams.ts
import { useState, useEffect, useCallback } from "react";
import { useSearchParams, useRouter, usePathname } from "next/navigation";

interface FilterState {
  [key: string]: string;
}

/**
 * Custom hook for managing filter parameters in URL
 * @param initialFilters Initial filter values
 * @param defaultPage Default page number
 * @returns Filter state and handlers
 */
export function useFilterParams(
  initialFilters: FilterState,
  defaultPage = 1
) {
  const searchParams = useSearchParams();
  const router = useRouter();
  const pathname = usePathname();

  // Initialize state from URL parameters
  const [filters, setFilters] = useState<FilterState>(() => {
    const filtersFromUrl: FilterState = { ...initialFilters };
    
    // Get filter values from URL (for standard parameters)
    Object.keys(initialFilters).forEach(key => {
      const paramValue = searchParams.get(key);
      if (paramValue) {
        filtersFromUrl[key] = paramValue;
      }
    });
    
    // Special handling for plural parameter names from backend
    
    // Handle assurance_goals (plural) -> assurance_goal (singular) for component state
    const assuranceGoalsParam = searchParams.get("assurance_goals");
    if (assuranceGoalsParam) {
      filtersFromUrl.assurance_goal = assuranceGoalsParam;
    }
    
    // Handle categories (plural) -> category (singular) for component state
    const categoriesParam = searchParams.get("categories");
    if (categoriesParam) {
      filtersFromUrl.category = categoriesParam;
    }
    
    // Get page from URL
    const pageParam = searchParams.get("page");
    filtersFromUrl.page = pageParam || defaultPage.toString();
    
    return filtersFromUrl;
  });

  // Update filters when URL parameters change
  useEffect(() => {
    // Only update local state if search params actually changed
    const updateFilters = () => {
      const filtersFromUrl: FilterState = { ...initialFilters };
      let hasChanged = false;
      
      // Process standard parameters (singular names in the component state)
      Object.keys(initialFilters).forEach(key => {
        const paramValue = searchParams.get(key);
        if (paramValue) {
          if (filtersFromUrl[key] !== paramValue) {
            hasChanged = true;
            filtersFromUrl[key] = paramValue;
          }
        } else if (filtersFromUrl[key] !== initialFilters[key]) {
          hasChanged = true;
          filtersFromUrl[key] = initialFilters[key];
        }
      });
      
      // Special handling for backend plural parameter names
      
      // Handle assurance_goals (plural) -> assurance_goal (singular)
      const assuranceGoalsParam = searchParams.get("assurance_goals");
      if (assuranceGoalsParam) {
        if (filtersFromUrl.assurance_goal !== assuranceGoalsParam) {
          hasChanged = true;
          filtersFromUrl.assurance_goal = assuranceGoalsParam;
        }
      }
      
      // Handle categories (plural) -> category (singular)
      const categoriesParam = searchParams.get("categories");
      if (categoriesParam) {
        if (filtersFromUrl.category !== categoriesParam) {
          hasChanged = true;
          filtersFromUrl.category = categoriesParam;
        }
      }
      
      // Get page from URL
      const pageParam = searchParams.get("page");
      const newPage = pageParam || defaultPage.toString();
      if (filtersFromUrl.page !== newPage) {
        hasChanged = true;
        filtersFromUrl.page = newPage;
      }
      
      // Only update state if values actually changed
      if (hasChanged) {
        setFilters(filtersFromUrl);
      }
    };
    
    updateFilters();
    
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams]);

  /**
   * Set a single filter value, preventing unnecessary updates
   * 
   * This function updates a single filter value in the state. It includes
   * an optimization to prevent unnecessary re-renders by returning the same
   * state reference if the value hasn't actually changed.
   * 
   * @param key - The filter key to update
   * @param value - The new value for the filter
   */
  const setFilter = (key: string, value: string) => {
    // Only update if the value actually changed to prevent unnecessary renders
    setFilters(prev => {
      if (prev[key] === value) {
        return prev; // Return the same object reference if nothing changed
      }
      return {
        ...prev,
        [key]: value,
      };
    });
  };

  /**
   * Create URL search parameters from the current filter state
   * 
   * This converts the component's filter state into URL search parameters,
   * handling the conversion from singular field names (used in the component)
   * to plural field names (expected by the backend API).
   * 
   * @param resetPageParam - Whether to reset the page parameter to 1 (default: true)
   * @returns URLSearchParams object with the filter parameters
   */
  const createSearchParams = useCallback((resetPageParam = true) => {
    const params = new URLSearchParams();
    
    // Convert from component parameter names to backend parameter names (singular to plural)
    
    // Handle assurance_goal -> assurance_goals (backend expects plural)
    if (filters.assurance_goal && filters.assurance_goal !== "all") {
      params.set("assurance_goals", filters.assurance_goal); 
    }
    
    // Handle category -> categories (backend expects plural)
    if (filters.category && filters.category !== "all") {
      params.set("categories", filters.category);
    }
    
    // Add search parameter if provided
    if (filters.search) {
      params.set("search", filters.search);
    }
    
    // Set page parameter (reset to 1 if specified)
    params.set("page", resetPageParam ? "1" : filters.page);
    
    return params;
  }, [filters]);

  /**
   * Apply filters to the URL and navigate to the filtered view
   * 
   * This converts the current filter state to URL parameters and
   * navigates to the updated URL, triggering a filtered view of the data.
   * 
   * @param resetPage - Whether to reset the page to 1 (default: true)
   */
  const applyFilters = useCallback((resetPage = true) => {
    const params = createSearchParams(resetPage);
    
    try {
      // Use Next.js router.push for client-side navigation
      router.push(`${pathname}?${params.toString()}`);
    } catch (error) {
      console.error("Navigation error:", error);
    }
  }, [createSearchParams, router, pathname]);

  /**
   * Reset all filters to their initial values
   * 
   * This resets the filter state to the initial values provided when the hook was
   * initialized, and navigates to the URL with only the page parameter set to 1.
   */
  const resetFilters = useCallback(() => {
    // Update local state
    setFilters({ 
      ...initialFilters,
      page: "1"
    });
    
    // Use Next.js router for navigation
    try {
      router.push(`${pathname}?page=1`);
    } catch (error) {
      console.error("Reset navigation error:", error);
    }
  }, [initialFilters, router, pathname]);

  /**
   * Change the current page and update the URL
   * 
   * This navigates to a different page while preserving all other filter parameters.
   * It handles the conversion from singular field names (component) to plural field
   * names (backend) just like other filter methods.
   * 
   * @param newPage - The page number to navigate to
   */
  const changePage = useCallback((newPage: number) => {
    // Build URL with current filters plus new page
    const params = new URLSearchParams();
    
    // Apply backend-expected parameter names
    
    // Handle assurance_goal -> assurance_goals (plural)
    if (filters.assurance_goal && filters.assurance_goal !== "all") {
      params.set("assurance_goals", filters.assurance_goal);
    }
    
    // Handle category -> categories (plural)
    if (filters.category && filters.category !== "all") {
      params.set("categories", filters.category);
    }
    
    // Add search parameter if provided
    if (filters.search) {
      params.set("search", filters.search);
    }
    
    // Set the new page parameter
    params.set("page", newPage.toString());
    
    // Use Next.js router for navigation
    try {
      router.push(`${pathname}?${params.toString()}`);
    } catch (error) {
      console.error("Page change navigation error:", error);
    }
  }, [filters, router, pathname]);

  return {
    filters,
    setFilter,
    applyFilters,
    resetFilters,
    changePage,
    currentPage: parseInt(filters.page || "1", 10),
  };
}
</file>

<file path="frontend/src/lib/config.ts">
// frontend/src/lib/config.ts

interface Config {
	apiBaseUrl: string;
	swaggerUrl: string;
	isProduction: boolean;
}

// Always prefer environment variables if available
const getApiBaseUrl = (): string => {
	// Check for environment variables
	if (process.env.NEXT_PUBLIC_API_URL) {
		console.log('Using NEXT_PUBLIC_API_URL from env:', process.env.NEXT_PUBLIC_API_URL);
		return process.env.NEXT_PUBLIC_API_URL;
	}

	// Use relative URL for both dev and prod to work with any domain
	console.log('No NEXT_PUBLIC_API_URL found, using default /api');
	return "/api";
};

const getSwaggerUrl = (): string => {
	if (process.env.NEXT_PUBLIC_SWAGGER_URL) {
		return process.env.NEXT_PUBLIC_SWAGGER_URL;
	}

	// Use relative URL
	return "/swagger/";
};

export const config: Config = {
	apiBaseUrl: getApiBaseUrl(),
	swaggerUrl: getSwaggerUrl(),
	isProduction: process.env.NODE_ENV === "production",
};
</file>

<file path="frontend/src/lib/types.ts">
// src/lib/types.ts

// Base type interfaces
export interface AssuranceGoal {
	id: number;
	name: string;
	description: string;
}

export interface Category {
	id: number;
	name: string;
	description: string;
	assurance_goal: number;
	assurance_goal_name: string;
}

export interface SubCategory {
	id: number;
	name: string;
	description: string;
	category: number;
	category_name: string;
}

export interface Tag {
	id: number;
	name: string;
}

// Attribute System
export interface AttributeType {
	id: number;
	name: string;
	description: string;
	applicable_goals: number[];
	required_for_goals: number[];
}

export interface AttributeValue {
	id: number;
	attribute_type: number;
	attribute_type_name: string;
	name: string;
	description: string;
}

export interface TechniqueAttribute {
	id: number;
	attribute_type: string;
	attribute_value: number;
	attribute_value_name: string;
}

// Resource Management
export interface ResourceType {
	id: number;
	name: string;
	icon: string;
}

export interface TechniqueResource {
	id: number;
	resource_type: number;
	resource_type_name: string;
	source_type?: string;  // Added based on data in techniques.csv
	title: string;
	url: string;
	description: string;
	authors?: string;
	publication_date?: string;
}

// Use Cases and Limitations
export interface TechniqueExampleUseCase {
	id: number;
	description: string;
	assurance_goal?: number;
	assurance_goal_name?: string;
}

export interface TechniqueLimitation {
	id: number;
	description: string;
}

// Technique Relationship
export interface TechniqueRelationship {
	id: number;
	technique_from: number;
	technique_from_name: string;
	technique_to: number;
	technique_to_name: string;
	relationship_type: string;
}

// Main Technique Type
export interface Technique {
	id: number;
	name: string;
	description: string;
	model_dependency: string;
	category_tags: string;
	complexity_rating?: number;
	computational_cost_rating?: number;
	applicable_models?: string[];

	// Many-to-many relationships
	assurance_goals: AssuranceGoal[];
	categories: Category[];
	subcategories: SubCategory[];
	tags: Tag[];

	// Renamed from attributes to attribute_values to match API
	attribute_values: AttributeValue[];
	resources: TechniqueResource[];
	example_use_cases: TechniqueExampleUseCase[];
	limitations: TechniqueLimitation[];
}

// Form Data for Creating/Updating Techniques
export interface TechniqueFormData {
	name: string;
	description: string;
	model_dependency: string;
	assurance_goal_ids: number[];
	category_ids: number[];
	subcategory_ids: number[];
	tag_ids: number[];
	attributes: {
		attribute_type: number;
		attribute_value: number;
	}[];
	resources: {
		resource_type: number;
		title: string;
		url: string;
		description: string;
	}[];
	example_use_cases: {
		description: string;
		assurance_goal?: number;
	}[];
	limitations: string[];
}

// API Response wrapper type
export interface APIResponse<T> {
	count: number;
	next: string | null;
	previous: string | null;
	results: T[];
}

// Generic response type
export interface APIErrorResponse {
	detail?: string;
	errors?: Record<string, string[]>;
	status_code?: number;
	error_type?: string;
	[key: string]:
		| string
		| number
		| boolean
		| null
		| undefined
		| Record<string, string[]>;
}
</file>

<file path="frontend/src/tests/hooks/useApiError.test.ts">
import { renderHook, act } from "@testing-library/react";
import { useApiError } from "@/lib/hooks/useApiError";
import axios, { AxiosError, AxiosHeaders, AxiosResponse } from "axios";

// Mock console.error to avoid cluttering test output
const originalConsoleError = console.error;
beforeAll(() => {
  console.error = jest.fn();
});

afterAll(() => {
  console.error = originalConsoleError;
});

// Helper to create Axios errors for testing
function createAxiosError(status: number, data: any): AxiosError {
  const headers = new AxiosHeaders();
  
  const response: AxiosResponse = {
    data,
    status,
    statusText: status === 404 ? "Not Found" : "Error",
    headers,
    config: {
      headers
    } as any,
  };
  
  const error = new AxiosError(
    "Request failed",
    String(status),
    { headers } as any,
    null,
    response
  );
  
  return error;
}

describe("useApiError hook", () => {
  test("handles standard backend error format correctly", () => {
    const { result } = renderHook(() => useApiError());
    
    const standardizedError = createAxiosError(400, {
      detail: "Validation failed",
      status_code: 400,
      error_type: "ValidationError",
      errors: {
        name: ["This field is required"],
        description: ["This field is required"]
      }
    });
    
    act(() => {
      result.current.handleError(standardizedError);
    });
    
    expect(result.current.error).toEqual({
      message: "Validation failed",
      details: {
        name: ["This field is required"],
        description: ["This field is required"]
      },
      statusCode: 400,
      errorType: "ValidationError"
    });
  });
  
  test("handles DRF validation errors with field-specific messages", () => {
    const { result } = renderHook(() => useApiError());
    
    // DRF validation error format
    const validationError = createAxiosError(400, {
      name: ["This field is required"],
      description: ["This field is required"]
    });
    
    act(() => {
      result.current.handleError(validationError);
    });
    
    expect(result.current.error).toEqual({
      message: "Validation error",
      details: {
        name: ["This field is required"],
        description: ["This field is required"]
      },
      statusCode: 400,
      errorType: "ValidationError"
    });
  });
  
  test("handles DRF error with detail field as string", () => {
    const { result } = renderHook(() => useApiError());
    
    // DRF error with detail field
    const detailError = createAxiosError(404, {
      detail: "Not found"
    });
    
    act(() => {
      result.current.handleError(detailError);
    });
    
    expect(result.current.error).toEqual({
      message: "Not found",
      statusCode: 404,
      errorType: "APIError"
    });
  });
  
  test("handles network errors", () => {
    const { result } = renderHook(() => useApiError());
    
    // Network error (no response)
    const networkError = new AxiosError(
      "Network Error",
      "ECONNABORTED"
    );
    
    act(() => {
      result.current.handleError(networkError);
    });
    
    expect(result.current.error?.message).toContain("Network Error");
    expect(result.current.error?.errorType).toBe("NetworkError");
  });
  
  test("handles regular JS errors", () => {
    const { result } = renderHook(() => useApiError());
    
    const jsError = new Error("JavaScript error");
    
    act(() => {
      result.current.handleError(jsError);
    });
    
    expect(result.current.error).toEqual({
      message: "JavaScript error",
      errorType: "Error"
    });
  });
  
  test("handles unknown error types", () => {
    const { result } = renderHook(() => useApiError());
    
    act(() => {
      result.current.handleError("Some string error");
    });
    
    expect(result.current.error).toEqual({
      message: "An unknown error occurred",
      errorType: "UnknownError"
    });
  });
  
  test("clears error state", () => {
    const { result } = renderHook(() => useApiError());
    
    // Set an error
    act(() => {
      result.current.handleError(new Error("Test error"));
    });
    
    // Verify error is set
    expect(result.current.error).not.toBeNull();
    
    // Clear error
    act(() => {
      result.current.clearError();
    });
    
    // Verify error is cleared
    expect(result.current.error).toBeNull();
  });
});
</file>

<file path="frontend/src/tests/TechniqueForm.test.tsx">
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import TechniqueForm from '@/components/technique/TechniqueForm';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useRouter } from 'next/navigation';

// Mock the next/navigation
jest.mock('next/navigation', () => ({
  useRouter: jest.fn(),
}));

// Mock API hooks with more complete mock data
jest.mock('@/lib/api/hooks', () => ({
  useCreateTechnique: () => ({ 
    mutateAsync: jest.fn().mockResolvedValue({ id: 123 }), 
    isPending: false 
  }),
  useUpdateTechnique: () => ({ 
    mutateAsync: jest.fn().mockResolvedValue({ id: 456 }), 
    isPending: false 
  }),
  useAssuranceGoals: () => ({ 
    data: { 
      results: [
        { id: 1, name: 'Accuracy' },
        { id: 2, name: 'Fairness' },
        { id: 3, name: 'Safety' }
      ] 
    }, 
    isLoading: false 
  }),
  useCategories: () => ({ 
    data: { 
      results: [
        { id: 1, name: 'Testing', assurance_goal: 1 },
        { id: 2, name: 'Monitoring', assurance_goal: 1 },
        { id: 3, name: 'Bias Detection', assurance_goal: 2 }
      ] 
    }, 
    isLoading: false 
  }),
  useSubCategories: () => ({ 
    data: { 
      results: [
        { id: 1, name: 'Unit Testing', category: 1 },
        { id: 2, name: 'Integration Testing', category: 1 },
        { id: 3, name: 'Real-time Monitoring', category: 2 }
      ] 
    }, 
    isLoading: false 
  }),
  useTags: () => ({ 
    data: { 
      results: [
        { id: 1, name: 'ML' },
        { id: 2, name: 'NLP' },
        { id: 3, name: 'Computer Vision' }
      ] 
    }, 
    isLoading: false 
  }),
  useResourceTypes: () => ({ 
    data: { 
      results: [
        { id: 1, name: 'Paper' },
        { id: 2, name: 'Code Repository' },
        { id: 3, name: 'Documentation' }
      ] 
    }, 
    isLoading: false 
  }),
  useTechniqueDetail: (id) => ({ 
    data: id ? {
      id: id,
      name: 'Test Technique',
      description: 'Test Description',
      model_dependency: 'Model-Agnostic',
      assurance_goals: [{ id: 1, name: 'Accuracy' }],
      categories: [{ id: 1, name: 'Testing' }],
      subcategories: [],
      tags: [],
      attribute_values: [],
      example_use_cases: [{ description: 'Example use case', assurance_goal: 1 }],
      limitations: [{ description: 'Limitation example' }],
      resources: [{ resource_type: 1, title: 'Resource', url: 'https://example.com', description: 'Resource Description' }],
    } : null, 
    isLoading: false 
  }),
}));

// Mock API error hook
jest.mock('@/lib/hooks/useApiError', () => ({
  useApiError: () => ({ 
    error: null, 
    handleError: jest.fn() 
  }),
}));

describe('TechniqueForm', () => {
  let queryClient: QueryClient;
  let user: ReturnType<typeof userEvent.setup>;
  const pushMock = jest.fn();
  const backMock = jest.fn();

  beforeEach(() => {
    queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          retry: false,
        },
      },
    });

    user = userEvent.setup();

    // Setup router mock
    (useRouter as jest.Mock).mockImplementation(() => ({
      push: pushMock,
      back: backMock,
    }));
  });

  afterEach(() => {
    jest.clearAllMocks();
    queryClient.clear();
  });

  it('renders the form for creating a new technique', () => {
    render(
      <QueryClientProvider client={queryClient}>
        <TechniqueForm />
      </QueryClientProvider>
    );

    // Check that the form title is rendered
    expect(screen.getByText('Create New Technique')).toBeInTheDocument();
    
    // Check that required fields are present
    expect(screen.getByLabelText(/Technique Name/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Description/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Model Dependency/i)).toBeInTheDocument();
    
    // Check that submit button is present
    expect(screen.getByText('Create Technique')).toBeInTheDocument();
  });

  it('renders the form for editing an existing technique', () => {
    render(
      <QueryClientProvider client={queryClient}>
        <TechniqueForm id={1} isEditMode={true} />
      </QueryClientProvider>
    );

    // Check that the form title is for editing
    expect(screen.getByText('Edit Technique')).toBeInTheDocument();
    
    // Check that submit button is for updating
    expect(screen.getByText('Update Technique')).toBeInTheDocument();
    
    // Check that the form is populated with the existing technique data
    expect(screen.getByLabelText(/Technique Name/i)).toHaveValue('Test Technique');
    expect(screen.getByLabelText(/Description/i)).toHaveValue('Test Description');
  });

  it('successfully submits a new technique', async () => {
    const createTechniqueMock = require('@/lib/api/hooks').useCreateTechnique().mutateAsync;

    render(
      <QueryClientProvider client={queryClient}>
        <TechniqueForm />
      </QueryClientProvider>
    );

    // Fill out the basic required fields
    await user.type(screen.getByLabelText(/Technique Name/i), 'New Test Technique');
    await user.type(screen.getByLabelText(/Description/i), 'New test description');
    
    // Navigate to the Classification tab
    await user.click(screen.getByRole('tab', { name: /Classification/i }));
    
    // Select an assurance goal (multi-select)
    const assuranceGoalSelect = screen.getByLabelText(/Assurance Goals/i);
    await user.selectOptions(assuranceGoalSelect, ['1']); // Select 'Accuracy'
    
    // Select a category
    const categorySelect = screen.getByLabelText(/Categories/i);
    await user.selectOptions(categorySelect, ['1']); // Select 'Testing'
    
    // Submit the form
    await user.click(screen.getByText('Create Technique'));
    
    // Wait for the submission to complete
    await waitFor(() => {
      expect(createTechniqueMock).toHaveBeenCalled();
      expect(pushMock).toHaveBeenCalledWith('/techniques/123');
    });
  });

  it('successfully updates an existing technique', async () => {
    const updateTechniqueMock = require('@/lib/api/hooks').useUpdateTechnique().mutateAsync;

    render(
      <QueryClientProvider client={queryClient}>
        <TechniqueForm id={456} isEditMode={true} />
      </QueryClientProvider>
    );

    // Edit the name field
    const nameInput = screen.getByLabelText(/Technique Name/i);
    await user.clear(nameInput);
    await user.type(nameInput, 'Updated Test Technique');
    
    // Submit the form
    await user.click(screen.getByText('Update Technique'));
    
    // Wait for the submission to complete
    await waitFor(() => {
      expect(updateTechniqueMock).toHaveBeenCalled();
      expect(pushMock).toHaveBeenCalledWith('/techniques/456');
    });
  });

  it('adds and removes dynamic fields - use cases', async () => {
    render(
      <QueryClientProvider client={queryClient}>
        <TechniqueForm />
      </QueryClientProvider>
    );

    // Navigate to the Examples & Limitations tab
    await user.click(screen.getByRole('tab', { name: /Examples & Limitations/i }));
    
    // The form should start with one empty use case
    expect(screen.getByText('Example 1')).toBeInTheDocument();
    
    // Add a new use case
    await user.click(screen.getByText('Add Use Case'));
    
    // Now there should be two use cases
    expect(screen.getByText('Example 1')).toBeInTheDocument();
    expect(screen.getByText('Example 2')).toBeInTheDocument();
    
    // Fill out the second use case
    const useCaseInputs = screen.getAllByLabelText('Description');
    await user.type(useCaseInputs[1], 'New test use case');
    
    // Remove the first use case
    const removeButtons = screen.getAllByRole('button', { name: '' }); // Trash2 icon buttons have no accessible name
    await user.click(removeButtons[0]);
    
    // Now there should only be one use case (the second one)
    expect(screen.queryByText('Example 1')).toBeInTheDocument();
    expect(screen.queryByText('Example 2')).not.toBeInTheDocument();
  });

  it('shows validation errors when submitting invalid data', async () => {  
    render(
      <QueryClientProvider client={queryClient}>
        <TechniqueForm />
      </QueryClientProvider>
    );
    
    // Try to submit the form without filling required fields
    await user.click(screen.getByText('Create Technique'));
    
    // Check that validation errors are displayed
    await waitFor(() => {
      expect(screen.getByText('Name is required')).toBeInTheDocument();
      expect(screen.getByText('Description is required')).toBeInTheDocument();
    });
    
    // Navigate to the Classification tab to check those errors
    await user.click(screen.getByRole('tab', { name: /Classification/i }));
    
    await waitFor(() => {
      expect(screen.getByText('At least one assurance goal is required')).toBeInTheDocument();
      expect(screen.getByText('At least one category is required')).toBeInTheDocument();
    });
  });

  it('displays loading state when submitting', async () => {
    // Mock the isPending state to be true
    jest.spyOn(require('@/lib/api/hooks'), 'useCreateTechnique').mockImplementation(() => ({
      mutateAsync: jest.fn(() => new Promise(resolve => setTimeout(() => resolve({ id: 123 }), 100))),
      isPending: true
    }));
    
    render(
      <QueryClientProvider client={queryClient}>
        <TechniqueForm />
      </QueryClientProvider>
    );

    // Fill out the basic required fields
    await user.type(screen.getByLabelText(/Technique Name/i), 'New Test Technique');
    await user.type(screen.getByLabelText(/Description/i), 'New test description');
    
    // Navigate to the Classification tab
    await user.click(screen.getByRole('tab', { name: /Classification/i }));
    
    // Select an assurance goal (multi-select)
    const assuranceGoalSelect = screen.getByLabelText(/Assurance Goals/i);
    await user.selectOptions(assuranceGoalSelect, ['1']); // Select 'Accuracy'
    
    // Select a category
    const categorySelect = screen.getByLabelText(/Categories/i);
    await user.selectOptions(categorySelect, ['1']); // Select 'Testing'
    
    // Submit the form
    await user.click(screen.getByText('Create Technique'));
    
    // Check for loading state
    await waitFor(() => {
      expect(screen.getByText('Creating...')).toBeInTheDocument();
    });
  });

  it('handles browser back navigation', async () => {
    render(
      <QueryClientProvider client={queryClient}>
        <TechniqueForm />
      </QueryClientProvider>
    );

    // Click the back button
    await user.click(screen.getByText('Back'));
    
    // Check that router.back was called
    expect(backMock).toHaveBeenCalled();
  });
});
</file>

<file path="dev.sh">
#!/bin/bash

# This script starts both frontend and backend in development mode

# Function to clean up on exit
cleanup() {
  echo "Stopping all processes..."
  kill $BACKEND_PID $FRONTEND_PID 2>/dev/null
  exit 0
}

# Setup trap for clean exit
trap cleanup SIGINT SIGTERM

# Check if Python virtual environment is active
if [ -z "$VIRTUAL_ENV" ]; then
  echo "Activating Python virtual environment..."
  if [ -d ".venv" ]; then
    source .venv/bin/activate
  else
    echo "No .venv directory found. Running poetry env use to create it..."
    poetry env use python
    source $(poetry env info --path)/bin/activate
  fi
else
  echo "Virtual environment already active: $VIRTUAL_ENV"
fi

# Start Django backend in the background
echo "Starting Django backend server..."
cd backend
USE_SQLITE=True python manage.py runserver &
BACKEND_PID=$!
cd ..

# Wait a moment for backend to initialize
sleep 2

# Start Next.js frontend in the background
echo "Starting Next.js frontend..."
cd frontend
pnpm run dev --turbopack &
FRONTEND_PID=$!
cd ..

echo "Development environment running."
echo "Backend: http://localhost:8000"
echo "Frontend: http://localhost:3000"
echo "Press Ctrl+C to stop all services."

# Wait for all background processes to finish
wait
</file>

<file path="update-nginx.sh">
#!/bin/bash
# update-nginx.sh - Update Nginx configuration without restarting the server

set -e  # Exit on any error

# Make the script executable
chmod +x $0

# Load environment variables
if [ -f .env.tailscale ]; then
  set -a
  source .env.tailscale
  set +a
else
  echo "WARNING: .env.tailscale file not found. Using default values."
fi

echo "Updating Nginx configuration for Tea Techniques..."
echo "=================================================="

# Check if nginx directory exists, if not create it
if [ ! -d nginx ]; then
  echo "Creating nginx directory..."
  mkdir -p nginx
fi

# Check if template exists
if [ ! -f nginx/tea-techniques.conf.template ]; then
  echo "ERROR: Nginx configuration template not found at nginx/tea-techniques.conf.template"
  exit 1
fi

# Generate the new configuration file
echo "1. Generating new Nginx configuration from template..."
if [ -f nginx/tea-techniques.conf ]; then
  # Backup existing configuration
  cp nginx/tea-techniques.conf nginx/tea-techniques.conf.bak
  echo "   Backed up existing configuration to nginx/tea-techniques.conf.bak"
fi

# Use envsubst to replace environment variables in the template
envsubst < nginx/tea-techniques.conf.template > nginx/tea-techniques.conf
echo "   Generated new configuration at nginx/tea-techniques.conf"

# Reload Nginx configuration by restarting the container
echo "2. Restarting Nginx container to apply changes..."
if docker-compose ps | grep -q nginx; then
  docker-compose restart nginx
  echo "   ✅ Nginx container restarted successfully"
else
  echo "   ❌ Nginx container is not running"
  echo "   Please start the container with: docker-compose up -d nginx"
  exit 1
fi

# Verify Nginx is running
echo "3. Verifying Nginx is running..."
if docker-compose ps | grep -q "nginx.*Up"; then
  echo "   ✅ Nginx container is running"
else
  echo "   ❌ Nginx container failed to start"
  echo "   Please check container logs with: docker-compose logs nginx"
  exit 1
fi

# Show Nginx status and logs
echo "4. Checking Nginx container logs (last 5 lines)..."
docker-compose logs --tail=5 nginx

echo ""
echo "Configuration updated successfully!"
echo "===================================="
echo "Your application should now correctly handle API requests."
echo ""
if [ -n "$TAILSCALE_DOMAIN" ]; then
  echo "To test the API directly, try:"
  echo "curl -v https://${TAILSCALE_DOMAIN}/api/"
  echo ""
  echo "To test the frontend with API integration:"
  echo "Visit https://${TAILSCALE_DOMAIN}/techniques/"
else
  echo "To test the API locally, try:"
  echo "curl -v http://localhost/api/"
  echo ""
  echo "To test the frontend with API integration:"
  echo "Visit http://localhost/techniques/"
fi
echo ""
echo "For debugging, check the Nginx logs:"
echo "docker-compose logs nginx"
</file>

<file path="backend/api/urls.py">
# api/urls.py

from django.urls import path, include, re_path
from rest_framework.routers import DefaultRouter
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework.reverse import reverse
from drf_yasg.views import get_schema_view
from drf_yasg import openapi
from rest_framework import permissions
from .views.api_views import (
    AssuranceGoalsViewSet,
    CategoryViewSet,
    SubCategoryViewSet,
    TagsViewSet,
    TechniquesViewSet,
    get_categorylist,
    get_subcategorylist,
    AttributeTypesViewSet,
    AttributeValuesViewSet,
    ResourceTypesViewSet,
    debug_endpoint,
    health_check,
)
from .views.auth_views import (
    get_csrf,
    login_view,
    logout_view,
    user_view,
    auth_status_view,
)


@api_view(["GET"])
def api_root(request, format=None):
    """
    API root providing links to all primary endpoints
    """
    return Response(
        {
            "assurance_goals": reverse(
                "assurancegoal-list", request=request, format=format
            ),
            "categories": reverse("category-list", request=request, format=format),
            "subcategories": reverse(
                "subcategory-list", request=request, format=format
            ),
            "tags": reverse("tag-list", request=request, format=format),
            "techniques": reverse("technique-list", request=request, format=format),
            "attribute_types": reverse(
                "attributetype-list", request=request, format=format
            ),
            "attribute_values": reverse(
                "attributevalue-list", request=request, format=format
            ),
            "resource_types": reverse(
                "resourcetype-list", request=request, format=format
            ),
            "health": reverse("health-check", request=request, format=format),
            "debug": reverse("debug-endpoint", request=request, format=format),
        }
    )


# Schema view for Swagger documentation
schema_view = get_schema_view(
    openapi.Info(
        title="TEA Techniques API",
        default_version="v1",
        description="API for Trustworthy and Ethical Assurance (TEA) Techniques",
        terms_of_service="https://www.yourapp.com/terms/",
        contact=openapi.Contact(email="contact@yourapp.com"),
        license=openapi.License(name="BSD License"),
    ),
    public=True,
    permission_classes=(permissions.AllowAny,),
)

router = DefaultRouter(trailing_slash=False)
router.register(r"assurance-goals", AssuranceGoalsViewSet)
router.register(r"categories", CategoryViewSet)
router.register(r"subcategories", SubCategoryViewSet)
router.register(r"tags", TagsViewSet)
router.register(r"techniques", TechniquesViewSet)
router.register(r"attribute-types", AttributeTypesViewSet)
router.register(r"attribute-values", AttributeValuesViewSet)
router.register(r"resource-types", ResourceTypesViewSet)

urlpatterns = [
    path("health/", health_check, name="health-check"),
    path("debug", debug_endpoint, name="debug-endpoint"),
    path("debug/", debug_endpoint, name="debug-endpoint-slash"),
    path("", api_root, name="api-root"),
    path("", include(router.urls)),
    path(
        "categories-by-goal/<int:assurance_goal_id>",
        get_categorylist,
        name="categories-by-goal",
    ),
    path(
        "subcategories-by-category/<int:category_id>",
        get_subcategorylist,
        name="subcategories-by-category",
    ),
    # Authentication - DRF's built-in auth views
    path("auth/", include("rest_framework.urls")),
    # Custom auth endpoints
    path("auth/csrf", get_csrf, name="get-csrf"),
    path("auth/login", login_view, name="login"),
    path("auth/logout", logout_view, name="logout"),
    path("auth/user", user_view, name="user"),
    path("auth/status", auth_status_view, name="auth-status"),
    # Swagger documentation
    re_path(
        r"^swagger(?P<format>\.json|\.yaml)$",
        schema_view.without_ui(cache_timeout=0),
        name="schema-json",
    ),
    re_path(
        r"^swagger$",
        schema_view.with_ui("swagger", cache_timeout=0),
        name="schema-swagger-ui",
    ),
    # Also keep trailing slash versions for backward compatibility
    re_path(
        r"^swagger/$",
        schema_view.with_ui("swagger", cache_timeout=0),
        name="schema-swagger-ui-slash",
    ),
    re_path(
        r"^redoc$", schema_view.with_ui("redoc", cache_timeout=0), name="schema-redoc"
    ),
    re_path(
        r"^redoc/$",
        schema_view.with_ui("redoc", cache_timeout=0),
        name="schema-redoc-slash",
    ),
]
</file>

<file path="backend/entrypoint.sh">
#!/bin/bash
set -e

# Determine which settings module we're using
DEFAULT_SETTINGS="config.settings.docker"
SETTINGS_MODULE=${DJANGO_SETTINGS_MODULE:-$DEFAULT_SETTINGS}
echo "Using settings module: $SETTINGS_MODULE"

# Check if we're using PostgreSQL (default) or SQLite
if [[ "$SETTINGS_MODULE" == *"sqlite"* ]]; then
    echo "Using SQLite database"
    
    # Ensure the db_data directory exists
    mkdir -p /app/db_data
else
    # Wait for PostgreSQL database
    echo "Checking PostgreSQL database connection..."
    max_retries=30
    retry_count=0

    while [ $retry_count -lt $max_retries ]; do
        if PGPASSWORD=$DB_PASSWORD psql -h "$DB_HOST" -U "$DB_USER" -d "$DB_NAME" -c "\q" 2>/dev/null; then
            echo "✅ PostgreSQL is up - executing command"
            break
        fi
        
        retry_count=$((retry_count+1))
        echo "⏳ Waiting for PostgreSQL... (attempt $retry_count of $max_retries)"
        sleep 2
        
        if [ $retry_count -eq $max_retries ]; then
            echo "❌ Failed to connect to PostgreSQL after $max_retries attempts!"
            echo "⚠️  Continuing startup anyway, but application may fail!"
        fi
    done
fi

# Collect static files (no input in case it asks)
echo "Collecting static files..."
python manage.py collectstatic --noinput

# Run migrations 
echo "Running migrations..."
python manage.py migrate --noinput

# Import techniques from JSON if file exists and database is empty
JSON_FILE="data/techniques.json"
if [ -f "$JSON_FILE" ]; then
    echo "Checking for existing techniques..."
    TECHNIQUE_COUNT=$(python -c "from api.models import Technique; print(Technique.objects.count())" 2>/dev/null || echo "0")
    
    if [ "$TECHNIQUE_COUNT" = "0" ]; then
        echo "No techniques found in database, importing from $JSON_FILE..."
        # Use the standard JSON import command
        python manage.py import_techniques --file="$JSON_FILE" || {
            echo "⚠️  Warning: Could not import techniques from JSON."
            echo "Please check the file format and the import script logs."
        }
    else
        echo "✅ Database already contains $TECHNIQUE_COUNT techniques, skipping import."
    fi
else
    echo "⚠️  No $JSON_FILE found, skipping technique import."
fi

# Set worker count based on environment variables or available cores
WORKERS=${GUNICORN_WORKERS:-2}
echo "Starting Gunicorn with $WORKERS workers..."

# Start server with Gunicorn
exec gunicorn config.wsgi:application \
    --bind 0.0.0.0:8000 \
    --workers $WORKERS \
    --timeout 180 \
    --forwarded-allow-ips="*" \
    --access-logfile - \
    --error-logfile -
</file>

<file path="docs/DATA-MANAGEMENT.md">
# Data Management Guide

> [!NOTE] Overview
> This project uses a JSON file, `techniques.json`, located in `backend/data/` to store technique data.
>
> For a comprehensive understanding of how data is structured, please refer to the [Model Architecture](MODEL-ARCHITECTURE.md) documentation.

## Adding or Modifying Techniques

1. Edit the `techniques.json` file directly in `backend/data/`
2. For local development:
   - To reset the database and import techniques: `USE_SQLITE=True python manage.py reset_and_import_techniques`
   - To only import techniques without resetting: `USE_SQLITE=True python manage.py import_techniques`
3. For Docker deployments, rebuild and restart the containers: `docker compose down && docker compose up -d --build`

> [!WARNING]
> The `reset_database` command will completely reset the database. Use with caution.

## Schema Information

The JSON file includes the following key fields:

- `id`: Technique ID
- `name`: Technique name
- `description`: Technique description
- `model_dependency`: Model dependency type (i.e. agnostic or specific)
- `assurance_goals`: Array of assurance goals to which the technique belongs
- `category_tags`: String containing category tags in format "#category/subcategory"
- `attributes`: Array of attributes for the technique (e.g. `{"type": "Scope", "value": "local"}`)
- `example_use_cases`: Array of example use cases for the technique
- `limitations`: Array of limitations for the technique
- `resources`: Array of resources for the technique (e.g. journal article or GitHub repository)
- `complexity_rating`: a numeric value (1–5) representing the complexity of the technique
- `computational_cost_rating`: a numeric value (1–5) representing the computational cost of the technique

> [!TIP]
> A full schema definition can be found in `backend/data/techniques_schema.json`

## Related Documentation

- [Model Architecture](MODEL-ARCHITECTURE.md) - Detailed information about the data model
- [API Guide](API-GUIDE.md) - How the data is exposed through the API
- [User Guide](USER-GUIDE.md) - How users interact with the data
- [Glossary](GLOSSARY.md) - Definitions of terms used in the data
</file>

<file path="docs/DEPLOYMENT.md">
# Deployment Guide

> [!NOTE] Overview
> This document outlines deployment options for the TEA Techniques application.
>
> For Tailscale-specific deployment, see the [Tailscale Deployment Guide](TAILSCALE-DEPLOYMENT.md).

## Local Development

> [!TIP]
> To run the application locally:
>
> ```bash
> # Backend
> cd backend
> poetry install
> python manage.py runserver
>
> # Frontend
> cd frontend
> pnpm install
> pnpm run dev --turbopack
> ```

## Docker Deployment (Local)

> [!TIP]
> For a production-like environment using Docker:
>
> ```bash
> # Build and run with Docker Compose
> docker-compose up --build
> ```

## Cloud Deployment (AWS, Azure, etc.)

> [!IMPORTANT]
> For cloud deployments, the key considerations are:
>
> 1. **API URLs**: Set the appropriate `NEXT_PUBLIC_API_URL` environment variable during build or runtime
>
> 2. **Reverse Proxy**: Configure a reverse proxy (like Nginx, AWS Application Load Balancer, etc.) to route requests properly:
>
>    - Frontend: `/` → Frontend service
>    - Backend: `/api/*` → Backend service
>    - Admin: `/admin/*` → Backend service
>    - Static: `/static/*` → Backend service
>    - Swagger: `/swagger/*` → Backend service
>
> 3. **Environment Variables**: Create appropriate `.env` files or use cloud provider's environment variable features

## Troubleshooting

### API Connection Issues

> [!WARNING]
> If the frontend can load but API calls fail:
>
> 1. Check browser console for errors
> 2. Verify the `NEXT_PUBLIC_API_URL` environment variable is correctly set
> 3. Ensure your reverse proxy is correctly routing `/api/*` paths to the backend service
> 4. Check CORS settings in the backend's `ALLOWED_HOSTS` and `CORS_ALLOWED_ORIGINS`

## Related Documentation

- [Tailscale Deployment Guide](TAILSCALE-DEPLOYMENT.md) - Guide for Tailscale-specific deployment
- [Development Workflow](DEVELOPMENT-WORKFLOW.md) - Local development setup
- [API Guide](API-GUIDE.md) - API endpoints that need to be configured for routing
- [Model Architecture](MODEL-ARCHITECTURE.md) - Database considerations for deployment
</file>

<file path="docs/DEVELOPMENT-WORKFLOW.md">
# Development Workflow

> [!NOTE] Overview
> This guide covers the recommended development workflow for the TEA Techniques project, including environment setup, tools, and best practices.

## Development Environment

### Prerequisites

- Python 3.12+
- Node.js 20+
- pnpm (or npm)
- SQLite
- Docker (optional, for containerised development)

### Editor Setup

#### VSCode (Recommended)

Recommended extensions:

- ESLint
- Prettier
- Python
- Django
- Tailwind CSS IntelliSense
- Docker

Workspace settings:

```json
{
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  },
  "python.linting.enabled": true,
  "python.linting.pylintEnabled": true,
  "python.formatting.provider": "black"
}
```

### Environment Variables

Create `.env` files in the project root and in the backend and frontend directories (copy from the respective `.env.example` files):

**Project Root `.env`**:
```
# Backend settings
SECRET_KEY=your-secret-key
DJANGO_SETTINGS_MODULE=config.settings.development

# Database settings (for PostgreSQL)
DB_NAME=techniques
DB_USER=postgres
DB_PASSWORD=postgres
DB_HOST=localhost
DB_PORT=5432

# Frontend settings
NEXT_PUBLIC_API_URL=/api
NEXT_PUBLIC_SWAGGER_URL=/swagger/
BACKEND_URL=http://localhost:8000
```

**Backend `.env`**:
```
# Django configuration
SECRET_KEY=your-secret-key
DJANGO_SETTINGS_MODULE=config.settings.development

# Database settings
DB_NAME=techniques
DB_USER=postgres
DB_PASSWORD=postgres
DB_HOST=localhost
DB_PORT=5432
```

**Frontend `.env`**:
```
# Public variables
NEXT_PUBLIC_API_URL=/api
NEXT_PUBLIC_SWAGGER_URL=/swagger/

# Server-side variables
BACKEND_URL=http://localhost:8000
```

## Project Structure

Key directories to be aware of:

```
tea-techniques/
├── backend/              # Django backend
│   ├── api/              # Main Django app
│   ├── config/           # Django settings
│   ├── data/             # Data files
│   └── manage.py         # Django management script
├── frontend/             # Next.js frontend
│   ├── src/
│   │   ├── app/          # Next.js pages
│   │   ├── components/   # React components
│   │   └── lib/          # Utilities
├── docs/                 # Documentation
└── docker-compose.yml    # Docker configuration
```

## Local Development Setup

### Backend Setup

1. Navigate to the backend directory:

   ```bash
   cd backend
   ```

2. Install dependencies using Poetry:

   ```bash
   poetry install
   ```

3. Initialize the database:

   ```bash
   python manage.py reset_and_import_techniques
   ```

4. Run the development server:

   ```bash
   poetry run python manage.py runserver
   ```

5. The API will be available at http://localhost:8000/api/

### Frontend Setup

1. Navigate to the frontend directory:

   ```bash
   cd frontend
   ```

2. Install dependencies:

   ```bash
   pnpm install
   # or
   npm install
   ```

3. Run the development server:

   ```bash
   pnpm run dev:turbo
   # or
   npm run dev --turbopack
   ```

4. The frontend will be available at http://localhost:3000

### Docker Setup (Alternative)

For a production-like environment:

```bash
docker compose up -d
```

This will start the backend, frontend, and PostgreSQL database containers.

## Development Workflow

### 1. Feature Branch Workflow

Always create a feature branch for your work:

```bash
git checkout -b feature/your-feature-name
```

### 2. TDD Approach (Test-Driven Development)

For new features:

1. Write tests first
2. Implement the feature
3. Verify tests pass
4. Refactor as needed

### 3. Running Tests

#### Backend Tests

```bash
cd backend
poetry run pytest
```

For specific tests:

```bash
poetry run pytest api/tests/test_file.py::TestClass::test_method
```

With coverage report:

```bash
poetry run pytest --cov=api
```

#### Frontend Tests

```bash
cd frontend
npm run test
```

Watch mode for development:

```bash
npm run test:watch
```

### 4. Code Style and Linting

#### Backend

```bash
cd backend
poetry run black .
poetry run isort .
poetry run pylint api
```

#### Frontend

```bash
cd frontend
npm run lint
```

### 5. API Development

For backend API development:

1. Define models in `backend/api/models.py`
2. Create serializers in `backend/api/serializers.py`
3. Set up views in `backend/api/views/api_views.py`
4. Configure routes in `backend/api/urls.py`
5. Write tests in `backend/api/tests/`

### 6. Frontend Development

For frontend development:

1. Create or modify components in `frontend/src/components/`
2. Update pages in `frontend/src/app/`
3. Add API hooks in `frontend/src/lib/api/hooks.ts`
4. Add types in `frontend/src/lib/types.ts`
5. Write tests in `frontend/tests/`

### 7. Data Management

For updating technique data:

1. Edit JSON file in `backend/data/`
2. Import data using management commands:
   ```bash
   # For development with standard PostgreSQL database
   python manage.py import_techniques
   
   # For SQLite development (if needed)
   DJANGO_SETTINGS_MODULE=config.settings.sqlite python manage.py import_techniques
   ```

## Common Development Tasks

### Adding a New Model

1. Define the model in `backend/api/models.py`
2. Create migrations: `python manage.py makemigrations`
3. Apply migrations: `python manage.py migrate`
4. Create a serializer in `backend/api/serializers.py`
5. Add ViewSet in `backend/api/views/api_views.py`
6. Register routes in `backend/api/urls.py`

### Adding a New API Endpoint

1. Create a view function or ViewSet in `backend/api/views/api_views.py`
2. Register the URL in `backend/api/urls.py`
3. Update Swagger documentation if needed

### Adding a New Frontend Page

1. Create a new directory in `frontend/src/app/`
2. Add a `page.tsx` file with your page component
3. Update navigation if needed

### Adding a New Component

1. Create a new file in the appropriate subdirectory of `frontend/src/components/`
2. Implement the component using TypeScript and React
3. Add tests in `frontend/tests/`

## Debugging Tips

### Backend Debugging

1. Use `import pdb; pdb.set_trace()` to set breakpoints
2. Use the Django Debug Toolbar for analyzing queries
3. Check logs in `backend/logs/`

### Frontend Debugging

1. Use the React Developer Tools browser extension
2. Use `console.log()` for basic debugging
3. Use the Network tab to debug API calls
4. Use the React Query Devtools for understanding query state

## Performance Considerations

### Backend Performance

1. Use `select_related()` and `prefetch_related()` to optimize queries
2. Add database indexes for frequently queried fields
3. Use Django's caching framework for expensive operations

### Frontend Performance

1. Use React.memo() for expensive components
2. Leverage React Query's caching system
3. Use pagination for large datasets
4. Optimize images and assets

## Deployment

See the [Deployment Guide](DEPLOYMENT.md) for detailed deployment instructions.

## Troubleshooting

### Common Issues

#### Backend

- **Migration errors**: Try `python manage.py makemigrations` followed by `python manage.py migrate`
- **Import errors**: Check that all required packages are installed in your Poetry environment
- **Database errors**: Check connection settings in `.env` or settings files
- **Settings module errors**: Ensure `DJANGO_SETTINGS_MODULE` is set correctly (e.g., `config.settings.development`)

#### Frontend

- **Build errors**: Check for TypeScript errors or missing dependencies
- **API connection issues**: Verify API URL in environment variables
- **Component errors**: Check React component props and types

## Related Links

- [Contributing Guide](CONTRIBUTING.md)
- [Testing Guide](TESTING.md)
- [Model Architecture](MODEL-ARCHITECTURE.md)
- [Frontend Guide](FRONTEND-GUIDE.md)
</file>

<file path="frontend/src/app/about/page.tsx">
// src/app/about/page.tsx
import Link from "next/link";
import MainLayout from "@/components/layout/MainLayout";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { PrismCodeBlock as CodeBlock } from "@/components/ui/prism-code-block";
import { ArrowRight, BookOpen, Code, Layers, Users, Zap } from "lucide-react";

export default function AboutPage() {
	return (
		<MainLayout>
			<div className="space-y-8 max-w-4xl mx-auto">
				<div>
					<h1 className="text-3xl font-bold mb-4">
						About TEA Techniques
					</h1>
					<p className="text-muted-foreground text-lg">
						A platform for exploring techniques for evidencing
						claims about responsible design, development, and
						deployment of data-driven technologies.
					</p>
				</div>

				<Tabs defaultValue="project-info" className="w-full">
					<TabsList className="mb-6">
						<TabsTrigger value="project-info" className="flex items-center gap-2">
							<BookOpen className="h-4 w-4" />
							Project Information
						</TabsTrigger>
						<TabsTrigger value="developer-instructions" className="flex items-center gap-2">
							<Code className="h-4 w-4" />
							Developer Instructions
						</TabsTrigger>
						<TabsTrigger value="community-contributions" className="flex items-center gap-2">
							<Users className="h-4 w-4" />
							Community Contributions
						</TabsTrigger>
					</TabsList>

					<TabsContent
						value="project-info"
						className="space-y-8 py-4"
					>
						<section>
							<h2 className="text-2xl font-bold mb-4 flex items-center gap-2">
								<BookOpen className="h-6 w-6 text-primary" />
								Project Overview
							</h2>
							<div className="prose max-w-none bg-card rounded-lg p-6 border shadow-sm">
								<p>
									The TEA Techniques Database is an interactive repository designed to work in conjunction with the
									<a href="https://assuranceplatform.azurewebsites.net/" className="text-primary hover:underline"> Trustworthy and Ethical Assurance (TEA) platform</a> as
									a core plugin to enable practitioners to identify and implement appropriate assurance methods.
								</p>
								<br />
								<p>
									This database provides a structured way to explore and understand various techniques for evidencing
									claims about responsible AI design, development, and deployment. By organizing techniques by assurance
									goals, categories, and subcategories, it helps practitioners find exactly what they need for their
									specific use cases.
								</p>
							</div>
						</section>

						<section>
							<h2 className="text-2xl font-bold mb-4 flex items-center gap-2">
								<Zap className="h-6 w-6 text-primary" />
								Key Features
							</h2>
							<div className="prose max-w-none bg-card rounded-lg p-6 border shadow-sm">
								<ul className="space-y-3">
									<li className="flex items-start gap-2">
										<ArrowRight className="h-5 w-5 text-primary flex-shrink-0 mt-0.5" />
										<div>
											<strong>Structured Documentation</strong>: Each technique includes comprehensive information about its purpose, implementation details, and practical use cases.
										</div>
									</li>
									<li className="flex items-start gap-2">
										<ArrowRight className="h-5 w-5 text-primary flex-shrink-0 mt-0.5" />
										<div>
											<strong>Categorized Organization</strong>: Techniques are organized by assurance goals, categories, and subcategories to help you find exactly what you need.
										</div>
									</li>
									<li className="flex items-start gap-2">
										<ArrowRight className="h-5 w-5 text-primary flex-shrink-0 mt-0.5" />
										<div>
											<strong>API Access</strong>: Access all data through a comprehensive REST API with documentation via Swagger.
										</div>
									</li>
									<li className="flex items-start gap-2">
										<ArrowRight className="h-5 w-5 text-primary flex-shrink-0 mt-0.5" />
										<div>
											<strong>Model Agnostic & Specific</strong>: Browse techniques that work across different model types or that are designed for specific model architectures.
										</div>
									</li>
								</ul>
							</div>
						</section>
					</TabsContent>

					<TabsContent
						value="developer-instructions"
						className="space-y-8 py-4"
					>
						<section>
							<h2 className="text-2xl font-bold mb-4 flex items-center gap-2">
								<Code className="h-6 w-6 text-primary" />
								Development Setup
							</h2>
							<div className="bg-card rounded-lg border shadow-sm p-6 space-y-6">
								<div className="space-y-2">
									<h3 className="text-lg font-semibold flex items-center gap-2">
										<Zap className="h-5 w-5 text-primary" />
										Prerequisites
									</h3>
									<p className="text-muted-foreground mb-2">
										This project uses Poetry for Python dependency management. If you don&apos;t have Poetry installed:
									</p>
									<CodeBlock
										language="bash"
										code={`# On Linux, macOS, Windows (WSL)
curl -sSL https://install.python-poetry.org | python3 -

# On Windows (PowerShell)
(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | python -`}
									/>
								</div>

								<div className="space-y-2">
									<h3 className="text-lg font-semibold flex items-center gap-2">
										<Layers className="h-5 w-5 text-primary" />
										SQLite Setup (Quick Start for Development)
									</h3>
									<ol className="mt-4">
										<li className="rounded-lg p-4">
											<div className="flex items-center gap-3 mb-2">
												<span className="flex items-center justify-center bg-primary text-primary-foreground rounded-full w-6 h-6 text-sm font-bold">1</span>
												<strong className="text-primary">Clone the repository</strong>
											</div>
											<CodeBlock
												language="bash"
												code={`git clone https://github.com/chrisdburr/tea-techniques.git
cd tea-techniques`}
											/>
										</li>
										<li className="rounded-lg p-4">
											<div className="flex items-center gap-3 mb-2">
												<span className="flex items-center justify-center bg-primary text-primary-foreground rounded-full w-6 h-6 text-sm font-bold">2</span>
												<strong className="text-primary">Setup environment variable</strong>
											</div>
											<CodeBlock
												language="bash"
												code={`cp .env.example .env`}
											/>
											<p className="text-sm text-muted-foreground mt-2">You may want to review and adjust the values in the <code>.env</code> file (e.g. change user and password)</p>
										</li>
										<li className="rounded-lg p-4">
											<div className="flex items-center gap-3 mb-2">
												<span className="flex items-center justify-center bg-primary text-primary-foreground rounded-full w-6 h-6 text-sm font-bold">3</span>
												<strong className="text-primary">Set up the backend</strong>
											</div>
											<CodeBlock
												language="bash"
												code={`cd backend
poetry install
USE_SQLITE=True python manage.py reset_and_import_techniques`}
											/>
										</li>
										<li className="rounded-lg p-4">
											<div className="flex items-center gap-3 mb-2">
												<span className="flex items-center justify-center bg-primary text-primary-foreground rounded-full w-6 h-6 text-sm font-bold">4</span>
												<strong className="text-primary">Run the backend with SQLite</strong>
											</div>
											<CodeBlock
												language="bash"
												code={`USE_SQLITE=True poetry run python manage.py runserver`}
											/>
										</li>
										<li className="rounded-lg p-4">
											<div className="flex items-center gap-3 mb-2">
												<span className="flex items-center justify-center bg-primary text-primary-foreground rounded-full w-6 h-6 text-sm font-bold">5</span>
												<strong className="text-primary">In a new terminal, set up and run the frontend</strong>
											</div>
											<CodeBlock
												language="bash"
												code={`cd frontend
npm install
npm run dev --turbopack`}
											/>
										</li>
										<li className="rounded-lg p-4">
											<div className="flex items-center gap-3 mb-2">
												<span className="flex items-center justify-center bg-primary text-primary-foreground rounded-full w-6 h-6 text-sm font-bold">6</span>
												<strong className="text-primary">Access the application</strong>
											</div>
											<ul className="mt-2 space-y-1">
												<li className="flex items-center gap-2">
													<ArrowRight className="h-5 w-5 text-primary flex-shrink-0 mt-0.5" />
													<span className="bg-muted px-2 py-1 rounded text-primary font-mono">Frontend:</span>
													<code className="text-primary">http://localhost:3000</code>
												</li>
												<li className="flex items-center gap-2">
													<ArrowRight className="h-5 w-5 text-primary flex-shrink-0 mt-0.5" />
													<span className="bg-muted px-2 py-1 rounded text-primary font-mono">API:</span>
													<code className="text-primary">http://localhost:8000/api/</code>
												</li>
												<li className="flex items-center gap-2">
													<ArrowRight className="h-5 w-5 text-primary flex-shrink-0 mt-0.5" />
													<span className="bg-muted px-2 py-1 rounded text-primary font-mono">Admin:</span>
													<code className="text-primary">http://localhost:8000/admin/</code>
												</li>
											</ul>
										</li>
									</ol>
								</div>
							</div>
						</section>

						<section>
							<h2 className="text-2xl font-bold mb-4 flex items-center gap-2">
								<Layers className="h-6 w-6 text-primary" />
								Project Structure
							</h2>
							<div className="bg-card rounded-lg border shadow-sm p-6 space-y-6">
								<div className="grid grid-cols-1 md:grid-cols-2 gap-6">
									<div className="space-y-4">
										<h3 className="text-lg font-semibold flex items-center gap-2">
											<ArrowRight className="h-5 w-5 text-primary" />
											Backend
										</h3>
										<p className="text-muted-foreground mb-2">Django with Django REST Framework</p>
										<ul className="space-y-2 text-sm">
											<li className="flex items-start gap-2">
												<code className="bg-muted px-2 py-1 rounded text-primary font-mono min-w-32">backend/api</code>
												<span>Main Django app</span>
											</li>
											<li className="flex items-start gap-2">
												<code className="bg-muted px-2 py-1 rounded text-primary font-mono min-w-32">backend/config</code>
												<span>Django project settings</span>
											</li>
											<li className="flex items-start gap-2">
												<code className="bg-muted px-2 py-1 rounded text-primary font-mono min-w-32">backend/data</code>
												<span>JSON file and schema for techniques</span>
											</li>
										</ul>
									</div>
									<div className="space-y-4">
										<h3 className="text-lg font-semibold flex items-center gap-2">
											<ArrowRight className="h-5 w-5 text-primary" />
											Frontend
										</h3>
										<p className="text-muted-foreground mb-2">Next.js with TypeScript and Tailwind CSS</p>
										<ul className="space-y-2 text-sm">
											<li className="flex items-start gap-2">
												<code className="bg-muted px-2 py-1 rounded text-primary font-mono min-w-32">frontend/src/app</code>
												<span>Next.js pages and routes</span>
											</li>
											<li className="flex items-start gap-2">
												<code className="bg-muted px-2 py-1 rounded text-primary font-mono min-w-32">frontend/src/components</code>
												<span>Reusable React components</span>
											</li>
											<li className="flex items-start gap-2">
												<code className="bg-muted px-2 py-1 rounded text-primary font-mono min-w-32">frontend/src/lib</code>
												<span>Utilities, types, and API clients</span>
											</li>
										</ul>
									</div>
								</div>
							</div>
						</section>

						<section>
							<h2 className="text-2xl font-bold mb-4 flex items-center gap-2">
								<Zap className="h-6 w-6 text-primary" />
								Testing
							</h2>
							<div className="bg-card rounded-lg border shadow-sm p-6 space-y-6">
								<p className="mb-4">
									The project includes a comprehensive testing setup for both the frontend and backend.
								</p>

								<div className="grid grid-cols-1 md:grid-cols-2 gap-6">
									<div className="space-y-4">
										<h3 className="text-lg font-semibold flex items-center gap-2">
											<ArrowRight className="h-5 w-5 text-primary" />
											Frontend Testing
										</h3>
										<p className="text-muted-foreground mb-2">
											The frontend uses Jest and React Testing Library for component testing. To run tests:
										</p>
										<CodeBlock
											language="bash"
											code={`cd frontend
npm test`}
										/>
									</div>

									<div className="space-y-4">
										<h3 className="text-lg font-semibold flex items-center gap-2">
											<ArrowRight className="h-5 w-5 text-primary" />
											Backend Testing
										</h3>
										<p className="text-muted-foreground mb-2">
											The backend uses Django&apos;s testing framework. To run tests:
										</p>
										<CodeBlock
											language="bash"
											code={`cd backend
python manage.py test`}
										/>
									</div>
								</div>
							</div>
						</section>
					</TabsContent>

					<TabsContent
						value="community-contributions"
						className="space-y-8 py-4"
					>
						<section>
							<h2 className="text-2xl font-bold mb-4 flex items-center gap-2">
								<Users className="h-6 w-6 text-primary" />
								How to Contribute
							</h2>
							<div className="bg-card rounded-lg border shadow-sm p-6">
								<p className="mb-4">
									Contributions to the TEA Techniques Database are welcome! Here&apos;s how you can contribute:
								</p>
								<ol className="space-y-4">
									<li className="flex gap-3 items-start">
										<span className="flex items-center justify-center bg-primary text-primary-foreground rounded-full w-6 h-6 text-sm font-bold mt-0.5">1</span>
										<div>
											<strong className="text-primary">Fork the repository on GitHub</strong>
										</div>
									</li>
									<li className="flex gap-3 items-start">
										<span className="flex items-center justify-center bg-primary text-primary-foreground rounded-full w-6 h-6 text-sm font-bold mt-0.5">2</span>
										<div className="flex-1">
											<strong className="text-primary">Create your feature branch</strong>
											<CodeBlock
												language="bash"
												code={`git checkout -b feature/amazing-feature`}
												className="mt-2"
											/>
										</div>
									</li>
									<li className="flex gap-3 items-start">
										<span className="flex items-center justify-center bg-primary text-primary-foreground rounded-full w-6 h-6 text-sm font-bold mt-0.5">3</span>
										<div className="flex-1">
											<strong className="text-primary">Commit your changes</strong>
											<CodeBlock
												language="bash"
												code={`git commit -m 'Add some amazing feature'`}
												className="mt-2"
											/>
										</div>
									</li>
									<li className="flex gap-3 items-start">
										<span className="flex items-center justify-center bg-primary text-primary-foreground rounded-full w-6 h-6 text-sm font-bold mt-0.5">4</span>
										<div className="flex-1">
											<strong className="text-primary">Push to the branch</strong>
											<CodeBlock
												language="bash"
												code={`git push origin feature/amazing-feature`}
												className="mt-2"
											/>
										</div>
									</li>
									<li className="flex gap-3 items-start">
										<span className="flex items-center justify-center bg-primary text-primary-foreground rounded-full w-6 h-6 text-sm font-bold mt-0.5">5</span>
										<div>
											<strong className="text-primary">Open a Pull Request</strong>
											<p className="text-sm text-muted-foreground mt-2">
												Please ensure your code follows the project&apos;s coding standards and includes appropriate tests.
											</p>
										</div>
									</li>
								</ol>
							</div>
						</section>

						<section>
							<h2 className="text-2xl font-bold mb-4 flex items-center gap-2">
								<Zap className="h-6 w-6 text-primary" />
								Adding New Techniques
							</h2>
							<div className="bg-card rounded-lg border shadow-sm p-6">
								<p className="mb-4">
									The database of techniques can be expanded in several ways:
								</p>
								<ul className="space-y-4">
									<li className="flex items-start gap-2">
										<ArrowRight className="h-5 w-5 text-primary flex-shrink-0 mt-0.5" />
										<div>
											<strong>Through the UI</strong>: Once logged in with appropriate permissions, you can use the &ldquo;Add New Technique&quot; form.
										</div>
									</li>
									<li className="flex items-start gap-2">
										<ArrowRight className="h-5 w-5 text-primary flex-shrink-0 mt-0.5" />
										<div>
											<strong>Via JSON modifications</strong>: The backend includes a directory where the dataset is stored as a single JSON file, which can be re-imported.
										</div>
									</li>
									<li className="flex items-start gap-2">
										<ArrowRight className="h-5 w-5 text-primary flex-shrink-0 mt-0.5" />
										<div>
											<strong>API Endpoints</strong>: You can programmatically add techniques using the REST API.
										</div>
									</li>
								</ul>
								<p className="mt-4">
									When adding a new technique, please ensure you provide comprehensive information, including:
								</p>
								<ul className="mt-2 grid grid-cols-1 md:grid-cols-2 gap-2 pl-6 list-disc">
									<li>Clear name and description</li>
									<li>Relevant assurance goals and categories</li>
									<li>Implementation details</li>
									<li>Example use cases</li>
									<li>Limitations</li>
									<li>References or resources</li>
								</ul>
							</div>
						</section>

						<section>
							<h2 className="text-2xl font-bold mb-4 flex items-center gap-2">
								<Users className="h-6 w-6 text-primary" />
								Community Guidelines
							</h2>
							<div className="bg-card rounded-lg border shadow-sm p-6">
								<p className="mb-4">
									To maintain the quality and usefulness of the TEA Techniques Database, please follow these guidelines:
								</p>
								<ul className="space-y-3">
									<li className="flex items-start gap-2">
										<ArrowRight className="h-5 w-5 text-primary flex-shrink-0 mt-0.5" />
										<span>Provide accurate and verifiable information</span>
									</li>
									<li className="flex items-start gap-2">
										<ArrowRight className="h-5 w-5 text-primary flex-shrink-0 mt-0.5" />
										<span>Be respectful and constructive in discussions</span>
									</li>
									<li className="flex items-start gap-2">
										<ArrowRight className="h-5 w-5 text-primary flex-shrink-0 mt-0.5" />
										<span>Follow the code of conduct</span>
									</li>
									<li className="flex items-start gap-2">
										<ArrowRight className="h-5 w-5 text-primary flex-shrink-0 mt-0.5" />
										<span>Respect intellectual property rights</span>
									</li>
									<li className="flex items-start gap-2">
										<ArrowRight className="h-5 w-5 text-primary flex-shrink-0 mt-0.5" />
										<span>Use inclusive language</span>
									</li>
								</ul>
								<p className="mt-4">
									We aim to create a welcoming and productive community that advances the field of responsible AI development.
								</p>
							</div>
						</section>
					</TabsContent>
				</Tabs>

				<div className="flex justify-center py-6">
					<Button asChild size="lg" className="gap-2">
						<Link href="/techniques">
							Explore Techniques
							<ArrowRight className="h-4 w-4" />
						</Link>
					</Button>
				</div>
			</div>
		</MainLayout>
	);
}
</file>

<file path="frontend/src/components/technique/TechniqueForm.tsx">
// src/components/technique/TechniqueForm.tsx
import React, { useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import {
  useCreateTechnique,
  useUpdateTechnique,
  useAssuranceGoals,
  useCategories,
  useSubCategories,
  useTags,
  useResourceTypes,
  useTechniqueDetail,
} from "@/lib/api/hooks";
import {
  TechniqueFormData
} from "@/lib/types";
import { useApiError } from "@/lib/hooks/useApiError";
import { SelectField } from "@/components/common/SelectField";
import { useForm, Controller, SubmitHandler } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";

import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { PlusCircle, Trash2, ArrowLeft, Save } from "lucide-react";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";

// Initial form data
const initialFormData: TechniqueFormData = {
  name: "",
  description: "",
  model_dependency: "Model-Agnostic", // Default value
  assurance_goal_ids: [],
  category_ids: [],
  subcategory_ids: [],
  tag_ids: [],
  attributes: [],
  resources: [],
  example_use_cases: [],
  limitations: [],
};

// Zod schema for form validation
const techniqueSchema = z.object({
  name: z.string().min(1, { message: "Name is required" }),
  description: z.string().min(1, { message: "Description is required" }),
  model_dependency: z.string().min(1, { message: "Model dependency is required" }),
  assurance_goal_ids: z.array(z.number()).min(1, { message: "At least one assurance goal is required" }),
  category_ids: z.array(z.number()).min(1, { message: "At least one category is required" }),
  subcategory_ids: z.array(z.number()),
  tag_ids: z.array(z.number()),
  attributes: z.array(
    z.object({
      attribute_type: z.number(),
      attribute_value: z.number(),
    })
  ),
  resources: z.array(
    z.object({
      resource_type: z.number(),
      title: z.string(),
      url: z.string(),
      description: z.string(),
    })
  ),
  example_use_cases: z.array(
    z.object({
      description: z.string(),
      assurance_goal: z.number().optional(),
    })
  ),
  limitations: z.array(z.string()),
});

interface TechniqueFormProps {
  id?: number;
  isEditMode?: boolean;
}

export default function TechniqueForm({ id, isEditMode = false }: TechniqueFormProps) {
  const router = useRouter();

  // Form state management with react-hook-form
  const {
    control,
    handleSubmit: hookFormSubmit,
    formState: { errors, isSubmitting },
    setValue,
    reset,
    watch
  } = useForm<TechniqueFormData>({
    resolver: zodResolver(techniqueSchema),
    defaultValues: initialFormData,
    mode: "onBlur"
  });

  // Watch relevant fields for dependent selections
  const watchedAssuranceGoalIds = watch("assurance_goal_ids");
  const watchedCategoryIds = watch("category_ids");

  const { handleError } = useApiError();

  // State for dynamic arrays
  const [useCases, setUseCases] = useState<Array<{ description: string; assurance_goal?: number }>>([{ description: "" }]);
  const [limitations, setLimitations] = useState<string[]>([""]);
  const [resources, setResources] = useState<Array<{ resource_type: number; title: string; url: string; description: string }>>([
    { resource_type: 0, title: "", url: "", description: "" }
  ]);

  // Fetch technique details if in edit mode
  const { data: techniqueData, isLoading: isLoadingTechnique } = useTechniqueDetail(id || 0);

  // Fetch reference data
  const { data: assuranceGoalsData, isLoading: isLoadingGoals } = useAssuranceGoals();
  const { data: tagsData, isLoading: isLoadingTags } = useTags();
  const { data: resourceTypesData, isLoading: isLoadingResourceTypes } = useResourceTypes();

  // Fetch categories filtered by selected assurance goals
  const [selectedGoals, setSelectedGoals] = useState<number[]>([]);
  const { data: categoriesData, isLoading: isLoadingCategories } = useCategories();

  // Filter categories to only show those belonging to selected goals
  const filteredCategories = categoriesData?.results
    ? categoriesData.results.filter(cat =>
      selectedGoals.length === 0 || selectedGoals.includes(cat.assurance_goal)
    )
    : [];

  // Fetch subcategories filtered by selected categories
  const [selectedCategories, setSelectedCategories] = useState<number[]>([]);
  const { data: subcategoriesData } = useSubCategories();

  // Filter subcategories to only show those belonging to selected categories
  const filteredSubcategories = subcategoriesData?.results
    ? subcategoriesData.results.filter(subcat =>
      selectedCategories.length === 0 || selectedCategories.includes(subcat.category)
    )
    : [];

  // Mutations for create/update
  const createMutation = useCreateTechnique();
  const updateMutation = useUpdateTechnique(id || 0);

  // Track overall loading state
  const isLoading =
    isLoadingGoals ||
    isLoadingCategories ||
    isLoadingTags ||
    isLoadingResourceTypes ||
    (isEditMode && isLoadingTechnique) ||
    isSubmitting ||
    createMutation.isPending ||
    updateMutation.isPending;

  // Initialize form when editing
  useEffect(() => {
    if (isEditMode && techniqueData) {
      // Extract IDs from relationships
      const assurance_goal_ids = techniqueData.assurance_goals.map(goal => goal.id);
      const category_ids = techniqueData.categories.map(cat => cat.id);
      const subcategory_ids = techniqueData.subcategories.map(subcat => subcat.id);
      const tag_ids = techniqueData.tags.map(tag => tag.id);

      // Format attributes
      const attributes = techniqueData.attribute_values.map(attr => ({
        attribute_type: typeof attr.attribute_type === 'string'
          ? parseInt(attr.attribute_type)
          : attr.attribute_type,
        attribute_value: parseInt(attr.name) || 0 // Parse to number, default to 0 if NaN
      }));

      // Set state for dynamic arrays
      setUseCases(techniqueData.example_use_cases.length > 0
        ? techniqueData.example_use_cases.map(uc => ({
          description: uc.description,
          assurance_goal: uc.assurance_goal
        }))
        : [{ description: "" }]
      );

      setLimitations(techniqueData.limitations.length > 0
        ? techniqueData.limitations.map(lim => lim.description)
        : [""]
      );

      setResources(techniqueData.resources.length > 0
        ? techniqueData.resources.map(res => ({
          resource_type: res.resource_type,
          title: res.title,
          url: res.url,
          description: res.description
        }))
        : [{ resource_type: 0, title: "", url: "", description: "" }]
      );

      // Update form values using react-hook-form's reset
      reset({
        name: techniqueData.name,
        description: techniqueData.description,
        model_dependency: techniqueData.model_dependency,
        assurance_goal_ids,
        category_ids,
        subcategory_ids,
        tag_ids,
        attributes,
        resources: [], // Will be handled by resources state
        example_use_cases: [], // Will be handled by useCases state
        limitations: [], // Will be handled by limitations state
      });

      // Update selected goals/categories for filtering, directly instead of through effects
      setSelectedGoals([...assurance_goal_ids]); // Use a new array to prevent reference sharing
      setSelectedCategories([...category_ids]);
    }
  }, [isEditMode, techniqueData, reset]);

  // Make sure selectedGoals and selectedCategories are memoized based on watched fields
  // without creating effects that might cause infinite loops
  const memoizedSelectedGoals = React.useMemo(() => watchedAssuranceGoalIds, [watchedAssuranceGoalIds]);
  const memoizedSelectedCategories = React.useMemo(() => watchedCategoryIds, [watchedCategoryIds]);

  // Update selected goals/categories with memoized values - only runs once after memo values are computed
  React.useEffect(() => {
    // Use functional updates to avoid potential loops
    setSelectedGoals(() => memoizedSelectedGoals);
  }, [memoizedSelectedGoals]);

  React.useEffect(() => {
    // Use functional updates to avoid potential loops
    setSelectedCategories(() => memoizedSelectedCategories);
  }, [memoizedSelectedCategories]);

  // Handle form submission using react-hook-form
  const onSubmit: SubmitHandler<TechniqueFormData> = async (data) => {
    // Filter out empty entries from dynamic arrays
    const filteredUseCases = useCases.filter(uc => uc.description.trim() !== "");
    const filteredLimitations = limitations.filter(lim => lim.trim() !== "");
    const filteredResources = resources.filter(res => res.title.trim() !== "" && res.url.trim() !== "");

    // Create final form data
    const finalFormData: TechniqueFormData = {
      ...data,
      example_use_cases: filteredUseCases,
      limitations: filteredLimitations,
      resources: filteredResources,
    };

    try {
      if (isEditMode && id) {
        // Update existing technique
        await updateMutation.mutateAsync(finalFormData);
        router.push(`/techniques/${id}`);
      } else {
        // Create new technique
        const result = await createMutation.mutateAsync(finalFormData);
        // Add a null check to handle the case when result might be null
        if (result && result.id) {
          router.push(`/techniques/${result.id}`);
        } else {
          // Fallback if result or result.id is null
          router.push(`/techniques`);
          console.warn("Received null or invalid result from API");
        }
      }
    } catch (error) {
      console.error("Error submitting technique:", error);
      handleError(error);
    }
  };

  // Handle goal selection changes with react-hook-form
  const handleGoalChange = (values: string[]) => {
    try {
      // Use setValue from react-hook-form
      const goalIds = values.map(v => parseInt(v));
      setValue("assurance_goal_ids", goalIds, { shouldValidate: true });
    } catch (error) {
      console.error("Error in handleGoalChange:", error);
    }
  };

  // Handle category selection changes with react-hook-form
  const handleCategoryChange = (values: string[]) => {
    try {
      // Use setValue from react-hook-form
      const categoryIds = values.map(v => parseInt(v));
      setValue("category_ids", categoryIds, { shouldValidate: true });
    } catch (error) {
      console.error("Error in handleCategoryChange:", error);
    }
  };

  // Dynamic array management functions
  const addUseCase = () => {
    setUseCases([...useCases, { description: "" }]);
  };

  const updateUseCase = (index: number, field: keyof typeof useCases[0], value: string | number | undefined) => {
    const updated = [...useCases];
    updated[index] = { ...updated[index], [field]: value };
    setUseCases(updated);
  };

  const removeUseCase = (index: number) => {
    if (useCases.length > 1) {
      setUseCases(useCases.filter((_, i) => i !== index));
    } else {
      setUseCases([{ description: "" }]);
    }
  };

  const addLimitation = () => {
    setLimitations([...limitations, ""]);
  };

  const updateLimitation = (index: number, value: string) => {
    const updated = [...limitations];
    updated[index] = value;
    setLimitations(updated);
  };

  const removeLimitation = (index: number) => {
    if (limitations.length > 1) {
      setLimitations(limitations.filter((_, i) => i !== index));
    } else {
      setLimitations([""]);
    }
  };

  const addResource = () => {
    setResources([...resources, { resource_type: 0, title: "", url: "", description: "" }]);
  };

  const updateResource = (index: number, field: keyof typeof resources[0], value: string | number) => {
    const updated = [...resources];
    updated[index] = { ...updated[index], [field]: value };
    setResources(updated);
  };

  const removeResource = (index: number) => {
    if (resources.length > 1) {
      setResources(resources.filter((_, i) => i !== index));
    } else {
      setResources([{ resource_type: 0, title: "", url: "", description: "" }]);
    }
  };

  // Prepare options for select fields
  const assuranceGoalOptions = assuranceGoalsData?.results?.map(goal => ({
    value: goal.id.toString(),
    label: goal.name,
  })) || [];

  const categoryOptions = filteredCategories.map(category => ({
    value: category.id.toString(),
    label: category.name,
  }));

  const subcategoryOptions = filteredSubcategories.map(subcategory => ({
    value: subcategory.id.toString(),
    label: subcategory.name,
  }));

  const tagOptions = tagsData?.results?.map(tag => ({
    value: tag.id.toString(),
    label: tag.name,
  })) || [];

  const modelDependencyOptions = [
    { value: "Model-Agnostic", label: "Model-Agnostic" },
    { value: "Model-Specific", label: "Model-Specific" },
  ];

  const resourceTypeOptions = resourceTypesData?.results?.map(rt => ({
    value: rt.id.toString(),
    label: rt.name,
  })) || [];

  return (
    <div className="space-y-6 py-6">
      <div className="flex items-center justify-between">
        <div className="space-y-1">
          <h1 className="text-2xl font-bold">
            {isEditMode ? "Edit Technique" : "Create New Technique"}
          </h1>
          <p className="text-muted-foreground">
            {isEditMode
              ? "Update this technique with new information"
              : "Add a new technique to the collection"}
          </p>
        </div>
        <Button
          variant="outline"
          onClick={() => router.back()}
          disabled={isLoading}
        >
          <ArrowLeft className="mr-2 h-4 w-4" /> Back
        </Button>
      </div>

      <form onSubmit={hookFormSubmit(onSubmit)}>
        <Tabs defaultValue="basic" className="w-full">
          <TabsList className="grid grid-cols-4 mb-8">
            <TabsTrigger value="basic">Basic Information</TabsTrigger>
            <TabsTrigger value="classification">Classification</TabsTrigger>
            <TabsTrigger value="examples">Examples & Limitations</TabsTrigger>
            <TabsTrigger value="resources">Resources</TabsTrigger>
          </TabsList>

          {/* Basic Information Tab */}
          <TabsContent value="basic">
            <Card>
              <CardHeader>
                <CardTitle>Basic Information</CardTitle>
                <CardDescription>
                  Provide essential information about the technique
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-6">
                <div className="space-y-2">
                  <Label htmlFor="name">
                    Technique Name <span className="text-destructive">*</span>
                  </Label>
                  <Controller
                    name="name"
                    control={control}
                    render={({ field }) => (
                      <Input
                        id="name"
                        placeholder="Enter technique name"
                        disabled={isLoading}
                        {...field}
                      />
                    )}
                  />
                  {errors?.name && (
                    <p className="text-sm text-destructive">{errors.name.message}</p>
                  )}
                </div>

                <div className="space-y-2">
                  <Label htmlFor="description">
                    Description <span className="text-destructive">*</span>
                  </Label>
                  <Controller
                    name="description"
                    control={control}
                    render={({ field }) => (
                      <Textarea
                        id="description"
                        placeholder="Provide a detailed description of the technique"
                        rows={6}
                        disabled={isLoading}
                        {...field}
                      />
                    )}
                  />
                  {errors?.description && (
                    <p className="text-sm text-destructive">{errors.description.message}</p>
                  )}
                </div>

                <div className="space-y-2">
                  <Label htmlFor="model_dependency">
                    Model Dependency <span className="text-destructive">*</span>
                  </Label>
                  <Controller
                    name="model_dependency"
                    control={control}
                    render={({ field }) => (
                      <select
                        id="model_dependency"
                        className="w-full px-3 py-2 border rounded-md"
                        disabled={isLoading}
                        {...field}
                      >
                        <option value="" disabled>Select Model Dependency</option>
                        {modelDependencyOptions.map(option => (
                          <option key={option.value} value={option.value}>{option.label}</option>
                        ))}
                      </select>
                    )}
                  />
                  {errors?.model_dependency && (
                    <p className="text-sm text-destructive">{errors.model_dependency.message}</p>
                  )}
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          {/* Classification Tab */}
          <TabsContent value="classification">
            <Card>
              <CardHeader>
                <CardTitle>Classification</CardTitle>
                <CardDescription>
                  Categorize the technique to make it easier to discover
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-6">
                <div className="space-y-6">
                  <div className="space-y-2">
                    <label htmlFor="assurance_goal_ids" className="block font-medium">
                      Assurance Goals <span className="text-destructive">*</span>
                    </label>
                    <Controller
                      name="assurance_goal_ids"
                      control={control}
                      render={({ field }) => (
                        <select
                          id="assurance_goal_ids"
                          multiple
                          className="w-full px-3 py-2 border rounded-md"
                          onChange={(e) => {
                            const selectedOptions = Array.from(e.target.selectedOptions).map(opt => opt.value);
                            handleGoalChange(selectedOptions);
                          }}
                          disabled={isLoading}
                          size={4}
                          value={field.value.map(id => id.toString())}
                        >
                          {assuranceGoalOptions.map(option => (
                            <option key={option.value} value={option.value}>
                              {option.label}
                            </option>
                          ))}
                        </select>
                      )}
                    />
                    <p className="text-xs text-muted-foreground">
                      Hold Ctrl (or Cmd) to select multiple options
                    </p>
                    {errors?.assurance_goal_ids && (
                      <p className="text-sm text-destructive">{errors.assurance_goal_ids.message}</p>
                    )}
                  </div>

                  <div className="space-y-2">
                    <label htmlFor="category_ids" className="block font-medium">
                      Categories <span className="text-destructive">*</span>
                    </label>
                    <Controller
                      name="category_ids"
                      control={control}
                      render={({ field }) => (
                        <select
                          id="category_ids"
                          multiple
                          className="w-full px-3 py-2 border rounded-md"
                          onChange={(e) => {
                            const selectedOptions = Array.from(e.target.selectedOptions).map(opt => opt.value);
                            handleCategoryChange(selectedOptions);
                          }}
                          disabled={isLoading || watchedAssuranceGoalIds.length === 0}
                          size={4}
                          value={field.value.map(id => id.toString())}
                        >
                          {categoryOptions.map(option => (
                            <option key={option.value} value={option.value}>
                              {option.label}
                            </option>
                          ))}
                        </select>
                      )}
                    />
                    <p className="text-xs text-muted-foreground">
                      {watchedAssuranceGoalIds.length === 0
                        ? "Select assurance goals first to see available categories"
                        : "Hold Ctrl (or Cmd) to select multiple options"}
                    </p>
                    {errors?.category_ids && (
                      <p className="text-sm text-destructive">{errors.category_ids.message}</p>
                    )}
                  </div>

                  <div className="space-y-2">
                    <label htmlFor="subcategory_ids" className="block font-medium">
                      Subcategories
                    </label>
                    <Controller
                      name="subcategory_ids"
                      control={control}
                      render={({ field }) => (
                        <select
                          id="subcategory_ids"
                          multiple
                          className="w-full px-3 py-2 border rounded-md"
                          onChange={(e) => {
                            const selectedOptions = Array.from(e.target.selectedOptions).map(opt => opt.value);
                            const subcategoryIds = selectedOptions.map(v => parseInt(v));
                            setValue("subcategory_ids", subcategoryIds);
                          }}
                          disabled={isLoading || watchedCategoryIds.length === 0}
                          size={4}
                          value={field.value.map(id => id.toString())}
                        >
                          {subcategoryOptions.map(option => (
                            <option key={option.value} value={option.value}>
                              {option.label}
                            </option>
                          ))}
                        </select>
                      )}
                    />
                    <p className="text-xs text-muted-foreground">
                      {watchedCategoryIds.length === 0
                        ? "Select categories first to see available subcategories"
                        : "Hold Ctrl (or Cmd) to select multiple options"}
                    </p>
                  </div>

                  <div className="space-y-2">
                    <label htmlFor="tag_ids" className="block font-medium">
                      Tags
                    </label>
                    <Controller
                      name="tag_ids"
                      control={control}
                      render={({ field }) => (
                        <select
                          id="tag_ids"
                          multiple
                          className="w-full px-3 py-2 border rounded-md"
                          onChange={(e) => {
                            const selectedOptions = Array.from(e.target.selectedOptions).map(opt => opt.value);
                            const tagIds = selectedOptions.map(v => parseInt(v));
                            setValue("tag_ids", tagIds);
                          }}
                          disabled={isLoading}
                          size={4}
                          value={field.value.map(id => id.toString())}
                        >
                          {tagOptions.map(option => (
                            <option key={option.value} value={option.value}>
                              {option.label}
                            </option>
                          ))}
                        </select>
                      )}
                    />
                    <p className="text-xs text-muted-foreground">
                      Hold Ctrl (or Cmd) to select multiple options
                    </p>
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          {/* Examples & Limitations Tab */}
          <TabsContent value="examples">
            <Card>
              <CardHeader>
                <CardTitle>Example Use Cases</CardTitle>
                <CardDescription>
                  Provide examples of how this technique can be used
                </CardDescription>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  {useCases.map((useCase, index) => (
                    <div key={index} className="border rounded-md p-4 space-y-4">
                      <div className="flex justify-between items-center">
                        <h3 className="text-sm font-medium">Example {index + 1}</h3>
                        <Button
                          type="button"
                          variant="ghost"
                          size="sm"
                          onClick={() => removeUseCase(index)}
                          disabled={isLoading}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>

                      <div className="space-y-2">
                        <Label htmlFor={`useCase-description-${index}`}>Description</Label>
                        <Textarea
                          id={`useCase-description-${index}`}
                          value={useCase.description}
                          onChange={(e) => updateUseCase(index, "description", e.target.value)}
                          placeholder="Describe an example use case"
                          rows={3}
                          disabled={isLoading}
                        />
                      </div>

                      <div className="space-y-2">
                        <Label htmlFor={`useCase-goal-${index}`}>Related Assurance Goal (Optional)</Label>
                        <SelectField
                          id={`useCase-goal-${index}`}
                          label=""
                          value={useCase.assurance_goal?.toString() || "0"}
                          onChange={(value) => updateUseCase(index, "assurance_goal", value === "0" ? undefined : parseInt(value))}
                          options={[{ value: "0", label: "None" }, ...assuranceGoalOptions]}
                          placeholder="Select related goal (optional)"
                          disabled={isLoading}
                        />
                      </div>
                    </div>
                  ))}

                  <Button
                    type="button"
                    variant="outline"
                    onClick={addUseCase}
                    disabled={isLoading}
                    className="w-full"
                  >
                    <PlusCircle className="h-4 w-4 mr-2" /> Add Use Case
                  </Button>
                </div>
              </CardContent>
            </Card>

            <Card className="mt-6">
              <CardHeader>
                <CardTitle>Limitations</CardTitle>
                <CardDescription>
                  Outline any limitations or drawbacks of this technique
                </CardDescription>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  {limitations.map((limitation, index) => (
                    <div key={index} className="border rounded-md p-4 space-y-4">
                      <div className="flex justify-between items-center">
                        <h3 className="text-sm font-medium">Limitation {index + 1}</h3>
                        <Button
                          type="button"
                          variant="ghost"
                          size="sm"
                          onClick={() => removeLimitation(index)}
                          disabled={isLoading}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>

                      <div className="space-y-2">
                        <Label htmlFor={`limitation-${index}`}>Description</Label>
                        <Textarea
                          id={`limitation-${index}`}
                          value={limitation}
                          onChange={(e) => updateLimitation(index, e.target.value)}
                          placeholder="Describe a limitation of this technique"
                          rows={3}
                          disabled={isLoading}
                        />
                      </div>
                    </div>
                  ))}

                  <Button
                    type="button"
                    variant="outline"
                    onClick={addLimitation}
                    disabled={isLoading}
                    className="w-full"
                  >
                    <PlusCircle className="h-4 w-4 mr-2" /> Add Limitation
                  </Button>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          {/* Resources Tab */}
          <TabsContent value="resources">
            <Card>
              <CardHeader>
                <CardTitle>Resources</CardTitle>
                <CardDescription>
                  Add links to papers, code repositories, documentation, or other related resources
                </CardDescription>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  {resources.map((resource, index) => (
                    <div key={index} className="border rounded-md p-4 space-y-4">
                      <div className="flex justify-between items-center">
                        <h3 className="text-sm font-medium">Resource {index + 1}</h3>
                        <Button
                          type="button"
                          variant="ghost"
                          size="sm"
                          onClick={() => removeResource(index)}
                          disabled={isLoading}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>

                      <div className="space-y-2">
                        <Label htmlFor={`resource-type-${index}`}>Resource Type</Label>
                        <SelectField
                          id={`resource-type-${index}`}
                          label=""
                          value={resource.resource_type ? resource.resource_type.toString() : ""}
                          onChange={(value) => updateResource(index, "resource_type", parseInt(value))}
                          options={[{ value: "", label: "Select resource type" }, ...resourceTypeOptions]}
                          placeholder="Select resource type"
                          disabled={isLoading}
                        />
                      </div>

                      <div className="space-y-2">
                        <Label htmlFor={`resource-title-${index}`}>Title</Label>
                        <Input
                          id={`resource-title-${index}`}
                          value={resource.title}
                          onChange={(e) => updateResource(index, "title", e.target.value)}
                          placeholder="Enter resource title"
                          disabled={isLoading}
                        />
                      </div>

                      <div className="space-y-2">
                        <Label htmlFor={`resource-url-${index}`}>URL</Label>
                        <Input
                          id={`resource-url-${index}`}
                          value={resource.url}
                          onChange={(e) => updateResource(index, "url", e.target.value)}
                          placeholder="Enter resource URL"
                          type="url"
                          disabled={isLoading}
                        />
                      </div>

                      <div className="space-y-2">
                        <Label htmlFor={`resource-description-${index}`}>Description (Optional)</Label>
                        <Textarea
                          id={`resource-description-${index}`}
                          value={resource.description}
                          onChange={(e) => updateResource(index, "description", e.target.value)}
                          placeholder="Enter resource description"
                          rows={2}
                          disabled={isLoading}
                        />
                      </div>
                    </div>
                  ))}

                  <Button
                    type="button"
                    variant="outline"
                    onClick={addResource}
                    disabled={isLoading}
                    className="w-full"
                  >
                    <PlusCircle className="h-4 w-4 mr-2" /> Add Resource
                  </Button>
                </div>
              </CardContent>
            </Card>
          </TabsContent>
        </Tabs>

        <div className="mt-6 flex justify-end">
          <Button
            type="submit"
            disabled={isLoading}
            className="min-w-[120px]"
          >
            {isLoading ? (
              <span className="flex items-center gap-2">
                <span className="animate-spin">↻</span>
                {isEditMode ? "Updating..." : "Creating..."}
              </span>
            ) : (
              <>
                <Save className="mr-2 h-4 w-4" />
                {isEditMode ? "Update Technique" : "Create Technique"}
              </>
            )}
          </Button>
        </div>
      </form>
    </div>
  );
}
</file>

<file path="frontend/src/lib/api/fetch.ts">
// src/lib/api/fetch.ts

// Define the possible API environments
type ApiEnvironment = 'client' | 'server';

/**
 * Determine the current environment (client or server)
 */
function getEnvironment(): ApiEnvironment {
  return typeof window === 'undefined' ? 'server' : 'client';
}

/**
 * Get the appropriate base URL for API requests based on environment
 */
function getBaseUrl(): string {
  const environment = getEnvironment();
  
  if (environment === 'server') {
    // When running on the server
    if (process.env.DOCKER_ENV === 'true') {
      // Use direct backend URL when running on the server in Docker
      const backendUrl = process.env.BACKEND_URL || 'http://backend:8000';
      console.log(`[fetchApi] Server-side request in Docker using: ${backendUrl}`);
      return backendUrl;
    } else {
      // Use localhost when running locally
      const backendUrl = process.env.BACKEND_URL || 'http://localhost:8000';
      console.log(`[fetchApi] Server-side request locally using: ${backendUrl}`);
      return backendUrl;
    }
  }
  
  // In the browser, use relative URLs that will be handled by Next.js rewrites
  console.log('[fetchApi] Client-side request using relative URL');
  return '';
}

/**
 * Fetch API function with enhanced error handling and environment awareness
 */
export async function fetchApi(endpoint: string, options: RequestInit = {}) {
  const baseUrl = getBaseUrl();
  // Ensure no double slashes and include the base URL if we're on the server
  const url = `${baseUrl}/api/${endpoint.replace(/^\/+/, '')}`;
  
  console.log(`[fetchApi] Environment: ${getEnvironment()}, Requesting: ${url}`);
  
  try {
    const response = await fetch(url, {
      ...options,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
        ...options.headers,
      },
    });
    
    // Log status for debugging
    console.log(`[fetchApi] Response status: ${response.status} ${response.statusText}`);
    
    if (!response.ok) {
      // Try to get more detailed error information
      let errorText = '';
      try {
        errorText = await response.text();
        console.error(`[fetchApi] Error details: ${errorText.substring(0, 500)}${errorText.length > 500 ? '...' : ''}`);
      } catch (e) {
        console.error(`[fetchApi] Could not read error details: ${e}`);
      }
      
      throw new Error(`API error: ${response.status} ${response.statusText}`);
    }
    
    return response.json();
  } catch (error) {
    console.error(`[fetchApi] Request failed:`, error);
    throw error;
  }
}
</file>

<file path="frontend/Dockerfile">
# Use Node.js LTS version
FROM node:20-slim AS builder

# Set working directory
WORKDIR /app

# Install pnpm
RUN npm install -g pnpm@10.6.5

# Copy package files
COPY package.json pnpm-lock.yaml ./

# Install dependencies with pnpm
RUN pnpm install --frozen-lockfile

# Copy project files
COPY . .

# Build-time arguments (ARG) - only needed at build time
ARG NEXT_PUBLIC_API_URL=/api
ARG NEXT_PUBLIC_SWAGGER_URL=/swagger/

# Variables needed at build time (converted from ARG to ENV)
ENV NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL}
ENV NEXT_PUBLIC_SWAGGER_URL=${NEXT_PUBLIC_SWAGGER_URL}
ENV NEXT_TELEMETRY_DISABLED=1
ENV NODE_ENV=production

# Build the application
RUN pnpm build

# Production image - use alpine for smaller image size
FROM node:20-alpine AS runner

WORKDIR /app

# Copy necessary files for standalone mode
COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static

# Runtime environment variables (ENV)
ENV NODE_ENV=production
ENV PORT=3000
ENV HOSTNAME="0.0.0.0"
ENV NEXT_TELEMETRY_DISABLED=1

# Install curl for health checks
RUN apk add --no-cache curl

# Don't run as root
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs
RUN chown -R nextjs:nodejs /app
USER nextjs

# Expose the port the app runs on
EXPOSE 3000

# Start the application in standalone mode
CMD ["node", "server.js"]
</file>

<file path="backend/api/management/commands/reset_and_import_techniques.py">
# backend/api/management/commands/reset_and_import_techniques.py
from django.core.management.base import BaseCommand
from django.core.management import call_command


class Command(BaseCommand):
    help = "Reset the database and import techniques in one step"

    def add_arguments(self, parser):
        parser.add_argument("--file", type=str, help="Path to the data file")
        parser.add_argument(
            "--force", action="store_true", help="Skip confirmation prompt"
        )
        parser.add_argument(
            "--format",
            type=str,
            choices=["json", "csv"],
            default="json",
            help="Format of the input file (default: json)",
        )

    def handle(self, *args, **options):
        file_path = options.get("file")
        force = options.get("force", False)
        file_format = options.get("format", "json")

        # First, reset the database
        reset_options = {"force": force}
        self.stdout.write(self.style.NOTICE("Step 1: Resetting database"))
        call_command("reset_database", **reset_options)

        # Then import techniques
        import_options = {}
        if file_path:
            import_options["file"] = file_path

        self.stdout.write(
            self.style.NOTICE(f"Step 2: Importing techniques from {file_format} file")
        )

        if file_format == "csv":
            # Use the original CSV import command—no longer used
            call_command("import_techniques_csv", **import_options)
        else:
            # Use the new JSON import command
            call_command("import_techniques", **import_options)

        self.stdout.write(self.style.SUCCESS("✅ Reset and import complete!"))

        # Add server startup instructions at the end
        self.stdout.write(
            self.style.SUCCESS(
                "➡️ Run 'python manage.py runserver' to start the server"
            )
        )
</file>

<file path="backend/config/urls.py">
# config/urls.py

from django.conf import settings
from django.contrib import admin
from django.urls import path, include
from rest_framework.documentation import include_docs_urls
from drf_yasg.views import get_schema_view
from drf_yasg import openapi
from rest_framework import permissions

# Create schema view for Swagger documentation
schema_view = get_schema_view(
    openapi.Info(
        title="TEA Techniques API",
        default_version="v1",
        description="API for Trustworthy and Ethical Assurance Techniques",
        contact=openapi.Contact(email="cburr@turing.ac.uk"),
        license=openapi.License(name="MIT License"),
    ),
    public=True,
    permission_classes=(permissions.AllowAny,),
)

urlpatterns = [
    path("admin/", admin.site.urls),
    path("api/", include("api.urls")),
    path("__reload__/", include("django_browser_reload.urls")),
    path(
        "swagger/",
        schema_view.with_ui("swagger", cache_timeout=0),
        name="schema-swagger-ui",
    ),
    path(
        "swagger",
        schema_view.with_ui("swagger", cache_timeout=0),
        name="schema-swagger-ui-no-slash",
    ),
    path("redoc/", schema_view.with_ui("redoc", cache_timeout=0), name="schema-redoc"),
    path(
        "redoc",
        schema_view.with_ui("redoc", cache_timeout=0),
        name="schema-redoc-no-slash",
    ),
    path("", include("api.root_urls")),
]

if settings.DEBUG:
    try:
        import debug_toolbar

        urlpatterns = [
            path("__debug__/", include(debug_toolbar.urls)),
        ] + urlpatterns
    except ImportError:
        # Handle case where debug_toolbar is not installed
        pass
</file>

<file path="backend/pyproject.toml">
[tool.poetry]
name = "tea-techniques"
version = "0.1.0"
description = ""
authors = ["Christopher Burr <chrisdburr@gmail.com>"]
readme = "README.md"
package-mode=false

[tool.poetry.dependencies]
python = "^3.12"
django = "^5.1.1"
pandas = "^2.2.3"
sqlalchemy = "^2.0.35"
python-dotenv = "^1.0.1"
markdown = "^3.7"
beautifulsoup4 = "^4.12.3"
lxml = "^5.3.0"
html5lib = "^1.1"
djangorestframework = "^3.15.2"
django-filter = "^24.3"
django-extensions = "^3.2.3"
django-tailwind = "^3.8.0"
django-browser-reload = "^1.15.0"
psycopg = "^3.2.5"
django-cors-headers = "^4.7.0"
drf-yasg = "^1.21.9"
whitenoise = "^6.6.0"
bs4 = "^0.0.2"
requests = "^2.32.3"
jsonschema = "^4.23.0"
django-debug-toolbar = "^5.1.0"

[tool.poetry.group.dev.dependencies]
pytest = "^8.0.2"
pytest-django = "^4.8.0"
pytest-cov = "^4.1.0"
factory-boy = "^3.3.0"
faker = "^23.1.0"
mypy = "^1.9.0"
django-stubs = "^4.2.7"
djangorestframework-stubs = "^3.14.5"
types-requests = "^2.32.0.20240420"
types-markdown = "^3.5.0.20240412"

[tool.mypy]
python_version = "3.12"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = false
disallow_incomplete_defs = false
check_untyped_defs = true
disallow_untyped_decorators = false
no_implicit_optional = true
strict_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true

[[tool.mypy.overrides]]
module = "*.migrations.*"
ignore_errors = true

[[tool.mypy.overrides]]
module = "*.tests.*"
ignore_errors = true

[tool.pytest.ini_options]
DJANGO_SETTINGS_MODULE = "config.settings_sqlite"
python_files = ["test_*.py", "*_test.py"]
testpaths = ["api/tests"]
filterwarnings = ["ignore::DeprecationWarning"]

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
</file>

<file path="docs/TAILSCALE-DEPLOYMENT.md">
# Tailscale Deployment Guide

This document outlines the Tailscale deployment process for the TEA Techniques application, along with known issues and recommendations for improvements.

For standard deployment options, please refer to the [Deployment Guide](DEPLOYMENT.md).

## Current Deployment Architecture

The current setup uses Tailscale Funnel to expose the application to the internet:

1. **Docker Compose Stack**:
   - Frontend container (Next.js)
   - Backend container (Django)
   - PostgreSQL database container

2. **Nginx Configuration**:
   - Serves as a reverse proxy
   - Routes requests to the appropriate containers
   - Handles CORS and headers

3. **Tailscale Funnel**:
   - Exposes the Nginx server to the internet
   - Provides a secure public URL

## Deployment Process

To deploy the application with Tailscale:

1. Ensure Tailscale is installed and logged in on your server
2. Clone the repository
3. Configure environment variables:
   ```bash
   # Copy the example environment file
   cp .env.tailscale.example .env.tailscale
   
   # Edit the file with your Tailscale domain and other settings
   nano .env.tailscale
   ```
4. Run the deployment script:
   ```bash
   ./deploy-tailscale.sh
   ```

This script:
- Checks for proper configuration
- Stops any existing containers
- Cleans up volumes for a fresh start
- Generates Nginx configuration from a template
- Builds and starts the containers (including Nginx)
- Initializes the database with sample data
- Sets up Tailscale funnel

## Known Issues and Solutions

### Database Configuration

The application now uses PostgreSQL consistently across all environments:

**Solution**: The deployment has been standardized to use PostgreSQL:
1. The database configuration is set in the Django settings
2. The `tailscale_setup` command configures PostgreSQL properly
3. Standard Django migrations are used to maintain schema consistency

This ensures consistent behavior across all deployment environments.

### Host Header Handling

**Problem**: Nginx proxy passes the original host header to Django, which can cause URL resolution issues.

**Solution**: The Nginx configuration template explicitly sets the Host header to `localhost:8000` for all backend requests:

```nginx
proxy_set_header Host localhost:8000;
```

This ensures Django receives the expected host it's configured to use.

### Nginx Configuration Updates

**Problem**: Previously, updating Nginx configuration required direct file system access and service restarts.

**Solution**: Now Nginx runs in a container, with configuration managed through:

1. A template file (`nginx/tea-techniques.conf.template`) with environment variable placeholders
2. Environment variables in `.env.tailscale` file 
3. The `update-nginx.sh` script that regenerates the configuration and restarts only the Nginx container

This approach eliminates the need for root access to the host system and reduces deployment complexity.

## Recommendations for Improvement

### 1. Database Management

**Current**: PostgreSQL is used across all environments, providing consistency.

**Recommended**: Further improvements for database management:

```yaml
# Current docker-compose.yml configuration
services:
  db:
    image: postgres:16
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=techniques
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5
```

### 2. Migration Management

**Current**: Standard Django migrations are used consistently.

**Recommended**: Further enhance the migration strategy:

- Add migration testing to CI/CD pipeline
- Implement database versioning and rollback capability
- Create migration documentation for complex schema changes

### 3. Environment Configuration

**Current**: Environment variables are managed through `.env.tailscale` and template system:

- Environment variables are loaded from `.env.tailscale`
- Templates use environment variable substitution
- Docker Compose uses these variables automatically
- Default values are provided for optional variables

**Recommended further improvements**:

- Add validation for required environment variables
- Create separate `.env.production` and `.env.development` for other deployment scenarios
- Document all environment variables in a central location

### 4. Automated Health Checks

**Current**: Basic health checks are implemented:

- All containers have health checks configured in docker-compose.yml
- Nginx has a simple `/health` endpoint
- Deployment script verifies service status

**Recommended further improvements**:

- Implement a more comprehensive `/health` endpoint in the backend with DB connectivity check
- Add frontend health checks with API connectivity verification
- Set up external monitoring using a service like UptimeRobot

### 5. TLS/SSL Implementation

**Current**: Relies on Tailscale for secure connections.

**Recommended**: Add proper TLS/SSL for all environments:

- Add Let's Encrypt integration for Nginx
- Configure proper certificate renewal
- Ensure all traffic uses HTTPS

## Long-term Architecture Goals

For a production-ready deployment, consider:

1. **Kubernetes Deployment**:
   - Convert Docker Compose configuration to Kubernetes manifests
   - Use Helm charts for deployment
   - Implement proper resource limits and requests

2. **CI/CD Pipeline**:
   - Set up automated testing and deployment
   - Implement blue/green deployment strategy
   - Add automated database migrations

3. **Database Evolution**:
   - Implement a connection pooler like PgBouncer
   - Set up database backups and point-in-time recovery
   - Consider read replicas for scaling

4. **Monitoring and Logging**:
   - Add Prometheus metrics 
   - Implement centralized logging with ELK stack
   - Set up alerts for critical issues

By implementing these recommendations, the Tailscale deployment will become more robust, maintainable, and scalable for production use.

## Related Documentation

- [Deployment Guide](DEPLOYMENT.md) - Standard deployment options
- [Development Workflow](DEVELOPMENT-WORKFLOW.md) - Local development setup
- [Model Architecture](MODEL-ARCHITECTURE.md) - Database considerations
- [Future Roadmap](FUTURE-ROADMAP.md) - Long-term architecture goals
</file>

<file path="frontend/src/app/categories/page.tsx">
"use client";

import React, { useState, useEffect } from "react";
import Link from "next/link";
import MainLayout from "@/components/layout/MainLayout";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardFooter, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ArrowRight } from "lucide-react";
import { useAssuranceGoals, useTechniques } from "@/lib/api/hooks";
import GoalIcon from "@/components/technique/GoalIcon";
import type { AssuranceGoal, Technique } from "@/lib/types";

export default function CategoriesPage() {
    // State for the selected tab and goal
    const [selectedGoal, setSelectedGoal] = useState<string>("Explainability");
    const [selectedGoalId, setSelectedGoalId] = useState<number | null>(null);

    // const [selectedCategoryGroup, setSelectedCategoryGroup] = useState<string>("");

    // Fetch assurance goals
    const { data: assuranceGoalsData, isLoading: isLoadingGoals } = useAssuranceGoals();

    // Fetch categories
    // const { data: categoriesData, isLoading: isLoadingCategories } = useCategories();

    // Fetch ALL techniques (not filtered by goal) to allow client-side filtering
    const { data: allTechniques, isLoading: isLoadingTechniques } = useTechniques(
        {}, // No filters - get all techniques
        1 // First page only
    );

    useEffect(() => {
        if (assuranceGoalsData?.results) {
            const goal = assuranceGoalsData.results.find(g => g.name === selectedGoal);
            if (goal) {
                setSelectedGoalId(goal.id);
            }
        }
    }, [selectedGoal, assuranceGoalsData]);

    // Client-side filter for the selected goal
    const goalTechniques = React.useMemo(() => {
        // Ensure we have a properly typed return value for empty case
        if (!allTechniques) return { results: [] as Technique[] };
        
        // Check if results exist in a type-safe way
        const techniquesData = allTechniques as unknown as { results: Technique[] };
        if (!techniquesData.results || !Array.isArray(techniquesData.results)) {
            return { results: [] as Technique[] };
        }

        console.log(`Filtering techniques for goal: ${selectedGoal}`);

        // Log the first technique's full structure to examine how assurance_goals are represented
        if (techniquesData.results.length > 0) {
            console.log("First technique structure:", JSON.stringify(techniquesData.results[0], null, 2));
            console.log("First technique goals:", techniquesData.results[0].assurance_goals);
        }

        // Filter techniques to only include those with the selected goal
        const filteredResults = techniquesData.results.filter((technique: Technique) => {
            // Log each technique's goals for the first few techniques
            if (techniquesData.results.indexOf(technique) < 3) {
                console.log(`Technique ${technique.id} (${technique.name}) goals:`,
                    technique.assurance_goals.map(g => g.name));
            }

            const hasMatchingGoal = technique.assurance_goals &&
                Array.isArray(technique.assurance_goals) &&
                technique.assurance_goals.some(goal => {
                    // This is the key check - is the name matching?
                    const matches = goal && typeof goal === 'object' && goal.name === selectedGoal;
                    return matches;
                });

            return hasMatchingGoal;
        });

        console.log(`Found ${filteredResults.length} techniques for ${selectedGoal}`);
        return {
            ...techniquesData,
            results: filteredResults
        };
    }, [allTechniques, selectedGoal]);

    // Fetch model-agnostic and model-specific example techniques
    // const { data: agnosticTechniques } = useTechniques(
    //     { model_dependency: "Model-Agnostic" },
    //     1
    // );

    // const { data: specificTechniques } = useTechniques(
    //     { model_dependency: "Model-Specific" },
    //     1
    // );

    // Detailed descriptions for each assurance goal
    const goalDescriptions: Record<string, string> = {
        Explainability: "Techniques that aim to make AI models more interpretable and their decisions more understandable to humans. These techniques help identify how models transform inputs into outputs, which features are most important for predictions, and why specific decisions are made.",
        Fairness: "Techniques that assess and mitigate bias in AI systems to ensure equitable outcomes across diverse demographic groups. These approaches help identify, measure, and reduce discrimination and unfairness in algorithmic decision-making.",
        Security: "Techniques that protect AI systems from adversarial attacks, vulnerabilities, and other security threats. These methods enhance the robustness of AI systems against manipulation and unauthorized exploitation.",
        Privacy: "Techniques that help preserve data privacy and confidentiality when developing or deploying AI systems. These approaches enable machine learning while protecting sensitive information from exposure or inference.",
        Reliability: "Techniques that ensure AI systems perform consistently and as expected across various conditions and environments. These methods improve robustness, error detection, and failure prevention in AI applications.",
        Safety: "Techniques that prevent harm to humans, environments, and other systems from AI operations. These approaches focus on identifying and mitigating potential risks, ensuring AI systems operate within safe boundaries and prevent unintended consequences.",
        Transparency: "Techniques that promote openness about how AI systems are developed, governed, and maintained. These approaches focus on documenting project governance, decision-making processes, and development methodologies to build trust and enable effective oversight."
    };

    // Group categories by assurance goal for easier display
    // const categoriesByGoal = React.useMemo(() => {
    //     if (!categoriesData?.results) return {};

    //     return categoriesData.results.reduce((acc: Record<string, Category[]>, category: Category) => {
    //         const goalName = category.assurance_goal_name;
    //         if (!acc[goalName]) {
    //             acc[goalName] = [];
    //         }
    //         acc[goalName].push(category);
    //         return acc;
    //     }, {});
    // }, [categoriesData]);

    // Group categories by first letter for the category section
    // const categoriesByFirstLetter = React.useMemo(() => {
    //     if (!categoriesData?.results) return {};

    //     return categoriesData.results.reduce((acc: Record<string, Category[]>, category: Category) => {
    //         const firstLetter = category.name.charAt(0).toUpperCase();
    //         if (!acc[firstLetter]) {
    //             acc[firstLetter] = [];
    //         }
    //         acc[firstLetter].push(category);
    //         return acc;
    //     }, {});
    // }, [categoriesData]);

    // All unique first letters for category group tabs
    // const categoryGroups = React.useMemo(() => {
    //     return Object.keys(categoriesByFirstLetter).sort();
    // }, [categoriesByFirstLetter]);

    // Helper function to create URL with correct filter parameters
    const createFilterUrl = (filterType: string, filterValue: string | number) => {
        // For assurance goals, generate URL with goal ID
        if (filterType === "assurance_goal" && selectedGoalId) {
            return `/techniques?assurance_goals=${selectedGoalId}`;
        }
        if (filterType === "category") {
            return `/techniques?categories=${encodeURIComponent(filterValue.toString())}`;
        }
        // For model dependency, use the exact parameter name
        return `/techniques?${filterType}=${encodeURIComponent(filterValue.toString())}`;
    };

    // Update the selected goal when tab changes
    useEffect(() => {
        if (selectedGoal && selectedGoal !== "all") {
            // You could make other adjustments here if needed
        }
    }, [selectedGoal]);

    // Add this function above your component
    const createPlaceholderTechniques = (goalName: string) => {
        return [
            {
                id: 1000 + Math.random() * 1000,
                name: `Example ${goalName} Technique 1`,
                description: `This is a placeholder example for ${goalName}. In a production environment, this would be an actual technique from the database.`,
                model_dependency: "Model-Agnostic",
                assurance_goals: [{ id: 0, name: goalName }]
            },
            {
                id: 2000 + Math.random() * 1000,
                name: `Example ${goalName} Technique 2`,
                description: `Another placeholder example for ${goalName}. Add real techniques through the admin interface.`,
                model_dependency: "Model-Specific",
                assurance_goals: [{ id: 0, name: goalName }]
            },
            {
                id: 3000 + Math.random() * 1000,
                name: `Example ${goalName} Technique 3`,
                description: `Third placeholder example for ${goalName}. In the future, this would contain real techniques from the database.`,
                model_dependency: "Model-Agnostic",
                assurance_goals: [{ id: 0, name: goalName }]
            }
        ] as Technique[];
    };

    return (
        <MainLayout>
            <div className="space-y-12">
                <section className="space-y-6">
                    <h1 className="text-3xl font-bold text-center">TEA Techniques Categories</h1>
                    <p className="text-lg text-muted-foreground text-center max-w-3xl mx-auto">
                        Explore techniques by assurance goals, categories, or model dependencies to find the right approach for your AI assurance needs.
                    </p>
                </section>

                {/* Assurance Goals Section */}
                <section className="space-y-8">
                    <h2 className="text-2xl font-bold">Assurance Goals</h2>

                    <Tabs
                        defaultValue="Explainability"
                        className="space-y-8"
                        onValueChange={(value) => {
                            console.log("Tab changed to:", value);
                            setSelectedGoal(value);
                        }}
                    >
                        <TabsList className="flex flex-wrap gap-2">
                            {!isLoadingGoals && assuranceGoalsData?.results && assuranceGoalsData.results.map((goal: AssuranceGoal) => (
                                <TabsTrigger
                                    key={goal.id}
                                    value={goal.name}
                                    className="flex items-center gap-2"
                                >
                                    <GoalIcon goalName={goal.name} size={16} />
                                    <span>{goal.name}</span>
                                </TabsTrigger>
                            ))}
                        </TabsList>

                        {!isLoadingGoals && assuranceGoalsData?.results && assuranceGoalsData.results.map((goal: AssuranceGoal) => (
                            <TabsContent key={goal.id} value={goal.name} className="space-y-6">
                                {/* Goal description */}
                                <div className="bg-muted/30 p-6 rounded-lg">
                                    <p className="text-lg">{goalDescriptions[goal.name] || goal.description}</p>
                                </div>

                                {/* Example techniques for this goal */}
                                <div className="space-y-4">
                                    <h3 className="text-xl font-semibold">Example {goal.name} Techniques</h3>

                                    {isLoadingTechniques ? (
                                        <p>Loading examples...</p>
                                    ) : goalTechniques?.results && goalTechniques.results.length > 0 ? (
                                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                            {goalTechniques.results.slice(0, 3).map((technique: Technique) => (
                                                <Card key={technique.id} className="h-full flex flex-col">
                                                    <CardHeader>
                                                        <CardTitle className="line-clamp-2">{technique.name}</CardTitle>
                                                        <CardDescription>
                                                            {technique.model_dependency}
                                                        </CardDescription>
                                                    </CardHeader>
                                                    <CardContent className="flex-grow">
                                                        <p className="line-clamp-4 text-sm">{technique.description}</p>
                                                    </CardContent>
                                                    <CardFooter>
                                                        <Button asChild variant="outline" size="sm" className="w-full">
                                                            <Link href={`/techniques/${technique.id}`}>
                                                                View Details
                                                            </Link>
                                                        </Button>
                                                    </CardFooter>
                                                </Card>
                                            ))}
                                        </div>
                                    ) : (
                                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                            {createPlaceholderTechniques(selectedGoal).map((technique: Technique) => (
                                                <Card key={technique.id} className="h-full flex flex-col">
                                                    <CardHeader>
                                                        <CardTitle className="line-clamp-2">{technique.name}</CardTitle>
                                                        <CardDescription>
                                                            {technique.model_dependency}
                                                        </CardDescription>
                                                    </CardHeader>
                                                    <CardContent className="flex-grow">
                                                        <p className="line-clamp-4 text-sm">{technique.description}</p>
                                                    </CardContent>
                                                    <CardFooter>
                                                        <Button asChild variant="outline" size="sm" className="w-full">
                                                            <Link href="/techniques">
                                                                View Similar Techniques
                                                            </Link>
                                                        </Button>
                                                    </CardFooter>
                                                </Card>
                                            ))}
                                        </div>
                                    )}


                                    {/* Link to all techniques for this goal */}
                                    <div className="flex justify-center mt-6">
                                        <Button asChild size="lg">
                                            <Link href={createFilterUrl("assurance_goal", selectedGoal)}>
                                                Browse All {selectedGoal} Techniques
                                                <ArrowRight className="ml-2 h-4 w-4" aria-hidden="true" />
                                            </Link>
                                        </Button>
                                    </div>
                                </div>

                                {/* Categories related to this goal */}
                                {/* {categoriesByGoal[goal.name] && categoriesByGoal[goal.name].length > 0 && (
                                    <div className="space-y-4">
                                        <h3 className="text-xl font-semibold">{goal.name} Categories</h3>
                                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                            {categoriesByGoal[goal.name].map((category: Category) => (
                                                <Card key={category.id} className="hover:bg-muted/20 transition-colors">
                                                    <CardHeader>
                                                        <CardTitle>{category.name}</CardTitle>
                                                    </CardHeader>
                                                    <CardContent>
                                                        <p className="line-clamp-3 text-sm">{category.description || `${category.name} techniques for ${goal.name}`}</p>
                                                    </CardContent>
                                                    <CardFooter>
                                                        <Button asChild variant="outline" size="sm" className="w-full">
                                                            <Link href={createFilterUrl("category", category.id.toString())}>
                                                                Browse {category.name} Techniques
                                                            </Link>
                                                        </Button>
                                                    </CardFooter>
                                                </Card>
                                            ))}
                                        </div>
                                    </div>
                                )} */}
                            </TabsContent>
                        ))}
                    </Tabs>
                </section>

                {/* Categories Section */}
                {/* <section className="space-y-8"> */}
                {/* <h2 className="text-2xl font-bold">Categories by Name</h2> */}

                {/* <div className="bg-muted/30 p-6 rounded-lg">
                        <p className="text-lg">
                            Categories provide a more granular classification of techniques within each assurance goal.
                            Use these to find specific approaches targeting particular aspects of AI systems.
                        </p>
                    </div> */}

                {/* <Tabs
                        defaultValue={categoryGroups[0] || "A"}
                        className="space-y-8"
                        onValueChange={setSelectedCategoryGroup}
                    >
                        <TabsList className="flex flex-wrap gap-1">
                            {categoryGroups.map((letter) => (
                                <TabsTrigger key={letter} value={letter}>
                                    {letter}
                                </TabsTrigger>
                            ))}
                        </TabsList>

                        {categoryGroups.map((letter) => (
                            <TabsContent key={letter} value={letter} className="space-y-6">
                                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                    {categoriesByFirstLetter[letter] && categoriesByFirstLetter[letter].map((category: Category) => (
                                        <Card key={category.id} className="h-full flex flex-col">
                                            <CardHeader>
                                                <CardTitle className="flex items-center gap-2">
                                                    <GoalIcon goalName={category.assurance_goal_name} size={16} />
                                                    <span>{category.name}</span>
                                                </CardTitle>
                                                <CardDescription>{category.assurance_goal_name}</CardDescription>
                                            </CardHeader>
                                            <CardContent className="flex-grow">
                                                <p className="text-sm line-clamp-3">{category.description || `${category.name} techniques for ${category.assurance_goal_name}`}</p>
                                            </CardContent>
                                            <CardFooter>
                                                <Button asChild variant="outline" size="sm" className="w-full">
                                                    <Link href={createFilterUrl("category", category.id.toString())}>
                                                        Browse {category.name} Techniques
                                                    </Link>
                                                </Button>
                                            </CardFooter>
                                        </Card>
                                    ))}
                                </div>
                            </TabsContent>
                        ))}
                    </Tabs> */}

                {/* <div className="flex justify-center mt-6">
                        <Button asChild size="lg" variant="outline">
                            <Link href="/techniques">
                                Browse All Techniques
                                <ArrowRight className="ml-2 h-4 w-4" aria-hidden="true" />
                            </Link>
                        </Button>
                    </div> */}
                {/* </section> */}

                {/* Model Dependency Section */}
                {/* <section className="space-y-8"> */}
                {/* <h2 className="text-2xl font-bold">Model Dependency</h2> */}

                {/* <div className="grid grid-cols-1 md:grid-cols-2 gap-8"> */}
                {/* Model-Agnostic */}
                {/* <Card className="h-full flex flex-col">
                            <CardHeader>
                                <CardTitle>Model-Agnostic Techniques</CardTitle>
                                <CardDescription>
                                    Techniques that can be applied to any machine learning model, regardless of its internal structure.
                                </CardDescription>
                            </CardHeader>
                            <CardContent className="flex-grow">
                                <ul className="space-y-2">
                                    {agnosticTechniques?.results && agnosticTechniques.results.slice(0, 3).map((technique: Technique) => (
                                        <li key={technique.id}>
                                            <Link href={`/techniques/${technique.id}`} className="text-primary hover:underline">
                                                {technique.name}
                                            </Link>
                                        </li>
                                    ))}
                                </ul>
                            </CardContent>
                            <CardFooter>
                                <Button asChild variant="default" className="w-full">
                                    <Link href={createFilterUrl("model_dependency", "Model-Agnostic")}>
                                        Browse Model-Agnostic Techniques
                                        <ArrowRight className="ml-2 h-4 w-4" aria-hidden="true" />
                                    </Link>
                                </Button>
                            </CardFooter>
                        </Card> */}

                {/* Model-Specific */}
                {/* <Card className="h-full flex flex-col">
                            <CardHeader>
                                <CardTitle>Model-Specific Techniques</CardTitle>
                                <CardDescription>
                                    Techniques that require access to a model&apos;s internal components, gradients, or specific architectures.
                                </CardDescription>
                            </CardHeader>
                            <CardContent className="flex-grow">
                                <ul className="space-y-2">
                                    {specificTechniques?.results && specificTechniques.results.slice(0, 3).map((technique: Technique) => (
                                        <li key={technique.id}>
                                            <Link href={`/techniques/${technique.id}`} className="text-primary hover:underline">
                                                {technique.name}
                                            </Link>
                                        </li>
                                    ))}
                                </ul>
                            </CardContent>
                            <CardFooter>
                                <Button asChild variant="default" className="w-full">
                                    <Link href={createFilterUrl("model_dependency", "Model-Specific")}>
                                        Browse Model-Specific Techniques
                                        <ArrowRight className="ml-2 h-4 w-4" aria-hidden="true" />
                                    </Link>
                                </Button>
                            </CardFooter>
                        </Card> */}
                {/* </div>  */}
                {/* </section> */}

                {/* How to Use This Information Section */}
                <section className="space-y-6">
                    <h2 className="text-2xl font-bold">How to Use This Information</h2>

                    <div className="bg-card rounded-lg p-8 shadow-sm space-y-6">
                        <div className="max-w-3xl mx-auto space-y-6">
                            <div className="space-y-2">
                                <h3 className="text-xl font-semibold flex items-center">
                                    <ArrowRight className="mr-2 h-5 w-5 text-primary" />
                                    Identify Your Assurance Goals
                                </h3>
                                <p className="text-lg ml-7">
                                    Start by determining which aspects of AI trustworthiness are most important for your system—explainability, fairness, security, etc.
                                </p>
                            </div>

                            <div className="space-y-2">
                                <h3 className="text-xl font-semibold flex items-center">
                                    <ArrowRight className="mr-2 h-5 w-5 text-primary" />
                                    Consider Your Model Type
                                </h3>
                                <p className="text-lg ml-7">
                                    Some techniques require access to model internals, while others work with any model as a black box. Choose based on your access level.
                                </p>
                            </div>

                            <div className="space-y-2">
                                <h3 className="text-xl font-semibold flex items-center">
                                    <ArrowRight className="mr-2 h-5 w-5 text-primary" />
                                    Explore Categories in Depth
                                </h3>
                                <p className="text-lg ml-7">
                                    Within each assurance goal, different categories address specific aspects of the problem. Browse these to narrow your search.
                                </p>
                            </div>

                            <div className="space-y-2">
                                <h3 className="text-xl font-semibold flex items-center">
                                    <ArrowRight className="mr-2 h-5 w-5 text-primary" />
                                    Evaluate Implementation Requirements
                                </h3>
                                <p className="text-lg ml-7">
                                    Each technique has different complexity and computational requirements. Consider your resources and constraints.
                                </p>
                            </div>

                            <div className="space-y-2">
                                <h3 className="text-xl font-semibold flex items-center">
                                    <ArrowRight className="mr-2 h-5 w-5 text-primary" />
                                    Combine Multiple Techniques
                                </h3>
                                <p className="text-lg ml-7">
                                    Often, the best approach is to use multiple techniques together to address different aspects of AI assurance.
                                </p>
                            </div>
                        </div>
                    </div>
                </section>
            </div >
        </MainLayout >
    );
}
</file>

<file path="frontend/src/components/layout/Header.tsx">
"use client";

import React, { useState } from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { useAuth } from "@/lib/context/auth-context";
import { DarkModeToggle } from "@/lib/context/dark-mode";
import { Button } from "@/components/ui/button";
import { config } from "@/lib/config";
import { Menu, X, LogIn, LogOut, Plus, LayoutDashboard } from "lucide-react";

const Header = () => {
	const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
	const { isAuthenticated, isLoading, user, logout } = useAuth();
	const router = useRouter();

	const toggleMobileMenu = () => {
		setMobileMenuOpen(!mobileMenuOpen);
	};
	
	const handleLogout = async () => {
		await logout();
		router.push('/');
	};

	return (
		<header className="border-b border-border bg-background">
			<div className="container mx-auto flex h-16 items-center justify-between px-4">
				<div className="flex items-center gap-6">
					<Link href="/" className="text-xl font-bold">
						TEA Techniques
					</Link>

					{/* Desktop navigation - hidden on mobile */}
					<nav className="hidden md:block">
						<ul className="flex gap-6">
							<li>
								<Link
									href="/categories"
									className="text-muted-foreground hover:text-foreground"
								>
									Categories
								</Link>
							</li>
							<li>
								<Link
									href="/techniques"
									className="text-muted-foreground hover:text-foreground"
								>
									Browse Techniques
								</Link>
							</li>
							<li>
								<Link
									href="/about"
									className="text-muted-foreground hover:text-foreground"
								>
									About
								</Link>
							</li>
						</ul>
					</nav>
				</div>

				<div className="flex items-center gap-4">
					<DarkModeToggle />

					{/* Auth-aware buttons - hidden on mobile */}
					<div className="hidden md:flex gap-2">
						{!isLoading && (
							<>
								{isAuthenticated ? (
									<>
										<Button
											asChild
											variant="default"
											size="sm"
										>
											<Link href="/techniques/add">
												<Plus size={16} className="mr-1" />
												Add Technique
											</Link>
										</Button>
										
										{user?.isStaff && (
											<Button
												asChild
												variant="outline"
												size="sm"
											>
												<a href="/admin" target="_blank" rel="noopener noreferrer">
													<LayoutDashboard size={16} className="mr-1" />
													Admin
												</a>
											</Button>
										)}
										
										<Button
											variant="outline"
											size="sm"
											onClick={handleLogout}
										>
											<LogOut size={16} className="mr-1" />
											Logout
										</Button>
									</>
								) : (
									<Button
										asChild
										variant="outline"
										size="sm"
									>
										<Link href="/login">
											<LogIn size={16} className="mr-1" />
											Login
										</Link>
									</Button>
								)}
							</>
						)}
					</div>

					{/* API button - hidden on mobile */}
					<Button
						asChild
						variant="outline"
						size="sm"
						className="hidden md:flex"
					>
						<a
							href={config.swaggerUrl}
							target="_blank"
							rel="noopener noreferrer"
						>
							API Documentation
						</a>
					</Button>

					{/* Mobile menu button - only visible on mobile */}
					<Button
						variant="outline"
						size="icon"
						className="md:hidden"
						onClick={toggleMobileMenu}
						aria-label="Toggle menu"
					>
						{mobileMenuOpen ? <X size={20} /> : <Menu size={20} />}
					</Button>
				</div>
			</div>

			{/* Mobile menu - slides in from the top when open */}
			{mobileMenuOpen && (
				<div className="md:hidden">
					<nav className="flex flex-col border-b border-border bg-background">
						<ul className="flex flex-col py-4">
							<li>
								<Link
									href="/categories"
									className="block px-4 py-3 text-muted-foreground hover:bg-muted hover:text-foreground"
									onClick={() => setMobileMenuOpen(false)}
								>
									Categories
								</Link>
							</li>
							<li>
								<Link
									href="/techniques"
									className="block px-4 py-3 text-muted-foreground hover:bg-muted hover:text-foreground"
									onClick={() => setMobileMenuOpen(false)}
								>
									Browse Techniques
								</Link>
							</li>
							<li>
								<Link
									href="/about"
									className="block px-4 py-3 text-muted-foreground hover:bg-muted hover:text-foreground"
									onClick={() => setMobileMenuOpen(false)}
								>
									About
								</Link>
							</li>
							<li>
								<a
									href={config.swaggerUrl}
									className="block px-4 py-3 text-muted-foreground hover:bg-muted hover:text-foreground"
									target="_blank"
									rel="noopener noreferrer"
									onClick={() => setMobileMenuOpen(false)}
								>
									API Documentation
								</a>
							</li>
							
							{/* Auth links for mobile */}
							{!isLoading && (
								<>
									{isAuthenticated ? (
										<>
											<li>
												<Link
													href="/techniques/add"
													className="block px-4 py-3 text-muted-foreground hover:bg-muted hover:text-foreground"
													onClick={() => setMobileMenuOpen(false)}
												>
													Add Technique
												</Link>
											</li>
											{user?.isStaff && (
												<li>
													<a
														href="/admin"
														className="block px-4 py-3 text-muted-foreground hover:bg-muted hover:text-foreground"
														target="_blank"
														rel="noopener noreferrer"
														onClick={() => setMobileMenuOpen(false)}
													>
														Admin Dashboard
													</a>
												</li>
											)}
											<li>
												<button
													onClick={() => {
														setMobileMenuOpen(false);
														handleLogout();
													}}
													className="block w-full text-left px-4 py-3 text-muted-foreground hover:bg-muted hover:text-foreground"
												>
													Logout
												</button>
											</li>
										</>
									) : (
										<li>
											<Link
												href="/login"
												className="block px-4 py-3 text-muted-foreground hover:bg-muted hover:text-foreground"
												onClick={() => setMobileMenuOpen(false)}
											>
												Login
											</Link>
										</li>
									)}
								</>
							)}
						</ul>
					</nav>
				</div>
			)}
		</header>
	);
};

export default Header;
</file>

<file path="frontend/src/components/technique/TechniquesSidebar.tsx">
"use client";

import React from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Slider } from "@/components/ui/slider";
import { ArrowRightFromLine, ChevronLeft, Search } from "lucide-react";
import { AssuranceGoal, Category } from "@/lib/types";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import {
	Accordion,
	AccordionContent,
	AccordionItem,
	AccordionTrigger,
} from "@/components/ui/accordion";
import GoalIcon from "./GoalIcon";
import CategoryTag from "./CategoryTag";

// Export this interface so it can be imported by TechniquesList.tsx
export interface FilterState {
	search: string;
	assurance_goals: string[];
	categories: string[];
	model_dependency: string[];
	complexity_max?: number;
	computational_cost_max?: number;
}

interface TechniquesSidebarProps {
	// Filter state
	filters: FilterState;
	setFilters: (filters: FilterState) => void;
	applyFilters: (filters?: FilterState) => void; // Updated to accept optional filters
	resetFilters: () => void;

	// Data for populating filters
	assuranceGoals?: AssuranceGoal[];
	categories?: Category[];
	isDataLoading: boolean;

	// Mobile state
	isMobileOpen: boolean;
	setIsMobileOpen: (isOpen: boolean) => void;

	// New prop to control showing toggle in header
	allowToggle?: boolean;
}

export const TechniquesSidebar: React.FC<TechniquesSidebarProps> = ({
	filters,
	setFilters,
	applyFilters,
	resetFilters,
	assuranceGoals = [],
	categories = [],
	isDataLoading,
	isMobileOpen,
	setIsMobileOpen,
	allowToggle = false,
}) => {
	// Toggle sidebar on mobile
	const toggleSidebar = () => {
		setIsMobileOpen(!isMobileOpen);
	};

	// Helper to update a specific filter value
	const updateFilter = <K extends keyof FilterState>(
		key: K,
		value: FilterState[K]
	) => {
		console.log(`UpdateFilter called for ${key} with value:`, value);
		// Only update state, don't apply filters
		setFilters({ ...filters, [key]: value });
		console.log("Filter state updated, waiting for Apply button");
	};

	// Helper to toggle an item in an array filter without immediately applying
	const toggleArrayFilter = (key: keyof FilterState, itemId: string) => {
		console.log(`Toggling ${key} filter with value: ${itemId}`);
		const currentValues = filters[key] as string[];

		const newValues = currentValues.includes(itemId)
			? currentValues.filter((id) => id !== itemId)
			: [...currentValues, itemId];

		// Update filter state without applying immediately
		updateFilter(key, newValues as FilterState[typeof key]);
		console.log(`${key} filter updated, but not applied - waiting for Apply button`);
	};

	return (
		<div className={`bg-background border overflow-hidden ${isMobileOpen ? 'md:relative md:rounded-lg md:shadow-sm fixed inset-0 z-50' : 'rounded-lg shadow-sm'}`}>
			{/* Mobile filter panel content wrapper */}
			<div className={`${isMobileOpen ? 'h-full flex flex-col md:block' : ''}`}>
			{/* Overlay to capture clicks outside the sidebar on mobile */}
			{isMobileOpen && (
				<div
					className="fixed inset-0 bg-black/30 md:hidden"
					style={{ zIndex: -1 }}
					onClick={toggleSidebar}
					aria-hidden="true"
				/>
			)}
			{/* Sidebar header */}
			<div className="p-4 border-b flex items-center justify-between sticky top-0 bg-background z-10">
				<h2 className="font-semibold text-lg">Filters</h2>
				<div className="flex gap-2">
					{/* Toggle button for desktop */}
					{allowToggle && (
						<Button
							variant="outline"
							size="sm"
							onClick={toggleSidebar}
							className="hidden md:flex items-center"
							aria-label="Hide filters"
						>
							<ChevronLeft className="h-4 w-4 mr-2" />
							Hide
						</Button>
					)}

					{/* Close button for mobile only */}
					<Button
						variant="outline"
						size="sm"
						onClick={toggleSidebar}
						className="md:hidden"
						aria-label="Close filters"
					>
						<ArrowRightFromLine className="h-4 w-4" />
					</Button>
				</div>
			</div>
			{/* Filters */}
			<div className="overflow-y-auto py-2 bg-background flex-1 md:h-auto md:max-h-[calc(100vh-170px)]">
				<div className="p-4">
					<div className="relative">
						<Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
						<Input
							placeholder="Search techniques..."
							value={filters.search}
							onChange={(e) => {
								updateFilter("search", e.target.value);
							}}
							className="w-full pl-8"
							onKeyDown={(e) => {
								if (e.key === "Enter") {
									applyFilters(filters);
								}
							}}
						/>
					</div>
					
					{/* Action buttons for both mobile and desktop - shown at top on desktop, hidden on mobile */}
					<div className="hidden md:flex flex-row gap-2 mt-4">
						<Button
							onClick={() => applyFilters(filters)}
							variant="default"
							className="flex-1 font-medium"
							size="default"
						>
							Apply Filters
						</Button>
						<Button
							onClick={resetFilters}
							variant="outline"
							className="flex-1"
							size="sm"
						>
							Reset
						</Button>
					</div>
				</div>

				<Accordion
					type="multiple"
					defaultValue={[
						"assurance_goals",
						"model_dependency",
						"ratings",
					]}
				>
					{/* Assurance Goals Filter */}
					<AccordionItem value="assurance_goals">
						<AccordionTrigger className="px-4">
							Assurance Goals
						</AccordionTrigger>
						<AccordionContent className="px-4">
							{isDataLoading ? (
								<div className="text-sm text-muted-foreground py-2">
									Loading...
								</div>
							) : (
								<div className="space-y-3">
									{assuranceGoals?.map((goal) => (
										<div
											key={goal.id}
											className="flex items-start space-x-2"
										>
											<Checkbox
												id={`goal-${goal.id}`}
												checked={filters.assurance_goals.includes(
													goal.id.toString()
												)}
												onCheckedChange={() =>
													toggleArrayFilter(
														"assurance_goals",
														goal.id.toString()
													)
												}
											/>
											<Label
												htmlFor={`goal-${goal.id}`}
												className="flex items-center gap-2 cursor-pointer text-sm font-normal"
											>
												<GoalIcon
													goalName={goal.name}
													size={16}
												/>
												<span>{goal.name}</span>
											</Label>
										</div>
									))}
								</div>
							)}
						</AccordionContent>
					</AccordionItem>

					{/* Categories Filter */}
					<AccordionItem value="categories">
						<AccordionTrigger className="px-4">
							Categories
						</AccordionTrigger>
						<AccordionContent className="px-4">
							{isDataLoading ? (
								<div className="text-sm text-muted-foreground py-2">
									Loading...
								</div>
							) : (
								<div className="space-y-3">
									{categories?.map((category) => (
										<div
											key={category.id}
											className="flex items-start space-x-2"
										>
											<Checkbox
												id={`category-${category.id}`}
												checked={filters.categories.includes(
													category.id.toString()
												)}
												onCheckedChange={() =>
													toggleArrayFilter(
														"categories",
														category.id.toString()
													)
												}
											/>
											<Label
												htmlFor={`category-${category.id}`}
												className="cursor-pointer text-sm font-normal"
											>
												<CategoryTag
													name={category.name}
												/>
											</Label>
										</div>
									))}
								</div>
							)}
						</AccordionContent>
					</AccordionItem>

					{/* Model Dependency Filter */}
					<AccordionItem value="model_dependency">
						<AccordionTrigger className="px-4">
							Model Dependency
						</AccordionTrigger>
						<AccordionContent className="px-4">
							<div className="space-y-3">
								{["Model-Agnostic", "Model-Specific"].map(
									(dependency) => (
										<div
											key={dependency}
											className="flex items-start space-x-2"
										>
											<Checkbox
												id={`dependency-${dependency}`}
												checked={filters.model_dependency.includes(
													dependency
												)}
												onCheckedChange={() =>
													toggleArrayFilter(
														"model_dependency",
														dependency
													)
												}
											/>
											<Label
												htmlFor={`dependency-${dependency}`}
												className="cursor-pointer text-sm font-normal"
											>
												{dependency}
											</Label>
										</div>
									)
								)}
							</div>
						</AccordionContent>
					</AccordionItem>

					{/* Ratings Filter */}
					<AccordionItem value="ratings">
						<AccordionTrigger className="px-4">
							Ratings
						</AccordionTrigger>
						<AccordionContent className="px-4">
							<div className="space-y-6">
								{/* Complexity Rating - With visible steps */}
								<div className="space-y-3">
									<h4 className="text-sm font-medium">
										Maximum Complexity
									</h4>
									<div className="pt-2 pb-1">
										<Slider
											value={[
												filters.complexity_max || 5,
											]}
											min={1}
											max={5}
											step={1}
											onValueChange={(value) => {
												console.log(`Changing complexity_max to: ${value[0]}`);
												updateFilter(
													"complexity_max",
													value[0]
												);
												console.log("Complexity updated, but not applied - waiting for Apply button");
											}}
										/>
									</div>
									<div className="flex justify-between text-xs text-muted-foreground">
										<span>1</span>
										<span>2</span>
										<span>3</span>
										<span>4</span>
										<span>5</span>
									</div>
									<div className="flex justify-between text-xs text-muted-foreground">
										<span>Simple</span>
										<span className="ml-auto">Complex</span>
									</div>
								</div>

								{/* Computational Cost Rating - With visible steps */}
								<div className="space-y-3">
									<h4 className="text-sm font-medium">
										Maximum Computational Cost
									</h4>
									<div className="pt-2 pb-1">
										<Slider
											value={[
												filters.computational_cost_max ||
													5,
											]}
											min={1}
											max={5}
											step={1}
											onValueChange={(value) => {
												console.log(`Changing computational_cost_max to: ${value[0]}`);
												updateFilter(
													"computational_cost_max",
													value[0]
												);
												console.log("Computational cost updated, but not applied - waiting for Apply button");
											}}
										/>
									</div>
									<div className="flex justify-between text-xs text-muted-foreground">
										<span>1</span>
										<span>2</span>
										<span>3</span>
										<span>4</span>
										<span>5</span>
									</div>
									<div className="flex justify-between text-xs text-muted-foreground">
										<span>Low</span>
										<span className="ml-auto">High</span>
									</div>
								</div>
							</div>
						</AccordionContent>
					</AccordionItem>
				</Accordion>
			</div>

			{/* Mobile-only action buttons at the bottom */}
			<div className="sticky bottom-0 p-4 bg-background border-t shadow-md z-10 md:hidden">
				<div className="flex flex-col gap-2">
					<Button
						onClick={() => applyFilters(filters)}
						variant="default"
						className="w-full font-medium"
						size="default"
					>
						Apply Filters
					</Button>
					<Button
						onClick={resetFilters}
						variant="outline"
						className="w-full"
						size="sm"
					>
						Reset Filters
					</Button>
				</div>
			</div>
			</div>
		</div>
	);
};

export default TechniquesSidebar;
</file>

<file path=".env.example">
# Rename this file to .env and update the values as needed

#######################################
# Backend settings
#######################################

# General
SECRET_KEY=change-this-in-production
# Use 'config.settings.development', 'config.settings.production', 'config.settings.sqlite', 'config.settings.docker'
DJANGO_SETTINGS_MODULE=config.settings.development 

# Environment-specific settings
# You can override these in your specific settings module
DEBUG=True
ALLOWED_HOSTS=localhost,127.0.0.1

# Database settings 
# (only needed when using PostgreSQL-based settings)
DB_NAME=techniques
DB_USER=postgres
DB_PASSWORD=postgres
DB_HOST=localhost
DB_PORT=5432

# CORS settings (comma-separated list)
CORS_ALLOWED_ORIGINS=http://localhost:3000,http://localhost:3001,http://127.0.0.1:3000,http://frontend:3000

#######################################
# Frontend settings
#######################################

# Public variables (available in browser)
NEXT_PUBLIC_API_URL=/api
NEXT_PUBLIC_SWAGGER_URL=/swagger/

# Server-side variables
NODE_ENV=development

# For server-side API requests in Next.js
# Use http://backend:8000 in Docker, http://localhost:8000 for local development
BACKEND_URL=http://localhost:8000
</file>

<file path="deploy-tailscale.sh">
#!/bin/bash
# deploy-tailscale.sh - Deployment script for Tailscale server using Docker Compose profiles

# Exit immediately if a command exits with a non-zero status.
set -e

# --- Configuration ---
TAILSCALE_ENV_FILE=".env.tailscale"
NGINX_TEMPLATE_FILE="nginx/tea-techniques.conf.template"
NGINX_OUTPUT_FILE="nginx/tea-techniques.conf"
DOCKER_COMPOSE_CMD="docker compose --env-file ${TAILSCALE_ENV_FILE}" # Use the specific env file for all compose commands

# --- Pre-flight Checks ---
echo "🚀 Starting Tailscale Deployment for Tea Techniques..."
echo "=================================================="

# 1. Check if .env.tailscale exists
if [ ! -f "$TAILSCALE_ENV_FILE" ]; then
  echo "❌ Error: Environment file '$TAILSCALE_ENV_FILE' not found."
  if [ -f "${TAILSCALE_ENV_FILE}.example" ]; then
    echo "ℹ️ An example file exists at '${TAILSCALE_ENV_FILE}.example'. Please copy and configure it."
  fi
  exit 1
else
  echo "✅ Found environment file: $TAILSCALE_ENV_FILE"
  # Load environment variables from .env.tailscale for use *within this script* (e.g., for envsubst)
  set -a
  source "$TAILSCALE_ENV_FILE"
  set +a
fi

# 2. Check if Nginx template exists
if [ ! -f "$NGINX_TEMPLATE_FILE" ]; then
  echo "❌ Error: Nginx template file '$NGINX_TEMPLATE_FILE' not found."
  exit 1
else
   echo "✅ Found Nginx template: $NGINX_TEMPLATE_FILE"
fi

# 3. Check for required tools
if ! command -v docker &> /dev/null || ! command -v docker compose &> /dev/null; then
    echo "❌ Error: 'docker' and 'docker compose' (v2) are required but not found."
    exit 1
fi
if ! command -v envsubst &> /dev/null; then
    echo "❌ Error: 'envsubst' (usually part of gettext package) is required but not found."
    echo "ℹ️ On Debian/Ubuntu: sudo apt-get update && sudo apt-get install gettext-base"
    echo "ℹ️ On Arch Linux: sudo pacman -S gettext"
    echo "ℹ️ On macOS (Homebrew): brew install gettext && brew link --force gettext"
    exit 1
fi
echo "✅ Required tools found."

# --- Deployment Steps ---

# 4. Stop existing services defined in the compose file
echo ""
echo "🛑 Stopping existing containers (if any)..."
$DOCKER_COMPOSE_CMD down --remove-orphans || echo "ℹ️ No running containers to stop or failed to stop."

# 5. Clean up old volumes (optional, ensures completely fresh state)
read -p "❓ Do you want to remove existing database and log volumes? (y/N): " -n 1 -r
echo # Move to a new line
if [[ $REPLY =~ ^[Yy]$ ]]; then
    echo "🗑️ Removing volumes..."
    docker volume rm $(docker volume ls -q | grep tea-techniques_postgres_data) &>/dev/null || echo "ℹ️ No database volume to remove or removal failed."
    docker volume rm $(docker volume ls -q | grep tea-techniques_nginx_logs) &>/dev/null || echo "ℹ️ No nginx logs volume to remove or removal failed."
else
    echo "⏭️ Skipping volume removal."
fi

# 6. Generate Nginx Configuration from template
echo ""
echo "⚙️ Generating Nginx configuration file..."
mkdir -p "$(dirname "$NGINX_OUTPUT_FILE")" # Ensure directory exists
# Use envsubst to replace variables sourced from .env.tailscale
if envsubst < "$NGINX_TEMPLATE_FILE" > "$NGINX_OUTPUT_FILE"; then
  echo "   ✅ Generated '$NGINX_OUTPUT_FILE'"
else
  echo "❌ Error: Failed to generate Nginx config from template. Check variables in '$TAILSCALE_ENV_FILE'."
  exit 1
fi

# 7. Build/Pull images and start containers in detached mode
#    Crucially, we DO NOT specify '--profile dev' here, so only base services run
echo ""
echo "🏗️ Building/Pulling images and starting containers (production mode)..."
if $DOCKER_COMPOSE_CMD build --no-cache; then # Build with no cache for latest code
  echo "   ✅ Build successful."
else
  echo "❌ Error: Docker build failed. Check build logs."
  exit 1
fi

if $DOCKER_COMPOSE_CMD up -d; then # Start services without dev profile
  echo "   ✅ Containers started."
else
  echo "❌ Error: Failed to start containers. Check logs with '$DOCKER_COMPOSE_CMD logs'."
  exit 1
fi

# 8. Wait for services to become healthy
echo ""
echo "⏳ Waiting for services to become healthy (up to 60 seconds)..."
sleep 10 # Initial wait
attempts=0
max_attempts=10 # Wait for max 50 more seconds (10*5s)
while [ $attempts -lt $max_attempts ]; do
  if ! $DOCKER_COMPOSE_CMD ps | grep -v EXIT | grep -q unhealthy; then
    echo "✅ All services appear healthy."
    break
  fi
  attempts=$((attempts+1))
  echo "   Waiting... (attempt $attempts/$max_attempts)"
  sleep 5
done

if [ $attempts -eq $max_attempts ]; then
    echo "⚠️ Warning: Some services might still be unhealthy after waiting."
    echo "   Check detailed status with: $DOCKER_COMPOSE_CMD ps"
    echo "   Check logs with: $DOCKER_COMPOSE_CMD logs <service_name>"
    # Decide if you want to exit here or continue
    # exit 1
fi

# 9. Run Database Migrations and Data Import
echo ""
echo "💾 Setting up database (migrations, import)..."
echo "   Running Migrations..."
if $DOCKER_COMPOSE_CMD exec -T backend python manage.py migrate --noinput; then
  echo "   ✅ Migrations applied successfully."
else
  echo "❌ Error: Database migrations failed. Check backend logs."
  # exit 1 # Optional: exit on migration failure
fi

echo "   Importing Techniques (if database is empty)..."
# Check count first to avoid re-importing unnecessarily
TECHNIQUE_COUNT=$($DOCKER_COMPOSE_CMD exec -T backend python -c "from api.models import Technique; print(Technique.objects.count())" 2>/dev/null || echo "0")
echo "   Current technique count: $TECHNIQUE_COUNT"
if [ "$TECHNIQUE_COUNT" = "0" ]; then
  if $DOCKER_COMPOSE_CMD exec -T backend python manage.py import_techniques; then
    FINAL_COUNT=$($DOCKER_COMPOSE_CMD exec -T backend python -c "from api.models import Technique; print(Technique.objects.count())" 2>/dev/null || echo "Error")
    echo "   ✅ Techniques imported successfully. New count: $FINAL_COUNT"
  else
    echo "⚠️ Warning: Technique import failed or was skipped. Check backend logs."
  fi
else
    echo "   ⏭️ Skipping import as techniques already exist."
fi

echo "   Ensuring Admin User Exists..."
if $DOCKER_COMPOSE_CMD exec -T backend python manage.py shell -c "from django.contrib.auth.models import User; User.objects.create_superuser('admin', 'admin@example.com', '${ADMIN_PASSWORD:-admin}') if not User.objects.filter(username='admin').exists() else print('Admin already exists')"; then
  echo "   ✅ Admin user check complete."
else
  echo "⚠️ Warning: Could not ensure admin user exists."
fi

# 10. Setup Tailscale Funnel
echo ""
echo "🌐 Setting up Tailscale Funnel..."
if [ "$EUID" -eq 0 ] && command -v tailscale &> /dev/null; then
  echo "   Resetting existing funnel..."
  tailscale funnel reset || echo "   ℹ️ No existing funnel to reset or reset failed."
  sleep 2
  echo "   Starting funnel on port 80 in background..."
  if tailscale funnel --bg 80; then
    echo "   ✅ Tailscale funnel started."
    echo "   Funnel status:"
    tailscale funnel status
  else
    echo "❌ Error: Failed to start Tailscale funnel."
  fi
else
  echo "⚠️ WARNING: Not running as root or 'tailscale' command not found."
  echo "   Skipping automated Tailscale funnel setup."
  echo "   To enable external access, run manually as root:"
  echo "     tailscale funnel reset && sleep 2 && tailscale funnel --bg 80"
fi

# --- Completion ---
echo ""
echo "✅ Deployment Complete!"
echo "========================================"

if [ -n "$TAILSCALE_DOMAIN" ]; then
  echo "   Your application should be accessible at: https://${TAILSCALE_DOMAIN}"
  echo "   API Docs (Swagger): https://${TAILSCALE_DOMAIN}/swagger/"
else
  echo "   Your application is running, but TAILSCALE_DOMAIN was not found in $TAILSCALE_ENV_FILE."
  echo "   Access may be limited to your local network or Tailnet."
fi
echo ""
</file>

<file path="backend/api/models.py">
from __future__ import annotations

from django.db import models
from django.db.models.query import QuerySet
from typing import Dict, List, Optional, Any, Union, cast


class AssuranceGoal(models.Model):
    """
    Represents a high-level assurance goal for AI systems.
    
    Assurance goals are the broadest categorization of techniques, representing
    what the technique aims to achieve in terms of AI safety or quality assurance.
    Examples include fairness, robustness, explainability, etc.
    """
    name: models.CharField = models.CharField(max_length=255, unique=True)
    description: models.TextField = models.TextField()

    class Meta:
        db_table = "assurance_goal"
        verbose_name_plural = "Assurance Goals"

    def __str__(self) -> str:
        return self.name


class Category(models.Model):
    """
    Represents a category within an assurance goal.
    
    Categories provide the second level of classification for techniques,
    organizing techniques into logical groups under each assurance goal.
    A category belongs to exactly one assurance goal.
    """
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    assurance_goal = models.ForeignKey(AssuranceGoal, on_delete=models.CASCADE)

    class Meta:
        db_table = "category"
        verbose_name_plural = "Categories"
        unique_together = ("name", "assurance_goal")

    def __str__(self) -> str:
        return f"{self.name} ({self.assurance_goal.name})"


class SubCategory(models.Model):
    """
    Represents a subcategory within a category.
    
    Subcategories provide the third level of classification for techniques,
    allowing for more specific grouping of related techniques.
    A subcategory belongs to exactly one category.
    """
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    category = models.ForeignKey(
        Category, on_delete=models.CASCADE, related_name="subcategories"
    )

    class Meta:
        db_table = "subcategory"
        verbose_name_plural = "Subcategories"
        unique_together = ("name", "category")

    def __str__(self) -> str:
        return f"{self.name} ({self.category.name})"


class Tag(models.Model):
    """
    Represents a generic tag that can be applied to techniques.
    
    Tags provide a flexible, non-hierarchical way to classify techniques
    based on various attributes or properties, complementing the hierarchical
    classification system of goals, categories, and subcategories.
    """
    name = models.CharField(max_length=255, unique=True)

    class Meta:
        db_table = "tag"

    def __str__(self) -> str:
        return self.name


class ResourceType(models.Model):
    """
    Represents a type of resource associated with techniques.
    
    Resource types categorize the different kinds of resources that can be
    linked to techniques, such as papers, websites, tools, implementations, etc.
    """
    name = models.CharField(max_length=100, unique=True)
    icon = models.CharField(max_length=50, blank=True)

    class Meta:
        db_table = "resource_type"

    def __str__(self) -> str:
        return self.name


class Technique(models.Model):
    """
    Represents an AI assurance technique.
    
    This is the central model in the application, representing individual techniques
    that can be applied to AI systems for various assurance purposes. Each technique
    includes detailed information about its purpose, implementation, cost, and 
    relationships to goals, categories, and other classification systems.
    """
    name = models.CharField(max_length=255, unique=True)
    description = models.TextField()
    model_dependency = models.CharField(max_length=100)
    category_tags = models.CharField(
        max_length=500, blank=True, 
        help_text="Format: #category/subcategory (DEPRECATED: Use categories/subcategories relationships instead)"
    )
    complexity_rating = models.PositiveSmallIntegerField(null=True, blank=True)
    computational_cost_rating = models.PositiveSmallIntegerField(null=True, blank=True)
    applicable_models = models.JSONField(
        null=True,
        blank=True,
        help_text="List of model types this technique is applicable to (for model-specific techniques)",
    )
    assurance_goals = models.ManyToManyField(AssuranceGoal, related_name="techniques")
    categories = models.ManyToManyField(Category, related_name="techniques")
    subcategories = models.ManyToManyField(
        SubCategory, related_name="techniques", blank=True
    )
    tags = models.ManyToManyField(Tag, related_name="techniques", blank=True)

    class Meta:
        db_table = "technique"

    def __str__(self) -> str:
        return self.name


class AttributeType(models.Model):
    """
    Represents a type of attribute that can characterize techniques.
    
    Attribute types define various characteristics by which techniques can be
    described, such as 'prerequisites', 'output format', 'implementation complexity', etc.
    These provide a flexible way to add structured metadata to techniques.
    """
    name = models.CharField(max_length=255, unique=True)
    description = models.TextField(blank=True)

    class Meta:
        db_table = "attribute_type"

    def __str__(self) -> str:
        return self.name


class AttributeValue(models.Model):
    """
    Represents a specific value for an attribute type, associated with a technique.
    
    AttributeValue links a technique to a specific value for a given attribute type,
    creating a flexible system for storing structured metadata about techniques.
    For example, a technique might have an attribute type of 'Implementation Effort'
    with a value of 'High'.
    """
    attribute_type = models.ForeignKey(
        AttributeType, on_delete=models.CASCADE, related_name="values"
    )
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True)

    technique = models.ForeignKey(
        Technique, on_delete=models.CASCADE, related_name="attribute_values"
    )

    class Meta:
        db_table = "attribute_value"
        unique_together = ("attribute_type", "name", "technique")

    def __str__(self) -> str:
        return f"{self.attribute_type.name}: {self.name}"


class TechniqueResource(models.Model):
    """
    Represents an external resource associated with a technique.
    
    TechniqueResource stores references to external materials related to a technique,
    such as academic papers, websites, code repositories, tools, etc. These resources
    provide additional information, implementations, or examples of the technique.
    """
    technique = models.ForeignKey(
        Technique, on_delete=models.CASCADE, related_name="resources"
    )
    resource_type = models.ForeignKey(ResourceType, on_delete=models.PROTECT)
    title = models.CharField(max_length=255)
    url = models.URLField()
    description = models.TextField(blank=True)
    authors = models.CharField(max_length=500, blank=True, null=True)
    publication_date = models.CharField(max_length=50, blank=True, null=True)
    source_type = models.CharField(max_length=100, blank=True, null=True)

    class Meta:
        db_table = "technique_resource"
        unique_together = ("technique", "url")

    def __str__(self) -> str:
        return f"{self.resource_type.name}: {self.title}"


class TechniqueExampleUseCase(models.Model):
    """
    Represents an example use case for a technique.
    
    TechniqueExampleUseCase stores concrete examples of how a technique can be
    applied in practice, providing context for users to understand when and how
    to use the technique. Each use case can be associated with a specific assurance
    goal to clarify its purpose.
    """
    technique = models.ForeignKey(
        Technique, on_delete=models.CASCADE, related_name="example_use_cases"
    )
    description = models.TextField()
    assurance_goal = models.ForeignKey(
        AssuranceGoal, on_delete=models.CASCADE, null=True, blank=True
    )

    class Meta:
        db_table = "technique_example_use_case"

    def __str__(self) -> str:
        return f"Use case for {self.technique.name}"


class TechniqueLimitation(models.Model):
    """
    Represents a limitation or constraint of a technique.
    
    TechniqueLimitation documents the known limitations, constraints, or cautionary
    notes about a technique. This helps users understand the boundaries and potential
    drawbacks of each technique, enabling more informed decisions about when to apply it.
    """
    technique = models.ForeignKey(
        Technique, on_delete=models.CASCADE, related_name="limitations"
    )
    description = models.TextField()

    class Meta:
        db_table = "technique_limitation"

    def __str__(self) -> str:
        return f"Limitation for {self.technique.name}"
</file>

<file path="backend/api/serializers.py">
# api/serializers.py
"""
Serializers for the API application.

This module contains serializers for all models in the API application.
Serializers handle converting between Python objects and JSON representations,
as well as validation of input data.
"""

from __future__ import annotations

from rest_framework import serializers
import logging
from typing import Any, Dict, List, Optional, Union, cast

from .models import (
    AssuranceGoal,
    Category,
    SubCategory,
    Tag,
    ResourceType,
    Technique,
    AttributeType,
    AttributeValue,
    TechniqueResource,
    TechniqueExampleUseCase,
    TechniqueLimitation,
)

# Set up logger
logger = logging.getLogger(__name__)


class AssuranceGoalSerializer(serializers.ModelSerializer):
    """
    Serializer for the AssuranceGoal model.
    
    Serializes all fields of the AssuranceGoal model without any additional fields.
    """
    class Meta:
        model = AssuranceGoal
        fields = "__all__"


class CategorySerializer(serializers.ModelSerializer):
    """
    Serializer for the Category model.
    
    Includes the name of the associated AssuranceGoal as a read-only field.
    """
    assurance_goal_name = serializers.ReadOnlyField(source="assurance_goal.name")

    class Meta:
        model = Category
        fields = ["id", "name", "description", "assurance_goal", "assurance_goal_name"]


class SubCategorySerializer(serializers.ModelSerializer):
    """
    Serializer for the SubCategory model.
    
    Includes the name of the associated Category as a read-only field.
    """
    category_name = serializers.ReadOnlyField(source="category.name")

    class Meta:
        model = SubCategory
        fields = ["id", "name", "description", "category", "category_name"]


class TagSerializer(serializers.ModelSerializer):
    """
    Serializer for the Tag model.
    
    Serializes all fields of the Tag model without any additional fields.
    """
    class Meta:
        model = Tag
        fields = "__all__"


class AttributeTypeSerializer(serializers.ModelSerializer):
    """
    Serializer for the AttributeType model.
    
    Serializes all fields of the AttributeType model without any additional fields.
    """
    class Meta:
        model = AttributeType
        fields = "__all__"


class AttributeValueSerializer(serializers.ModelSerializer):
    """
    Serializer for the AttributeValue model.
    
    Includes the name of the associated AttributeType as a read-only field.
    """
    attribute_type_name = serializers.ReadOnlyField(source="attribute_type.name")

    class Meta:
        model = AttributeValue
        fields = [
            "id",
            "attribute_type",
            "attribute_type_name",
            "name",
            "description",
            "technique",
        ]


class ResourceTypeSerializer(serializers.ModelSerializer):
    """
    Serializer for the ResourceType model.
    
    Serializes all fields of the ResourceType model without any additional fields.
    """
    class Meta:
        model = ResourceType
        fields = "__all__"


class TechniqueResourceSerializer(serializers.ModelSerializer):
    """
    Serializer for the TechniqueResource model.
    
    Includes the name of the associated ResourceType as a read-only field.
    """
    resource_type_name = serializers.ReadOnlyField(source="resource_type.name")

    class Meta:
        model = TechniqueResource
        fields = [
            "id",
            "resource_type",
            "resource_type_name",
            "title",
            "url",
            "description",
            "authors",
            "publication_date",
            "source_type",
        ]


class TechniqueExampleUseCaseSerializer(serializers.ModelSerializer):
    """
    Serializer for the TechniqueExampleUseCase model.
    
    Includes the name of the associated AssuranceGoal as a computed field.
    Handles the case where assurance_goal might be None.
    """
    assurance_goal_name = serializers.SerializerMethodField()

    class Meta:
        model = TechniqueExampleUseCase
        fields = ["id", "description", "assurance_goal", "assurance_goal_name"]

    def get_assurance_goal_name(self, obj: TechniqueExampleUseCase) -> Optional[str]:
        """Return the name of the associated assurance goal, or None if not set."""
        if obj.assurance_goal:
            return obj.assurance_goal.name
        return None


class TechniqueLimitationSerializer(serializers.ModelSerializer):
    """
    Serializer for the TechniqueLimitation model.
    
    Only includes the id and description fields.
    """
    class Meta:
        model = TechniqueLimitation
        fields = ["id", "description"]


class TechniqueSerializer(serializers.ModelSerializer):
    """
    Serializer for the Technique model.
    
    Includes nested serializers for all related models, providing a comprehensive
    representation of a technique and all its associated data. All relationship
    fields are read-only in this serializer.
    """
    # Relationship fields
    assurance_goals = AssuranceGoalSerializer(many=True, read_only=True)
    categories = CategorySerializer(many=True, read_only=True)
    subcategories = SubCategorySerializer(many=True, read_only=True)
    tags = TagSerializer(many=True, read_only=True)

    # Additional relationship fields - note the change from attributes to attribute_values
    attribute_values = AttributeValueSerializer(many=True, read_only=True)
    resources = TechniqueResourceSerializer(many=True, read_only=True)
    example_use_cases = TechniqueExampleUseCaseSerializer(many=True, read_only=True)
    limitations = TechniqueLimitationSerializer(many=True, read_only=True)
    
    # Add a dummy field for applicable_models if it doesn't exist in the database
    applicable_models = serializers.SerializerMethodField()
    
    def get_applicable_models(self, obj: Technique) -> List[str]:
        """
        Get the applicable_models field from the Technique object.
        Returns an empty list if the field doesn't exist or is None.
        """
        try:
            if hasattr(obj, 'applicable_models') and obj.applicable_models is not None:
                return cast(List[str], obj.applicable_models)
            return []
        except Exception as e:
            logger.warning(f"Error accessing applicable_models: {str(e)}")
            return []

    class Meta:
        model = Technique
        fields = [
            "id",
            "name",
            "description",
            "model_dependency",
            "category_tags",
            "complexity_rating",
            "computational_cost_rating",
            "assurance_goals",
            "categories",
            "subcategories",
            "tags",
            "attribute_values",
            "resources",
            "example_use_cases",
            "limitations",
            "applicable_models",
        ]
</file>

<file path="frontend/src/app/techniques/[id]/page.tsx">
// src/app/techniques/[id]/page.tsx
"use client";

import { useParams } from "next/navigation";
import { useEffect } from "react";
import MainLayout from "@/components/layout/MainLayout";
import { useTechniqueDetail } from "@/lib/api/hooks";
import { Button } from "@/components/ui/button";
import {
	Card,
	CardContent,
	CardHeader,
	CardTitle,
	CardFooter,
} from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { TooltipProvider } from "@/components/ui/tooltip";
import { StarRating } from "@/components/ui/star-rating";
import Link from "next/link";
import {
	ArrowLeft,
	ArrowRight,
	Brain,
	CheckCircle,
	Cpu,
	Edit,
	Eye,
	ExternalLink,
	FileCode2,
	Book,
	Package,
	GraduationCap,
	Info,
	Loader2,
	Lock,
	NotebookText,
	Rss,
	Scale,
	Scroll,
	Shield,
	ShieldCheck,
} from "lucide-react";
import {
	TechniqueResource,
	TechniqueExampleUseCase,
	TechniqueLimitation,
	AttributeValue,
} from "@/lib/types";

// Utility function to find applicable models for model-specific techniques
// This simulates what we would expect from the backend API when updated
function findApplicableModels(techniqueId: number): string[] {
	// Sample data based on model-specific.json structure
	const modelSpecificData = {
		"Tree-based Models": {
			techniques: [
				{
					id: 3,
					name: "Mean Decrease Impurity",
					applicable_models: [
						"Decision Trees",
						"Random Forests",
						"Gradient Boosting Models",
					],
				},
				{
					id: 4,
					name: "Gini Importance",
					applicable_models: ["Decision Trees", "Random Forests"],
				},
				{
					id: 9,
					name: "Variable Importance in Random Forests (MDA MDG)",
					applicable_models: ["Random Forests"],
				},
			],
		},
		"Linear Models": {
			techniques: [
				{
					id: 5,
					name: "Coefficient Magnitudes (in Linear Models)",
					applicable_models: [
						"Linear Regression",
						"Logistic Regression",
						"Ridge Regression",
						"Lasso Regression",
					],
				},
			],
		},
		"Neural Networks": {
			techniques: [
				{
					id: 6,
					name: "Integrated Gradients",
					applicable_models: [
						"General Neural Networks",
						"CNNs",
						"RNNs",
						"Transformers",
					],
				},
				{
					id: 7,
					name: "DeepLIFT",
					applicable_models: [
						"General Neural Networks",
						"CNNs",
						"RNNs",
					],
				},
				{
					id: 8,
					name: "Layer-wise Relevance Propagation (LRP)",
					applicable_models: [
						"General Neural Networks",
						"CNNs",
						"RNNs",
					],
				},
			],
		},
	};

	// Search through all categories and techniques to find the matching ID
	for (const category of Object.values(modelSpecificData)) {
		for (const technique of category.techniques) {
			if (technique.id === techniqueId) {
				return technique.applicable_models || [];
			}
		}
	}

	return [];
}

// Helper component for section containers
function Section({
	title,
	children,
	noBorder = false,
}: {
	title: string;
	children: React.ReactNode;
	noBorder?: boolean;
}) {
	return (
		<div className="mb-8">
			<h2
				className="text-xl font-semibold mb-4"
				id={title.toLowerCase().replace(/\s+/g, "-")}
			>
				{title}
			</h2>
			{noBorder ? (
				<>{children}</>
			) : (
				<div className="bg-card rounded-lg border p-4 shadow-sm">
					{children}
				</div>
			)}
		</div>
	);
}

function TechniqueResources({ resources }: { resources: TechniqueResource[] }) {
	if (!resources || resources.length === 0) {
		return <p className="text-muted-foreground">No resources available.</p>;
	}
	
	// Debug: Log resources to see what we're actually getting from the API
	console.log("Resources from API:", JSON.stringify(resources, null, 2));

	// Function to get the appropriate icon for source type
	const getResourceIcon = (resource: TechniqueResource) => {
		const sourceType = (resource.source_type || "unknown").toLowerCase();
		
		switch (sourceType) {
			case "documentation":
				return <FileCode2 className="h-5 w-5" aria-hidden="true" />;
			case "tutorial":
				return <GraduationCap className="h-5 w-5" aria-hidden="true" />;
			case "software_package":
				return <Package className="h-5 w-5" aria-hidden="true" />;
			case "technical_paper":
				return <NotebookText className="h-5 w-5" aria-hidden="true" />;
			case "review_paper":
				return <Scroll className="h-5 w-5" aria-hidden="true" />;
			case "introductory_paper":
				return <Scroll className="h-5 w-5" aria-hidden="true" />;
			case "paper":
				return <Scroll className="h-5 w-5" aria-hidden="true" />;
			case "blog":
				return <Rss className="h-5 w-5" aria-hidden="true" />;
			case "implementation":
				return <Package className="h-5 w-5" aria-hidden="true" />;
			default:
				return <Book className="h-5 w-5" aria-hidden="true" />;
		}
	};
	

	// Format source type for display
	const formatSourceType = (sourceType: string): string => {
		if (!sourceType) return "Unknown";
		
		// Convert snake_case to Title Case
		return sourceType
			.split(/_|\s/)
			.map(word => word.charAt(0).toUpperCase() + word.slice(1))
			.join(" ");
	};

	return (
		<>
			{resources.map((resource) => (
				<div
					key={resource.id}
					className="border rounded-md p-4 mb-4 hover:border-primary transition-colors"
				>
					<div className="flex">
						<div className="flex-shrink-0 mr-3 mt-1">
							{getResourceIcon(resource)}
						</div>
						
						<div className="flex-grow">
							<div className="flex items-center justify-between">
								<h3 className="font-medium">
									{resource.title}
								</h3>
								<Button
									variant="outline"
									size="sm"
									asChild
									className="flex items-center gap-1"
								>
									<a href={resource.url} target="_blank" rel="noopener noreferrer">
										<ExternalLink
											className="h-4 w-4"
											aria-hidden="true"
										/>
										<span>View Resource</span>
									</a>
								</Button>
							</div>

							{/* Display metadata - all with same style */}
							<div className="mt-2 text-sm text-muted-foreground">
								{resource.source_type && (
									<div>
										Source Type: {formatSourceType(resource.source_type)}
									</div>
								)}
								
								{resource.authors && (
									<div>
										Authors: {resource.authors}
									</div>
								)}
								{resource.publication_date && (
									<div>
										Published: {resource.publication_date}
									</div>
								)}
							</div>

							{resource.description && (
								<p className="text-sm mt-2 text-muted-foreground">
									{resource.description}
								</p>
							)}
						</div>
					</div>
				</div>
			))}
		</>
	);
}

function TechniqueExampleUseCases({
	useCases,
}: {
	useCases: TechniqueExampleUseCase[];
}) {
	if (!useCases || useCases.length === 0) {
		return (
			<p className="text-muted-foreground">
				No example use cases specified.
			</p>
		);
	}

	// Group use cases by assurance goal
	const groupedUseCases = useCases.reduce((acc, useCase) => {
		const goalName = useCase.assurance_goal_name || "Other";
		if (!acc[goalName]) {
			acc[goalName] = [];
		}
		acc[goalName].push(useCase);
		return acc;
	}, {} as Record<string, TechniqueExampleUseCase[]>);

	// Map assurance goals to their respective icons
	const goalIcons = {
		Explainability: <Brain className="h-5 w-5" aria-hidden="true" />,
		Fairness: <Scale className="h-5 w-5" aria-hidden="true" />,
		Security: <Shield className="h-5 w-5" aria-hidden="true" />,
		Safety: <ShieldCheck className="h-5 w-5" aria-hidden="true" />,
		Reliability: <CheckCircle className="h-5 w-5" aria-hidden="true" />,
		Transparency: <Eye className="h-5 w-5" aria-hidden="true" />,
		Privacy: <Lock className="h-5 w-5" aria-hidden="true" />,
		Other: <Info className="h-5 w-5" aria-hidden="true" />,
	};

	return (
		<div className="space-y-8">
			{Object.entries(groupedUseCases).map(([goalName, cases]) => (
				<div key={goalName} className="space-y-4">
					<div className="flex items-center gap-2 text-primary font-medium">
						{goalIcons[goalName as keyof typeof goalIcons] || (
							<Info className="h-5 w-5" aria-hidden="true" />
						)}
						<h3 className="font-medium">{goalName}</h3>
					</div>
					<div className="space-y-4 pl-7">
						{cases.map((useCase) => (
							<div key={useCase.id} className="space-y-1">
								<p className="whitespace-pre-line">
									{useCase.description}
								</p>
							</div>
						))}
					</div>
				</div>
			))}
		</div>
	);
}

// Component to display technique limitations
function TechniqueLimitations({
	limitations,
}: {
	limitations: TechniqueLimitation[];
}) {
	if (!limitations || limitations.length === 0) {
		return (
			<p className="text-muted-foreground">No limitations specified.</p>
		);
	}

	return (
		<div className="space-y-4">
			{limitations.map((limitation) => {
				// No need to parse JSON anymore as the backend now handles it properly
				return (
					<div
						key={limitation.id}
						className="flex items-start gap-2 py-1"
					>
						<ArrowRight
							className="h-4 w-4 text-primary mt-1 flex-shrink-0"
							aria-hidden="true"
						/>
						<span>{limitation.description}</span>
					</div>
				);
			})}
		</div>
	);
}

export default function TechniqueDetailPage() {
	const params = useParams();
	const id = Number(params.id);

	// This would be replaced with actual auth state - for now always false
	const isAuthenticated = false;

	const { data: technique, isLoading, error } = useTechniqueDetail(id);

	// Debug logging - can be removed in production
	useEffect(() => {
		if (technique) {
			console.log("Technique data loaded:", technique);
		}
	}, [technique]);

	if (isLoading) {
		return (
			<MainLayout>
				<div className="flex justify-center items-center py-12">
					<Loader2
						className="h-8 w-8 animate-spin text-primary"
						aria-hidden="true"
					/>
					<span className="ml-2">Loading technique details...</span>
				</div>
			</MainLayout>
		);
	}

	if (error || !technique) {
		return (
			<MainLayout>
				<div className="flex flex-col items-center justify-center py-20">
					<h1 className="text-2xl font-bold mb-4">
						Error Loading Technique
					</h1>
					<p className="text-muted-foreground mb-8">
						There was an error loading this technique. It may not
						exist or you may not have permission to view it.
					</p>
					<Button asChild>
						<Link href="/techniques">Back to Techniques</Link>
					</Button>
				</div>
			</MainLayout>
		);
	}

	const applicableModels =
		technique.model_dependency === "Model-Specific"
			? technique.applicable_models || findApplicableModels(technique.id)
			: [];

	// Helper function to parse category tags
	const parseCategoryTags = (categoryTagsStr: string) => {
		if (!categoryTagsStr) return [];

		return categoryTagsStr
			.split("#")
			.filter((tag) => tag.trim().length > 0)
			.map((tag) => {
				const parts = tag.trim().split("/");
				// Format category name (remove hyphens, title case)
				const formatName = (name: string) => {
					return name
						.split("-")
						.map(
							(word) =>
								word.charAt(0).toUpperCase() + word.slice(1)
						)
						.join(" ");
				};

				return {
					category: formatName(parts[0]),
					subcategory: parts.length > 1 ? formatName(parts[1]) : null,
				};
			});
	};

	const categoryTags = parseCategoryTags(technique.category_tags);

	// Map assurance goals to their respective icons
	const goalIcons = {
		Explainability: <Brain className="h-5 w-5" />,
		Fairness: <Scale className="h-5 w-5" />,
		Security: <Shield className="h-5 w-5" />,
		Safety: <ShieldCheck className="h-5 w-5" />,
		Reliability: <CheckCircle className="h-5 w-5" />,
		Transparency: <Eye className="h-5 w-5" />,
		Privacy: <Lock className="h-5 w-5" />,
	};

	return (
		<TooltipProvider>
			<MainLayout>
				{/* Header section */}
				<div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
					{/* Main content */}
					<div className="lg:col-span-2 space-y-8">
						<div className="mb-6">
							<h1 className="text-3xl font-bold">
								{technique.name}
							</h1>
						</div>
						<Section title="Description">
							<div className="prose max-w-none">
								<p className="whitespace-pre-line">
									{technique.description}
								</p>
							</div>
						</Section>

						<Section title="Example Use Cases">
							<TechniqueExampleUseCases
								useCases={technique.example_use_cases}
							/>
						</Section>

						<Section title="Limitations">
							<TechniqueLimitations
								limitations={technique.limitations}
							/>
						</Section>

						<Section title="Resources" noBorder={true}>
							<TechniqueResources
								resources={technique.resources}
							/>
						</Section>
					</div>

					{/* Sidebar with technique attributes */}
					<div>
						<Card className="sticky top-4 shadow-sm">
							<CardHeader className="pb-3 border-b">
								<CardTitle className="text-lg font-semibold">
									Technique Attributes
									<span
										className="ml-1 inline-flex"
										title="Classification metadata for this technique"
									>
										<Info className="h-4 w-4 text-muted-foreground" />
									</span>
								</CardTitle>
							</CardHeader>
							<CardContent className="space-y-6">
								{/* Assurance Goals with Icons */}
								<div className="space-y-2">
									<h3 className="text-sm font-medium flex items-center">
										Assurance Goals
										<span
											className="ml-1 inline-flex"
											title="The primary goals that this technique helps achieve"
										>
											<Info className="h-4 w-4 text-muted-foreground" />
										</span>
									</h3>
									<div className="flex flex-wrap gap-3">
										{technique.assurance_goals.map(
											(goal) => (
												<div
													key={goal.id}
													className="flex items-center gap-2 p-2 bg-secondary rounded-md"
													title={goal.name}
												>
													{goalIcons[
														goal.name as keyof typeof goalIcons
													] || (
														<Info className="h-5 w-5" />
													)}
													<span className="font-medium text-sm">
														{goal.name}
													</span>
												</div>
											)
										)}
									</div>
								</div>

								{/* Categories (from category tags) */}
								{technique.category_tags &&
									categoryTags.length > 0 && (
										<div className="space-y-2">
											<h3 className="text-sm font-medium flex items-center">
												Categories
												<span
													className="ml-1 inline-flex"
													title="Classification categories for this technique"
												>
													<Info className="h-4 w-4 text-muted-foreground" />
												</span>
											</h3>
											<div className="space-y-2">
												{categoryTags.map(
													(tag, index) => (
														<div
															key={index}
															className="flex justify-between items-center text-sm py-1 border-b last:border-0 border-muted"
														>
															<span>
																{tag.category}
															</span>
															{tag.subcategory && (
																<Badge
																	variant="outline"
																	className="text-xs"
																>
																	{
																		tag.subcategory
																	}
																</Badge>
															)}
														</div>
													)
												)}
											</div>
										</div>
									)}

								{/* Ratings */}
								{technique.complexity_rating ? (
									<div className="space-y-2">
										<h3 className="text-sm font-medium flex items-center">
											Complexity
										</h3>
										<StarRating
											rating={technique.complexity_rating}
											maxRating={5}
											className="text-amber-400"
											aria-label={`Complexity rating: ${technique.complexity_rating} out of 5`}
										/>
									</div>
								) : null}

								{technique.computational_cost_rating ? (
									<div className="space-y-2">
										<h3 className="text-sm font-medium flex items-center">
											Computational Cost
										</h3>
										<StarRating
											rating={
												technique.computational_cost_rating
											}
											maxRating={5}
											className="text-amber-400"
											aria-label={`Computational cost rating: ${technique.computational_cost_rating} out of 5`}
										/>
									</div>
								) : null}

								{/* Model Dependency */}
								<div className="space-y-2">
									<h3 className="text-sm font-medium flex items-center">
										Model Dependency
										<span
											className="ml-1 inline-flex"
											title="Indicates whether this technique requires access to model internals"
										>
											<Info className="h-4 w-4 text-muted-foreground" />
										</span>
									</h3>
									<div>
										<Badge
											variant="outline"
											className="text-sm"
										>
											{technique.model_dependency}
										</Badge>
									</div>
								</div>

								{/* Applicable Models Section (for model-specific techniques) */}
								{technique.model_dependency ===
									"Model-Specific" &&
									applicableModels.length > 0 && (
										<div className="space-y-2">
											<h3 className="text-sm font-medium flex items-center">
												Applicable Models
												<span
													className="ml-1 inline-flex"
													title="Specific model architectures this technique can be applied to"
												>
													<Info className="h-4 w-4 text-muted-foreground" />
												</span>
											</h3>
											<div className="flex flex-wrap gap-2">
												{applicableModels.map(
													(model) => (
														<Badge
															key={model}
															variant="outline"
															className="flex items-center gap-1.5 text-xs py-1"
														>
															<Cpu className="h-3 w-3" />
															<span>{model}</span>
														</Badge>
													)
												)}
											</div>
										</div>
									)}

								{/* Goal-Specific Attributes section */}
								<div className="space-y-3 border-t pt-3">
									<h3 className="text-sm font-medium flex items-center">
										Goal-Specific Attributes
										<span
											className="ml-1 inline-flex"
											title="Attributes specific to the technique's assurance goals"
										>
											<Info className="h-4 w-4 text-muted-foreground" />
										</span>
									</h3>

									{/* Add Explanatory Scope and other attributes */}
									{technique.attribute_values &&
										technique.attribute_values.length > 0 &&
										Object.entries(
											technique.attribute_values.reduce(
												(acc, attr) => {
													const type =
														attr.attribute_type_name;
													if (!acc[type]) {
														acc[type] = [];
													}
													acc[type].push(attr);
													return acc;
												},
												{} as Record<
													string,
													AttributeValue[]
												>
											)
										).map(([type, values]) => (
											<div
												className="space-y-1"
												key={type}
											>
												<h4 className="text-xs text-muted-foreground">
													{type}
												</h4>
												<div className="flex flex-wrap gap-2">
													{values.map((value) => (
														<Badge
															key={value.id}
															variant="outline"
															className="text-sm"
														>
															{value.name}
														</Badge>
													))}
												</div>
											</div>
										))}
								</div>

								{/* Tags */}
								{technique.tags &&
									technique.tags.length > 0 && (
										<div className="space-y-2">
											<h3 className="text-sm font-medium flex items-center">
												Tags
												<span
													className="ml-1 inline-flex"
													title="Keywords associated with this technique"
												>
													<Info className="h-4 w-4 text-muted-foreground" />
												</span>
											</h3>
											<div className="flex flex-wrap gap-2">
												{technique.tags.map((tag) => (
													<Badge
														key={tag.id}
														variant="secondary"
													>
														{tag.name}
													</Badge>
												))}
											</div>
										</div>
									)}
							</CardContent>

							{/* Edit section - delete will be accessible from edit form later */}
							<CardFooter className="flex flex-col items-stretch pt-4 pb-4 border-t">
								<div
									className={`bg-muted/50 rounded p-3 mb-4 flex items-center ${
										isAuthenticated ? "hidden" : ""
									}`}
								>
									<Lock
										className="h-4 w-4 mr-2 text-muted-foreground"
										aria-hidden="true"
									/>
									<p className="text-sm text-muted-foreground">
										Authentication is required to edit a
										technique. Not implemented yet.
									</p>
								</div>
								<Button
									asChild
									variant="outline"
									className="w-full"
									disabled={!isAuthenticated}
								>
									<Link
										href="#"
										aria-label="Edit technique (disabled)"
									>
										<Edit
											className="h-4 w-4 mr-2"
											aria-hidden="true"
										/>{" "}
										Edit Technique
									</Link>
								</Button>
							</CardFooter>
						</Card>
					</div>
				</div>

				{/* Back button at the bottom */}
				<div className="mt-8">
					<Button asChild variant="outline" size="sm">
						<Link
							href="/techniques"
							className="flex items-center gap-2"
						>
							<ArrowLeft className="h-4 w-4" aria-hidden="true" />
							<span>Back to Techniques</span>
						</Link>
					</Button>
				</div>
			</MainLayout>
		</TooltipProvider>
	);
}
</file>

<file path="README.md">
# TEA Techniques

![An illustration showing different techniques for assurance](https://alan-turing-institute.github.io/turing-commons/assets/images/illustrations/trust-yellow.png)

[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://opensource.org/licenses/MIT)
[![Python](https://img.shields.io/badge/Python-3.12-blue)](https://www.python.org/downloads/)
[![Django](https://img.shields.io/badge/Django-5.1-green)](https://www.djangoproject.com/)
[![Next.js](https://img.shields.io/badge/Next.js-15.2-black)](https://nextjs.org/)
[![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](http://makeapullrequest.com)

An interactive database for exploring techniques for evidencing claims about responsible AI design, development, and deployment. This repository has been designed to work in conjunction with the [Trustworthy and Ethical Assurance (TEA) platform](https://assuranceplatform.azurewebsites.net/) as a core plugin to enable practitioners to identify and implement appropriate assurance methods.

## 🚀 Key Features

-   **📚 Structured Documentation**: Each technique includes comprehensive information about its purpose, implementation details, and practical use cases.
-   **🗂️ Categorized Organization**: Techniques are organized by assurance goals, categories, and subcategories to help you find exactly what you need.
-   **🔌 API Access**: Access all data through a comprehensive REST API with documentation via Swagger.
-   **🧩 Model Agnostic & Specific**: Browse techniques that work across different model types or that are designed for specific model architectures.

## 🛠️ Development Setup

> [!WARNING]
> These instructions have only been tested on MacOS and Linux. If you are using Windows, you may need to adjust some commands.

<details>
<summary>🪧 Prerequisites </summary>
  
- **Python 3.12+ & Poetry:** Install Python and then Poetry ([Installation Guide](https://python-poetry.org/docs/#installation)).
- **Node.js 20+ & pnpm:** Install Node.js ([Download](https://nodejs.org/)) and then pnpm (`npm install -g pnpm`).
- **PostgreSQL:** You need a running PostgreSQL server. 
   - **Installation:** If you don't have it, follow the official guide for your OS: [PostgreSQL Downloads](https://www.postgresql.org/download/).
   - **Database Setup:** After installation, you need to create the database and user specified in your `.env` file. Connect to PostgreSQL (e.g., using `psql`) and run commands similar to these (adjust names/passwords if you changed them in `.env`):
   
   ```sql
   CREATE DATABASE techniques;
   CREATE USER postgres WITH PASSWORD 'postgres'; 
   ALTER ROLE postgres SET client_encoding TO 'utf8';
   ALTER ROLE postgres SET default_transaction_isolation TO 'read committed';
   ALTER ROLE postgres SET timezone TO 'UTC';
   GRANT ALL PRIVILEGES ON DATABASE techniques TO postgres;
   \q 
   ```

-   **Ensure it's running:** Make sure the PostgreSQL service is active before starting the backend.

</details>

<summary>📦 Local Development Setup</summary>

For local development, we use PostgreSQL as the database backend:

1. **Clone the repository**

```bash
    git clone https://github.com/chrisdburr/tea-techniques.git
    cd tea-techniques
```

2. **Setup environment variable**

```bash
cp .env.example .env
```

Important: Ensure the DB_NAME, DB_USER, DB_PASSWORD, DB_HOST, DB_PORT variables in this .env file match your local PostgreSQL setup (see Prerequisites).

3. **Install and start PostgreSQL**

-   Ensure PostgreSQL is installed and running locally (see Prerequisites).
-   Ensure the database and user specified in your .env file exist and the user has the correct password and permissions.

4. **Set up the backend**

```bash
cd backend
poetry install
# Ensure your .env file is configured correctly *before* running migrations/imports
python manage.py migrate # Apply database migrations
python manage.py reset_and_import_techniques # Reset and import data (use with caution if you have custom data)
# OR just import if DB exists: python manage.py import_techniques
```

5. **Run the backend**

```bash
# Make sure you are in the backend directory
poetry run python manage.py runserver
```

6. **In a new terminal, set up and run the frontend**

```bash
cd frontend
pnpm install
pnpm run dev:turbo
```

7. **Access the application**

-   Frontend: http://localhost:3000
-   API: http://localhost:8000/api/
-   Django Admin: http://localhost:8000/admin/

</details>

<details>
<summary>🐳 Docker Setup (Production-like Environment)</summary>

If you want to use the full Docker setup with PostgreSQL:

1. **Setup environment variable**

```bash
cp .env.example .env
```

-   You may want to review and adjust the values in the `.env` file (e.g. change user and password)

2. **Start the application**

    ```bash
    COMPOSE_BAKE=true docker-compose build --no-cache && docker-compose up -d
    ```

3. **Access the application**

-   Frontend: http://localhost:3000
-   API: http://localhost:8000/api/

4. **Restart and Rebuild the Containers**

    ```bash
    docker-compose down && COMPOSE_BAKE=true docker-compose build --no-cache && docker-compose up -d
    ```

</details>

## 📦 Project Structure

-   **Backend**: Django with Django REST Framework

    -   `backend/api`: Main Django app
    -   `backend/config`: Django project settings
    -   `backend/scripts`: Utility scripts (e.g. reset DB, import CSV)
    -   `backend/data`: CSV file with technique data

-   **Frontend**: Next.js with TypeScript and Tailwind CSS
    -   `frontend/src/app`: Next.js pages and routes
    -   `frontend/src/components`: Reusable React components
    -   `frontend/src/lib`: Utilities, types, and API clients

## 💡 Development Tips

1. **API Documentation**

    You can access the API documentation at http://localhost:8000/swagger/ when the backend is running.

2. **Documentation**

    Comprehensive documentation is available to help you understand and contribute to the project:

    ### Core Guides

    - [Data Management Guide](docs/DATA-MANAGEMENT.md) - How to manage and import technique data
    - [Testing Guide](docs/TESTING.md) - Information on testing both frontend and backend
    - [Deployment Guide](docs/DEPLOYMENT.md) - How to deploy the application
    - [Tailscale Deployment Guide](docs/TAILSCALE-DEPLOYMENT.md) - Specialized deployment with Tailscale

    ### User Documentation

    - [User Guide](docs/USER-GUIDE.md) - End-user help for using the application
    - [Glossary](docs/GLOSSARY.md) - Terminology used in the application

    ### Developer Documentation

    - [API Guide](docs/API-GUIDE.md) - API endpoints and usage
    - [Model Architecture](docs/MODEL-ARCHITECTURE.md) - Data model details
    - [Frontend Guide](docs/FRONTEND-GUIDE.md) - Frontend architecture and components
    - [Development Workflow](docs/DEVELOPMENT-WORKFLOW.md) - Recommended development practices
    - [Contributing Guide](docs/CONTRIBUTING.md) - How to contribute to the project
    - [Future Roadmap](docs/FUTURE-ROADMAP.md) - Planned improvements

## 🤝 Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## 📄 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
</file>

<file path=".gitignore">
.env
.venv/
.DS_Store
__pycache__
*.log
*.code-workspace
frontend/node_modules
**/__pycache__/
.vscode/
CLAUDE.md
db.sqlite3
backend/api/migrations/**.py~
backend/api/migrations/0001_initial.py
tea-techniques.conf
repomix.config.json
.repomixignore
</file>

<file path="backend/api/management/commands/import_techniques.py">
# backend/api/management/commands/import_techniques.py
from __future__ import annotations

import json
import os
from pathlib import Path
import logging
from typing import Any, Dict, List, Optional, Union, Tuple, cast
from django.core.management.base import BaseCommand
from django.db import transaction
from django.conf import settings
from argparse import ArgumentParser

from api.models import (
    AssuranceGoal,
    Category,
    SubCategory,
    Tag,
    AttributeType,
    AttributeValue,
    ResourceType,
    Technique,
    TechniqueResource,
    TechniqueExampleUseCase,
    TechniqueLimitation,
)

# Set up logger
logger = logging.getLogger(__name__)


class Command(BaseCommand):
    help = "Import techniques from JSON file"

    def add_arguments(self, parser: ArgumentParser) -> None:
        parser.add_argument("--file", type=str, help="Path to the JSON file")
        parser.add_argument(
            "--force", 
            action="store_true", 
            default=False,
            help="Force import even if errors occur",
        )

    def handle(self, *args: Any, **options: Dict[str, Any]) -> None:
        file_path_option = options.get("file")
        force = options.get("force", False)

        # Get the file path
        if not file_path_option:
            BASE_DIR = Path(settings.BASE_DIR)
            file_path = os.path.join(
                BASE_DIR,
                "data",
                "techniques.json",
            )
        else:
            file_path = str(file_path_option)

        if not os.path.exists(file_path):
            self.stdout.write(self.style.ERROR(f"File not found: {file_path}"))
            return

        self.stdout.write(self.style.SUCCESS(f"Importing techniques from {file_path}"))

        # Create initial records needed for import
        self._create_base_records()

        # Process the JSON file
        try:
            with open(file_path, "r", encoding="utf-8") as json_file:
                techniques_data = json.load(json_file)

            # Use a transaction to ensure data consistency
            with transaction.atomic():
                count = 0
                for technique_data in techniques_data:
                    self._process_technique(technique_data)
                    count += 1

            self.stdout.write(
                self.style.SUCCESS(f"Successfully imported {count} techniques")
            )
        except Exception as e:
            self.stdout.write(self.style.ERROR(f"Error processing JSON file: {str(e)}"))

    def _create_base_records(self) -> None:
        """Create necessary base records (goals, attributes, etc.)"""
        # Create assurance goals if they don't exist
        goal_names = [
            "Explainability",
            "Fairness",
            "Privacy",
            "Reliability",
            "Safety",
            "Transparency",
        ]
        for goal_name in goal_names:
            AssuranceGoal.objects.get_or_create(
                name=goal_name,
                defaults={"description": f"{goal_name} techniques for trustworthy AI"},
            )

        # Create attribute types for common fields in the JSON
        attribute_types = [
            "Scope",
            "Data Type",
            "Model Type",
            "Programming Language",
            "Fairness Approach",
            "Project Lifecycle Stage",
            "Explanatory Scope",
        ]
        for attr_type in attribute_types:
            AttributeType.objects.get_or_create(
                name=attr_type,
                defaults={"description": f"The {attr_type.lower()} of the technique"},
            )

        # Create resource types for the JSON
        resource_types = [
            "Technical Paper",
            "Review Paper",
            "Introductory Paper",
            "Paper",
            "GitHub",
            "Documentation",
            "Tutorial",
            "Book",
            "Survey",
            "Blog",
            "Tool",
            "Law/Policy",
            "Software Package",
        ]
        for resource_type in resource_types:
            ResourceType.objects.get_or_create(
                name=resource_type,
                defaults={"icon": resource_type.lower().replace(" ", "_")},
            )

    def _parse_category_tags(self, category_tags: str) -> List[Dict[str, Optional[str]]]:
        """Parse category tags from #category/subcategory format."""
        if not category_tags:
            return []

        results: List[Dict[str, Optional[str]]] = []
        tags = category_tags.split("#")

        for tag in tags:
            tag = tag.strip()
            if not tag:
                continue

            if "/" in tag:
                category_name, subcategory_name = tag.split("/", 1)
                results.append(
                    {
                        "category": category_name.strip(),
                        "subcategory": subcategory_name.strip(),
                    }
                )
            else:
                results.append({"category": tag.strip(), "subcategory": None})

        return results

    def _process_technique(self, data: Dict[str, Any]) -> None:
        """Process a single technique from JSON data"""
        try:
            # Extract basic data
            name = data.get("name", "")
            description = data.get("description", "")
            model_dependency = data.get("model_dependency", "Model-Agnostic")
            assurance_goals_list = data.get("assurance_goals", [])
            category_tags = data.get("category_tags", "")  # Keep for backward compatibility
            categories_data = data.get("categories", [])  # New direct categories list
            subcategories_data = data.get("subcategories", [])  # New direct subcategories list
            complexity_rating = data.get("complexity_rating")
            computational_cost_rating = data.get("computational_cost_rating")
            applicable_models = data.get("applicable_models", [])

            # Process nested data structures directly from JSON
            attributes_data = data.get("attributes", [])
            example_use_cases_data = data.get("example_use_cases", [])
            resources_data = data.get("resources", [])
            limitations_data = data.get("limitations", [])

            # Skip if essential data is missing
            if not name or not description:
                self.stdout.write(
                    self.style.WARNING(
                        f"Skipping technique with missing name or description"
                    )
                )
                return

            # Create default values
            defaults = {
                "description": description,
                "model_dependency": model_dependency,
                "category_tags": category_tags,  # Keep for backward compatibility
                "complexity_rating": complexity_rating,
                "computational_cost_rating": computational_cost_rating,
            }

            # Add applicable_models to defaults
            defaults["applicable_models"] = applicable_models if applicable_models else None

            # Create or update the technique
            technique, created = Technique.objects.update_or_create(
                name=name,
                defaults=defaults,
            )

            # Clear existing relationships if updating
            if not created:
                # Clear M2M relationships
                technique.assurance_goals.clear()
                technique.categories.clear()
                technique.subcategories.clear()
                technique.tags.clear()

                # Delete related objects
                AttributeValue.objects.filter(technique=technique).delete()
                TechniqueResource.objects.filter(technique=technique).delete()
                TechniqueExampleUseCase.objects.filter(technique=technique).delete()
                TechniqueLimitation.objects.filter(technique=technique).delete()

            # Process assurance goals
            for goal_name in assurance_goals_list:
                goal, _ = AssuranceGoal.objects.get_or_create(
                    name=goal_name,
                    defaults={
                        "description": f"{goal_name} techniques for trustworthy AI"
                    },
                )
                technique.assurance_goals.add(goal)

            # First try to process direct categories and subcategories data
            has_direct_categories = False
            
            # Process direct categories data if available
            if categories_data:
                has_direct_categories = True
                for cat_data in categories_data:
                    if isinstance(cat_data, dict):
                        cat_name = cat_data.get("name")
                        cat_goal_name = cat_data.get("assurance_goal")
                    else:
                        cat_name = cat_data
                        cat_goal_name = assurance_goals_list[0] if assurance_goals_list else "Explainability"
                    
                    if not cat_name:
                        continue
                        
                    # Get or create the assurance goal
                    goal, _ = AssuranceGoal.objects.get_or_create(
                        name=cat_goal_name,
                        defaults={
                            "description": f"{cat_goal_name} techniques for trustworthy AI"
                        },
                    )
                    
                    # Get or create category
                    category, _ = Category.objects.get_or_create(
                        name=cat_name,
                        assurance_goal=goal,
                        defaults={"description": f"Category for {cat_name}"},
                    )
                    
                    # Add category to technique
                    technique.categories.add(category)
            
            # Process direct subcategories data if available
            if subcategories_data:
                has_direct_categories = True
                for subcat_data in subcategories_data:
                    if isinstance(subcat_data, dict):
                        subcat_name = subcat_data.get("name")
                        cat_name = subcat_data.get("category")
                        cat_goal_name = subcat_data.get("assurance_goal", 
                                                        assurance_goals_list[0] if assurance_goals_list else "Explainability")
                    else:
                        # If it's not a dict with detailed info, skip it
                        continue
                    
                    if not subcat_name or not cat_name:
                        continue
                    
                    # Get or create the assurance goal
                    goal, _ = AssuranceGoal.objects.get_or_create(
                        name=cat_goal_name,
                        defaults={
                            "description": f"{cat_goal_name} techniques for trustworthy AI"
                        },
                    )
                    
                    # Get or create category
                    category, _ = Category.objects.get_or_create(
                        name=cat_name,
                        assurance_goal=goal,
                        defaults={"description": f"Category for {cat_name}"},
                    )
                    
                    # Get or create subcategory
                    subcategory, _ = SubCategory.objects.get_or_create(
                        name=subcat_name,
                        category=category,
                        defaults={"description": f"Subcategory for {subcat_name}"},
                    )
                    
                    # Add subcategory to technique
                    technique.subcategories.add(subcategory)
            
            # Fallback to category_tags only if direct categories are not available
            if not has_direct_categories and category_tags:
                parsed_categories = self._parse_category_tags(category_tags)

                for cat_data in parsed_categories:
                    cat_name = cat_data.get("category")
                    subcat_name = cat_data.get("subcategory")

                    # Use first available assurance goal, or default to Explainability
                    goal_name = (
                        assurance_goals_list[0]
                        if assurance_goals_list
                        else "Explainability"
                    )

                    goal, _ = AssuranceGoal.objects.get_or_create(
                        name=goal_name,
                        defaults={
                            "description": f"{goal_name} techniques for trustworthy AI"
                        },
                    )

                    # Get or create category
                    category, _ = Category.objects.get_or_create(
                        name=cat_name,
                        assurance_goal=goal,
                        defaults={"description": f"Category for {cat_name}"},
                    )

                    # Add category to technique
                    technique.categories.add(category)

                    # Process subcategory if present
                    if subcat_name:
                        subcategory, _ = SubCategory.objects.get_or_create(
                            name=subcat_name,
                            category=category,
                            defaults={"description": f"Subcategory for {subcat_name}"},
                        )

                        # Add subcategory to technique
                        technique.subcategories.add(subcategory)

            # Process attributes
            for attr_data in attributes_data:
                attr_type_name = attr_data.get("type")
                attr_value_name = attr_data.get("value")

                if not attr_type_name or not attr_value_name:
                    continue

                # Get or create attribute type
                attr_type, _ = AttributeType.objects.get_or_create(
                    name=attr_type_name,
                    defaults={
                        "description": f"The {attr_type_name.lower()} of the technique"
                    },
                )

                # Create attribute value directly related to technique
                AttributeValue.objects.create(
                    attribute_type=attr_type,
                    name=attr_value_name,
                    description=f"{attr_value_name} {attr_type_name.lower()}",
                    technique=technique,
                )

            # Process example use cases
            for use_case_data in example_use_cases_data:
                use_case_desc = use_case_data.get("description")
                use_case_goal_name = use_case_data.get("goal")

                if not use_case_goal_name and assurance_goals_list:
                    use_case_goal_name = assurance_goals_list[0]

                if not use_case_desc:
                    continue

                # Find the goal
                try:
                    use_case_goal, _ = AssuranceGoal.objects.get_or_create(
                        name=use_case_goal_name,
                        defaults={
                            "description": f"{use_case_goal_name} techniques for trustworthy AI"
                        },
                    )

                    # Create example use case
                    TechniqueExampleUseCase.objects.create(
                        technique=technique,
                        description=use_case_desc,
                        assurance_goal=use_case_goal,
                    )
                except Exception as e:
                    self.stdout.write(
                        self.style.WARNING(f"Error creating use case for {name}: {e}")
                    )

            # Process limitations - handle both string and object formats
            for limitation in limitations_data:
                # Check if the limitation is already a dict/object with description field
                if isinstance(limitation, dict) and "description" in limitation:
                    description = limitation["description"].strip()
                    if description:
                        TechniqueLimitation.objects.create(
                            technique=technique, description=description
                        )
                # Check if it's a string that might be a JSON string
                elif isinstance(limitation, str):
                    # If it looks like a JSON array or object, try to parse it
                    if limitation.strip().startswith(('[', '{')):
                        try:
                            parsed_limitation = json.loads(limitation)
                            
                            # Handle case where the parsed result is an array of limitation objects
                            if isinstance(parsed_limitation, list):
                                for item in parsed_limitation:
                                    if isinstance(item, dict) and "description" in item:
                                        desc = item["description"].strip()
                                        if desc:
                                            TechniqueLimitation.objects.create(
                                                technique=technique, description=desc
                                            )
                                    elif isinstance(item, str) and item.strip():
                                        TechniqueLimitation.objects.create(
                                            technique=technique, description=item.strip()
                                        )
                            # Handle case where the parsed result is a single limitation object
                            elif isinstance(parsed_limitation, dict) and "description" in parsed_limitation:
                                desc = parsed_limitation["description"].strip()
                                if desc:
                                    TechniqueLimitation.objects.create(
                                        technique=technique, description=desc
                                    )
                        except json.JSONDecodeError:
                            # If parsing fails, treat it as a plain string
                            if limitation.strip():
                                TechniqueLimitation.objects.create(
                                    technique=technique, description=limitation.strip()
                                )
                    # Handle plain strings
                    elif limitation.strip():
                        TechniqueLimitation.objects.create(
                            technique=technique, description=limitation.strip()
                        )

            # Process resources
            for resource_data in resources_data:
                resource_type_name = resource_data.get("type", "Website")
                resource_title = resource_data.get("title", "Resource")
                resource_url = resource_data.get("url", "")
                resource_desc = resource_data.get("description", "")
                resource_authors = resource_data.get("authors", [])
                resource_publication_date = resource_data.get("publication_date", "")
                resource_source_type = resource_data.get(
                    "source_type", resource_type_name
                )

                if not resource_url:
                    continue

                # Get or create resource type
                resource_type, _ = ResourceType.objects.get_or_create(
                    name=resource_type_name,
                    defaults={"icon": resource_type_name.lower().replace(" ", "_")},
                )

                # Convert authors list to comma-separated string if it's a list
                if isinstance(resource_authors, list):
                    resource_authors = ", ".join(resource_authors)

                # Create resource
                TechniqueResource.objects.create(
                    technique=technique,
                    resource_type=resource_type,
                    url=resource_url,
                    title=resource_title,
                    description=resource_desc,
                    authors=resource_authors,
                    publication_date=resource_publication_date,
                    source_type=resource_source_type,
                )

            status = "Created" if created else "Updated"
            self.stdout.write(self.style.SUCCESS(f"{status} technique: {name}"))

        except Exception as e:
            self.stdout.write(
                self.style.ERROR(
                    f'Error processing technique {data.get("name", "Unknown")}: {str(e)}'
                )
            )
</file>

<file path="frontend/src/components/technique/TechniquesList.tsx">
// TechniquesList.tsx with pagination fix
"use client";

import React, {
	useState,
	useEffect,
	useMemo,
	useTransition,
	useCallback,
} from "react";
import Link from "next/link";
import {
	useAssuranceGoals,
	calculateTotalPages,
	useTechniques,
	useCategories,
} from "@/lib/api/hooks";
import { useFilterParams } from "@/lib/hooks/useFilterParams";
import TechniquesSidebar, {
	FilterState,
} from "@/components/technique/TechniquesSidebar";

import {
	Card,
	CardContent,
	CardDescription,
	CardFooter,
	CardHeader,
	CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Pagination } from "@/components/ui/pagination";
import { Loader2, Filter } from "lucide-react";
import type { Technique } from "@/lib/types";
import { formatCategoryName } from "./CategoryTag";
import GoalIcon from "./GoalIcon";
import { useRouter, useSearchParams, usePathname } from "next/navigation";

// Number of items per page - must match backend setting (20)
const PAGE_SIZE = 20;

// Default filter values
const DEFAULT_FILTERS: FilterState = {
	search: "",
	assurance_goals: [],
	categories: [],
	model_dependency: [],
	complexity_max: 5,
	computational_cost_max: 5,
};

// Extracted TechniqueCard component with improved responsive design
const TechniqueCard = ({
	technique,
}: {
	technique: Technique;
}): JSX.Element => {
	// Get first category and subcategory if available
	const primaryCategory =
		technique.categories.length > 0
			? formatCategoryName(technique.categories[0].name)
			: "Uncategorized";

	// Get subcategory if available
	const subcategory =
		technique.subcategories.length > 0
			? formatCategoryName(technique.subcategories[0].name)
			: null;

	// Truncate only subcategory if too long
	const truncateSubcategory = (text: string, maxLength = 20) => {
		if (!text || text.length <= maxLength) return text;
		return text.substring(0, maxLength) + "...";
	};

	// Build category display text with truncation only for subcategory
	const categoryText = subcategory
		? `${primaryCategory} | ${truncateSubcategory(subcategory)}`
		: primaryCategory;

	// Format the title to remove parenthetical content if it's too long
	const formatTitle = (title: string) => {
		// If the title is potentially too long (over ~35 chars), try to simplify it
		if (title.length > 35 && title.includes("(")) {
			// Return everything before the first parenthesis, trimmed
			return title.split("(")[0].trim();
		}
		return title;
	};

	// Truncate description for display and add ellipsis if needed
	const truncateDescription = (description: string, maxLength = 110) => {
		if (description.length <= maxLength) return description;

		// Find the last space before the maxLength to avoid cutting words
		let cutoff = description.lastIndexOf(" ", maxLength);
		if (cutoff === -1) cutoff = maxLength;

		return description.substring(0, cutoff) + "...";
	};

	// Build full category text for hover tooltip
	const fullCategoryText = subcategory
		? `${primaryCategory} | ${subcategory}`
		: primaryCategory;

	return (
		<Card className="h-full flex flex-col">
			<CardHeader className="pb-2 px-4 pt-4 sm:px-6 sm:pt-6">
				<CardTitle
					className="line-clamp-1 text-base sm:text-lg"
					title={technique.name}
				>
					{formatTitle(technique.name)}
				</CardTitle>
				<CardDescription
					className="text-xs sm:text-sm text-muted-foreground line-clamp-1"
					title={fullCategoryText}
				>
					{categoryText}
				</CardDescription>
			</CardHeader>

			<CardContent className="pt-0 pb-0 px-4 sm:px-6 flex-grow flex flex-col">
				<p
					className="text-xs sm:text-sm text-foreground mb-3 h-8 sm:h-10 overflow-hidden"
					title={technique.description}
				>
					{truncateDescription(technique.description, 90)}
				</p>

				<div className="flex flex-wrap items-center gap-1 sm:gap-2 mt-auto">
					{technique.assurance_goals.map((goal) => (
						<div
							key={goal.id}
							className="p-1 sm:p-1.5 rounded-full flex items-center bg-secondary"
							title={goal.name}
						>
							<GoalIcon goalName={goal.name} size={14} />
						</div>
					))}
				</div>
			</CardContent>

			<CardFooter className="pt-3 pb-4 px-4 sm:px-6 sm:pt-4">
				<Button
					asChild
					variant="default"
					size="sm"
					className="w-full text-xs sm:text-sm"
				>
					<Link href={`/techniques/${technique.id}`}>
						View Details
					</Link>
				</Button>
			</CardFooter>
		</Card>
	);
};

// Define EmptyStateComponent
const EmptyStateComponent = (): JSX.Element => {
	return (
		<div className="text-center py-8">
			<p>No techniques found matching your criteria.</p>
			<p className="mt-2 text-sm text-muted-foreground">
				This could be because:
			</p>
			<ul className="list-disc list-inside mt-2 text-sm text-muted-foreground">
				<li>No techniques exist in the database yet</li>
				<li>The current filters exclude all techniques</li>
			</ul>
		</div>
	);
};

export default function TechniquesList() {
	// State for sidebar visibility (used for both mobile and desktop)
	const [isSidebarOpen, setSidebarOpen] = useState(true);

	// Detect screen size to automatically hide sidebar on mobile
	useEffect(() => {
		const handleResize = () => {
			if (window.innerWidth < 768) {
				setSidebarOpen(false);
			} else {
				setSidebarOpen(true);
			}
		};

		// Initial check
		handleResize();

		// Listen for window resize events
		window.addEventListener("resize", handleResize);
		return () => window.removeEventListener("resize", handleResize);
	}, []);

	// Get current URL parameters directly
	const searchParams = useSearchParams();
	const router = useRouter();
	const pathname = usePathname();
	const [isPending, startTransition] = useTransition();
	
	// Still use the hook for currentPage - it provides other useful functionality
	const { currentPage } = useFilterParams({
		search: "",
		assurance_goal: "all",
		category: "all",
		model_dependency: "all",
	});

	// Parse filters from URL with useCallback to prevent recreating on each render
	const getInitialFilters = useCallback(() => {
		const initialFilters: FilterState = {
			search: "",
			assurance_goals: [],
			categories: [],
			model_dependency: [],
			complexity_max: 5,
			computational_cost_max: 5,
		};

		// Get search from URL
		const searchParam = searchParams.get("search");
		if (searchParam) {
			initialFilters.search = searchParam;
		}

		// Get multiple assurance_goals from URL
		// This is the key fix - using getAll() instead of get() for array parameters
		const assuranceGoalParams = searchParams.getAll("assurance_goals");
		if (assuranceGoalParams.length > 0) {
			console.log("Found assurance_goals in URL:", assuranceGoalParams);
			initialFilters.assurance_goals = assuranceGoalParams;
		}

		// Similarly get categories
		const categoryParams = searchParams.getAll("categories");
		if (categoryParams.length > 0) {
			initialFilters.categories = categoryParams;
		}

		// Get model dependency
		const modelDependencyParam = searchParams.get("model_dependency");
		if (modelDependencyParam) {
			initialFilters.model_dependency = [modelDependencyParam];
		}

		// Get rating filters
		const complexityParam = searchParams.get("complexity_max");
		if (complexityParam) {
			initialFilters.complexity_max = parseInt(complexityParam, 10);
		}

		const compCostParam = searchParams.get("computational_cost_max");
		if (compCostParam) {
			initialFilters.computational_cost_max = parseInt(compCostParam, 10);
		}

		console.log("Initialized filters from URL:", initialFilters);
		return initialFilters;
	}, [searchParams]);
	
	// State for the filters being edited by the user (not yet applied)
	const [filters, setFilters] = useState<FilterState>(getInitialFilters);
	
	// State for the filters that have been applied (used for API calls)
	const [appliedFilters, setAppliedFilters] = useState<FilterState>(getInitialFilters);
	
	// Update filters when URL parameters change
	useEffect(() => {
		// Get filters from URL parameters
		const updatedFilters = getInitialFilters();
		setFilters(updatedFilters);
		setAppliedFilters(updatedFilters);
	}, [searchParams, getInitialFilters]);

	// Convert back to URL format for API calls - but using appliedFilters not filters
	const apiFilters = useMemo(() => {
		return {
			search: appliedFilters.search,
			search_fields: "name",
			// Pass all assurance goals, not just the first one
			assurance_goals:
				appliedFilters.assurance_goals.length > 0
					? appliedFilters.assurance_goals
					: undefined,
			category:
				appliedFilters.categories.length === 1 ? appliedFilters.categories[0] : "all",
			model_dependency:
				appliedFilters.model_dependency.length > 0
					? appliedFilters.model_dependency[0]
					: "all",
			complexity_max: appliedFilters.complexity_max?.toString(),
			computational_cost_max: appliedFilters.computational_cost_max?.toString(),
		};
	}, [appliedFilters]);

	// Fetch data from API
	const {
		data: techniquesData,
		isLoading,
		error,
	} = useTechniques(apiFilters, currentPage);

	// Fetch filtered categories based on selected assurance goal
	const { data: categoriesData, isLoading: isLoadingCategories } =
		useCategories(
			filters.assurance_goals.length === 1
				? parseInt(filters.assurance_goals[0])
				: undefined
		);
	const { data: assuranceGoalsData, isLoading: isLoadingGoals } =
		useAssuranceGoals();

	// Update the techniques memo to include client-side filtering for complexity and computational cost
	const techniques = useMemo(() => {
		// Type assertion to ensure TypeScript knows the structure
		const data = techniquesData as { results?: Technique[] } | undefined;
		const results = data?.results || [];

		// Apply client-side filtering for results using appliedFilters
		return results.filter((technique: Technique) => {
			// Filter by search term if needed
			if (appliedFilters.search && appliedFilters.search.trim() !== "") {
				const searchTerm = appliedFilters.search.toLowerCase().trim();
				if (!technique.name.toLowerCase().includes(searchTerm)) {
					return false;
				}
			}

			// Apply complexity_max filter
			if (
				appliedFilters.complexity_max !== undefined &&
				technique.complexity_rating !== undefined &&
				technique.complexity_rating > appliedFilters.complexity_max
			) {
				return false;
			}

			// Apply computational_cost_max filter
			if (
				appliedFilters.computational_cost_max !== undefined &&
				technique.computational_cost_rating !== undefined &&
				technique.computational_cost_rating >
					appliedFilters.computational_cost_max
			) {
				return false;
			}

			// If it passed all filters, include it
			return true;
		});
	}, [
		techniquesData,
		appliedFilters.search,
		appliedFilters.complexity_max,
		appliedFilters.computational_cost_max,
	]);

	// Calculate pagination information using the total count from the API response
	// Get the total count from the API response
	const apiTotalCount = (techniquesData as { count?: number })?.count || 0;
	const totalPages = calculateTotalPages(apiTotalCount, PAGE_SIZE);

	// Apply filters function
	const applyFilters = useCallback((explicitFilters?: FilterState) => {
		// Use explicitly passed filters or current state
		const filtersToApply = explicitFilters || filters;
		console.log("🔍 ApplyFilters EXPLICITLY called with:", filtersToApply);
		
		// Update appliedFilters state first - this triggers API refresh
		setAppliedFilters(filtersToApply);

		// Build URL with current filters
		const params = new URLSearchParams();

		// Add search if provided
		if (filtersToApply.search) {
			params.set("search", filtersToApply.search);
			params.set("search_fields", "name");
		}

		// Add assurance goals - each as a separate parameter
		if (filtersToApply.assurance_goals.length > 0) {
			console.log(
				"Adding assurance goals to URL:",
				filtersToApply.assurance_goals
			);
			// Important: Use "append" for each goal ID
			filtersToApply.assurance_goals.forEach((goalId) => {
				params.append("assurance_goals", goalId);
			});
		}

		// Add categories
		if (filtersToApply.categories.length > 0) {
			filtersToApply.categories.forEach((catId) => {
				params.append("categories", catId);
			});
		}

		// Add model dependency
		if (filtersToApply.model_dependency.length > 0) {
			params.set("model_dependency", filtersToApply.model_dependency[0]);
		}

		// Add complexity and computational cost
		if (
			filtersToApply.complexity_max !== undefined &&
			filtersToApply.complexity_max < 5
		) {
			params.set(
				"complexity_max",
				filtersToApply.complexity_max.toString()
			);
		}

		if (
			filtersToApply.computational_cost_max !== undefined &&
			filtersToApply.computational_cost_max < 5
		) {
			params.set(
				"computational_cost_max",
				filtersToApply.computational_cost_max.toString()
			);
		}

		// Always set page to 1 when applying filters
		params.set("page", "1");

		// Debug the URL
		const urlString = params.toString();
		console.log("URL parameters:", urlString);

		// Use Next.js router for client-side navigation
		startTransition(() => {
			router.push(`${pathname}?${urlString}`);
		});
	}, [filters, router, pathname, startTransition]);

	// Reset filters function
	const resetFilters = useCallback(() => {
		const defaultFilters = getInitialFilters();
		setFilters(defaultFilters);
		setAppliedFilters(defaultFilters);
		console.log("Resetting filters with URL:", `/techniques?page=1`);
		
		// Use Next.js router for client-side navigation
		startTransition(() => {
			router.push(`${pathname}?page=1`);
		});
	}, [getInitialFilters, router, pathname, startTransition]);

	// Page change handler function
	const handlePageChange = useCallback((newPage: number) => {
		// Build URL with applied filters and new page
		const params = new URLSearchParams();

		// Add search if provided
		if (appliedFilters.search) {
			params.set("search", appliedFilters.search);
			params.set("search_fields", "name");
		}

		// Add assurance goals - each as a separate parameter, just like in applyFilters
		if (appliedFilters.assurance_goals.length > 0) {
			appliedFilters.assurance_goals.forEach((goalId) => {
				params.append("assurance_goals", goalId);
			});
		}

		// Add categories
		if (appliedFilters.categories.length > 0) {
			appliedFilters.categories.forEach((catId) => {
				params.append("categories", catId);
			});
		}

		// Add model dependency
		if (appliedFilters.model_dependency.length > 0) {
			params.set("model_dependency", appliedFilters.model_dependency[0]);
		}

		// Add max complexity if not at default
		if (appliedFilters.complexity_max && appliedFilters.complexity_max < 5) {
			params.set("complexity_max", appliedFilters.complexity_max.toString());
		}

		// Add max computational cost if not at default
		if (
			appliedFilters.computational_cost_max &&
			appliedFilters.computational_cost_max < 5
		) {
			params.set(
				"computational_cost_max",
				appliedFilters.computational_cost_max.toString()
			);
		}

		// Set the new page parameter
		params.set("page", newPage.toString());

		// Navigate to new page using Next.js router
		const queryString = params.toString();
		console.log("Changing page with URL:", `/techniques?${queryString}`);
		
		startTransition(() => {
			router.push(`${pathname}?${queryString}`);
		});
	}, [appliedFilters, router, pathname, startTransition]);

	return (
		<div className="space-y-6">
			<div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
				<div className="flex flex-row items-center gap-2">
					<h1 className="text-2xl sm:text-3xl font-bold">
						Techniques
					</h1>
				</div>
				<Button asChild size="sm" className="w-full sm:w-auto">
					<Link href="/techniques/add">Add New Technique</Link>
				</Button>
			</div>

			{/* Main content with sidebar */}
			<div className="flex flex-col md:flex-row gap-6 relative">
				{/* Sidebar with sticky behavior on desktop */}
				{isSidebarOpen && (
					<div className="md:w-80 md:sticky md:top-4 md:self-start">
						<TechniquesSidebar
							filters={filters}
							setFilters={setFilters}
							applyFilters={applyFilters}
							resetFilters={resetFilters}
							assuranceGoals={assuranceGoalsData?.results}
							categories={categoriesData?.results}
							isDataLoading={
								isLoadingGoals || isLoadingCategories
							}
							isMobileOpen={isSidebarOpen}
							setIsMobileOpen={setSidebarOpen}
							allowToggle={
								true
							} /* Pass flag to show toggle button in header */
						/>
					</div>
				)}

				{/* Filter buttons when sidebar is closed */}
				{!isSidebarOpen && (
					<>
						{/* Desktop sticky filter button (positioned on the left) */}
						<div className="hidden md:block sticky top-4 z-30 h-0">
							<Button
								variant="outline"
								onClick={() => setSidebarOpen(true)}
								className="flex items-center gap-2 shadow-md"
								size="sm"
							>
								<Filter className="h-4 w-4 mr-1" />
							</Button>
						</div>

						{/* Mobile floating button */}
						<div className="fixed bottom-6 right-6 z-40 md:hidden">
							<Button
								variant="secondary"
								onClick={() => setSidebarOpen(true)}
								className="rounded-full shadow-md w-12 h-12 p-0"
								aria-label="Show filters"
							>
								<Filter className="h-5 w-5" />
							</Button>
						</div>
					</>
				)}

				{/* Techniques list */}
				<div className="flex-1">
					{isLoading ? (
						<div className="flex justify-center items-center py-8">
							<Loader2 className="h-8 w-8 animate-spin text-primary" />
							<span className="ml-2">Loading techniques...</span>
						</div>
					) : error ? (
						<div className="text-center py-8 text-red-500">
							<p>
								Error loading techniques:{" "}
								{(error as Error).message}
							</p>
							<p className="mt-2">
								Please check that the backend is running and
								properly configured.
							</p>
						</div>
					) : (
						<>
							{techniques.length > 0 ? (
								<>
									{/* Improved responsive grid with smaller cards on xs screens */}
									<div className="grid grid-cols-1 sm:grid-cols-1 md:grid-cols-2 lg:grid-cols-2 xl:grid-cols-3 gap-4 sm:gap-6">
										{techniques.map(
											(technique: Technique) => (
												<TechniqueCard
													key={technique.id}
													technique={technique}
												/>
											)
										)}
									</div>

									{/* Only show pagination if we have more than one page */}
									{totalPages > 1 && (
										<Pagination
											currentPage={currentPage}
											totalPages={totalPages}
											onPageChange={handlePageChange}
											className="mt-8"
										/>
									)}
								</>
							) : (
								<EmptyStateComponent />
							)}
						</>
					)}
				</div>
			</div>
		</div>
	);
}
</file>

<file path="frontend/src/lib/api/client.ts">
// src/lib/api/client.ts
import axios from "axios";

// Select the appropriate base URL based on environment
const getBaseUrl = () => {
  // For server-side rendering in Docker environment
  if (typeof window === 'undefined') {
    // When running on the server
    if (process.env.DOCKER_ENV === 'true') {
      return process.env.BACKEND_URL || 'http://backend:8000';
    } else {
      return process.env.BACKEND_URL || 'http://localhost:8000';
    }
  }
  
  // For browser (client-side) requests, always use relative URLs
  // that will be handled by Next.js rewrites
  return '';
};

// Create a client that uses the appropriate API base URL
const apiClient = axios.create({
	baseURL: getBaseUrl(),
	timeout: 15000,
	headers: {
		"Content-Type": "application/json",
		Accept: "application/json",
	},
	// Allow redirects to follow Django's trailing slash redirects
	maxRedirects: 5,
	paramsSerializer: {
		indexes: null,
	},
	// Important for session-based authentication
	withCredentials: true,
});

export { apiClient };
export default apiClient;
</file>

<file path="docker-compose.yml">
services:
  db:
    image: postgres:16
    environment:
      - POSTGRES_DB=${DB_NAME:-techniques}
      - POSTGRES_USER=${DB_USER:-postgres}
      - POSTGRES_PASSWORD=${DB_PASSWORD:-postgres}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    # --- Development Profile ---
    profiles: ["dev"]
    ports:
      - "5432:5432" # Expose DB port only during dev

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    # --- Production-like Defaults ---
    environment:
      - DJANGO_SETTINGS_MODULE=${DJANGO_SETTINGS_MODULE:-config.settings.production} # Default to prod settings
      - SECRET_KEY=${SECRET_KEY:-change-in-production}
      - DB_NAME=${DB_NAME:-techniques}
      - DB_USER=${DB_USER:-postgres}
      - DB_PASSWORD=${DB_PASSWORD:-postgres}
      - DB_HOST=db
      - DB_PORT=5432
      - ALLOWED_HOSTS=${ALLOWED_HOSTS:-backend,nginx} # Allow backend and nginx service names
      - CORS_ALLOWED_ORIGINS=${CORS_ALLOWED_ORIGINS} # Must be set via .env or .env.tailscale
      - CSRF_TRUSTED_ORIGINS=${CSRF_TRUSTED_ORIGINS} # Must be set via .env or .env.tailscale
      - DEBUG=${DEBUG:-False} # Default to False
    # Default command uses Gunicorn (from entrypoint.sh)
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/api/health/"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s
    depends_on:
      db:
        condition: service_healthy
    # --- Development Profile Overrides ---
    profiles: ["dev"]
    volumes:
      - ./backend:/app # Mount local code for hot-reloading
    environment:
      # Override environment for development
      - DJANGO_SETTINGS_MODULE=config.settings.docker # Or development if preferred
      - DEBUG=True
      - CORS_ALLOWED_ORIGINS=http://localhost:80,http://localhost:3000,http://127.0.0.1:3000,http://frontend:3000 # Allow host access
      - CSRF_TRUSTED_ORIGINS=http://localhost:80,http://localhost:3000,http://127.0.0.1:3000
    ports:
      - "8000:8000" # Expose port 8000 directly for dev access/debugging

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      args:
        - NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL:-/api}
        - NEXT_PUBLIC_SWAGGER_URL=${NEXT_PUBLIC_SWAGGER_URL:-/swagger/}
    # --- Production-like Defaults ---
    environment:
      - PORT=3000
      - HOSTNAME=0.0.0.0
      - NODE_ENV=${NODE_ENV:-production} # Default to production
      - BACKEND_URL=${BACKEND_URL:-http://backend:8000}
    # Default command uses node server.js (from Dockerfile CMD)
    healthcheck:
      test: ["CMD", "curl", "--fail", "http://localhost:3000"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s
    depends_on:
      - backend
    # --- Development Profile Overrides ---
    profiles: ["dev"]
    volumes:
      - ./frontend:/app # Mount local code
      - /app/node_modules # Prevent node_modules overwrite
      - ./frontend/.next:/app/.next # Persist .next cache
    environment:
      # Override environment for development
      - NODE_ENV=development
      - WATCHPACK_POLLING=true # Helps with Docker volume hot-reloading
    command: pnpm run dev # Use dev server for hot-reloading
    ports:
      - "3000:3000" # Expose port 3000 directly for dev access

  nginx:
    image: nginx:alpine
    restart: unless-stopped
    volumes:
      # Mount generated config from host (generated before start)
      - ./nginx/tea-techniques.conf:/etc/nginx/conf.d/tea-techniques.conf:ro
      - nginx_logs:/var/log/nginx
    command: /bin/sh -c "rm -f /etc/nginx/conf.d/default.conf && nginx -g 'daemon off;'"
    depends_on:
      - frontend
      - backend
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 10s
    # --- Development Profile Overrides ---
    profiles: ["dev"]
    ports:
      - "80:80" # Expose Nginx port 80 only during dev

volumes:
  postgres_data:
  nginx_logs:
</file>

<file path="backend/api/views/api_views.py">
# api/views/api_views.py

from __future__ import annotations

from rest_framework import viewsets, filters, status
from rest_framework.response import Response
from rest_framework.decorators import api_view
from rest_framework.request import Request
from rest_framework.permissions import BasePermission, IsAuthenticated, AllowAny
from django_filters.rest_framework import DjangoFilterBackend
from django.http import JsonResponse
from django.core import serializers
from django.views.decorators.csrf import csrf_exempt
from django.middleware.common import CommonMiddleware
from django.db import connection
import json
import logging
from typing import Any, Dict, List, Optional, Type, Union, cast

from ..models import (
    AssuranceGoal,
    Category,
    SubCategory,
    Tag,
    ResourceType,
    Technique,
    AttributeType,
    AttributeValue,
    TechniqueResource,
    TechniqueExampleUseCase,
    TechniqueLimitation,
)
from ..serializers import (
    AssuranceGoalSerializer,
    CategorySerializer,
    SubCategorySerializer,
    TagSerializer,
    TechniqueSerializer,
    AttributeTypeSerializer,
    AttributeValueSerializer,
    ResourceTypeSerializer,
    TechniqueResourceSerializer,
    TechniqueExampleUseCaseSerializer,
    TechniqueLimitationSerializer,
)

# Set up logger
logger = logging.getLogger(__name__)


class AssuranceGoalsViewSet(viewsets.ModelViewSet):
    queryset = AssuranceGoal.objects.all()
    serializer_class = AssuranceGoalSerializer
    filter_backends = [
        DjangoFilterBackend,
        filters.SearchFilter,
        filters.OrderingFilter,
    ]
    filterset_fields = ["name"]
    search_fields = ["name", "description"]
    ordering_fields = ["id", "name"]


class CategoryViewSet(viewsets.ModelViewSet):
    queryset = Category.objects.all()
    serializer_class = CategorySerializer
    filter_backends = [
        DjangoFilterBackend,
        filters.SearchFilter,
        filters.OrderingFilter,
    ]
    filterset_fields = ["name", "assurance_goal"]
    search_fields = ["name", "assurance_goal__name"]
    ordering_fields = ["id", "name"]


class SubCategoryViewSet(viewsets.ModelViewSet):
    queryset = SubCategory.objects.all()
    serializer_class = SubCategorySerializer
    filter_backends = [
        DjangoFilterBackend,
        filters.SearchFilter,
        filters.OrderingFilter,
    ]
    filterset_fields = ["name", "category"]
    search_fields = ["name", "category__name"]
    ordering_fields = ["id", "name"]


class TagsViewSet(viewsets.ModelViewSet):
    queryset = Tag.objects.all()
    serializer_class = TagSerializer
    filter_backends = [
        DjangoFilterBackend,
        filters.SearchFilter,
        filters.OrderingFilter,
    ]
    filterset_fields = ["name"]
    search_fields = ["name"]
    ordering_fields = ["id", "name"]


class TechniquesViewSet(viewsets.ModelViewSet):
    """
    ViewSet for Techniques that provides `list`, `create`, `retrieve`,
    `update` and `destroy` actions.
    
    Authentication is required for create, update, and delete operations.
    """

    queryset = Technique.objects.all()
    serializer_class = TechniqueSerializer
    filter_backends = [
        DjangoFilterBackend,
        filters.SearchFilter,
        filters.OrderingFilter,
    ]
    filterset_fields = [
        "name",
        "model_dependency",
        "assurance_goals",
        "categories",
        "subcategories",
        "tags",
    ]
    search_fields = ["name", "description"]
    ordering_fields = ["id", "name"]
    
    def get_permissions(self) -> List[BasePermission]:
        """
        Customize permissions based on action:
        - list and retrieve are allowed for any user (even unauthenticated)
        - create, update, delete require authentication
        """
        if self.action in ['create', 'update', 'partial_update', 'destroy']:
            return [IsAuthenticated()]
        # Default permission for list and retrieve
        return [AllowAny()]

    def get_serializer_class(self) -> Type[TechniqueSerializer]:
        """Return appropriate serializer class based on action."""
        return TechniqueSerializer
        
    def list(self, request: Request, *args: Any, **kwargs: Any) -> Response:
        """Standard list method for techniques"""
        return super().list(request, *args, **kwargs)
                
    def retrieve(self, request: Request, *args: Any, **kwargs: Any) -> Response:
        """Standard retrieve method for techniques"""
        return super().retrieve(request, *args, **kwargs)

    def create(self, request: Request, *args: Any, **kwargs: Any) -> Response:
        """Create a new technique."""
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        instance = serializer.save()

        # Return the created instance
        return Response(serializer.data, status=status.HTTP_201_CREATED)

    def update(self, request: Request, *args: Any, **kwargs: Any) -> Response:
        """Update a technique."""
        instance = self.get_object()
        serializer = self.get_serializer(
            instance, data=request.data, partial=kwargs.get("partial", False)
        )
        serializer.is_valid(raise_exception=True)
        updated_instance = serializer.save()

        # Return the updated instance
        return Response(serializer.data)


class AttributeTypesViewSet(viewsets.ModelViewSet):
    queryset = AttributeType.objects.all()
    serializer_class = AttributeTypeSerializer
    filter_backends = [
        DjangoFilterBackend,
        filters.SearchFilter,
        filters.OrderingFilter,
    ]
    filterset_fields = ["name", "applicable_goals", "required_for_goals"]
    search_fields = ["name", "description"]
    ordering_fields = ["id", "name"]


class AttributeValuesViewSet(viewsets.ModelViewSet):
    queryset = AttributeValue.objects.all()
    serializer_class = AttributeValueSerializer
    filter_backends = [
        DjangoFilterBackend,
        filters.SearchFilter,
        filters.OrderingFilter,
    ]
    filterset_fields = ["name", "attribute_type"]
    search_fields = ["name", "description"]
    ordering_fields = ["id", "name"]


class ResourceTypesViewSet(viewsets.ModelViewSet):
    queryset = ResourceType.objects.all()
    serializer_class = ResourceTypeSerializer
    filter_backends = [
        DjangoFilterBackend,
        filters.SearchFilter,
        filters.OrderingFilter,
    ]
    filterset_fields = ["name"]
    search_fields = ["name"]
    ordering_fields = ["id", "name"]


@api_view(["GET"])
def get_categorylist(request: Request, assurance_goal_id: int) -> Response:
    categories = Category.objects.filter(assurance_goal_id=assurance_goal_id)
    serializer = CategorySerializer(categories, many=True)
    return Response(serializer.data)


@api_view(["GET"])
def get_subcategorylist(request: Request, category_id: int) -> Response:
    subcategories = SubCategory.objects.filter(category_id=category_id)
    serializer = SubCategorySerializer(subcategories, many=True)
    return Response(serializer.data)


@api_view(["GET"])
def health_check(request: Request) -> Response:
    """
    Simple health check endpoint that verifies the API is running
    and the database connection is working.
    """
    try:
        # Check database connection by making a simple query
        with connection.cursor() as cursor:
            cursor.execute("SELECT 1")
            one = cursor.fetchone()[0]
            assert one == 1
        
        return Response(
            {
                "status": "healthy",
                "database": "connected",
                "api": "running",
            }
        )
    except Exception as e:
        logger.error(f"Health check failed: {str(e)}")
        return Response(
            {
                "status": "unhealthy",
                "database": "disconnected",
                "error": str(e),
            },
            status=status.HTTP_503_SERVICE_UNAVAILABLE,
        )


@api_view(["GET", "POST"])
@csrf_exempt
def debug_endpoint(request: Request) -> Response:
    """
    Debugging endpoint to check what the API is receiving and can return.
    GET: Returns the available models and their structure
    POST: Echoes back the received data, useful for checking what's being sent
    """
    if request.method == "GET":
        # Return connection information for debugging
        from django.conf import settings
        
        # Safe version of settings that doesn't expose sensitive information
        safe_settings = {
            "DEBUG": settings.DEBUG,
            "ALLOWED_HOSTS": settings.ALLOWED_HOSTS,
            "CORS_ALLOWED_ORIGINS": getattr(settings, "CORS_ALLOWED_ORIGINS", "Not set"),
            "CORS_ALLOW_ALL_ORIGINS": getattr(settings, "CORS_ALLOW_ALL_ORIGINS", "Not set"),
            "DATABASE_ENGINE": settings.DATABASES["default"]["ENGINE"],
            "INSTALLED_APPS": settings.INSTALLED_APPS,
            "MIDDLEWARE": settings.MIDDLEWARE,
        }
        
        # Get current database connection info
        db_info = {
            "vendor": connection.vendor,
            "queries_executed": len(connection.queries) if settings.DEBUG else "Query logging disabled",
            "is_usable": connection.is_usable(),
        }
        
        # Return model information for debugging
        assurance_goals_count = AssuranceGoal.objects.count()
        categories_count = Category.objects.count()
        subcategories_count = SubCategory.objects.count()
        techniques_count = Technique.objects.count()

        response_data = {
            "api_status": "API is running correctly",
            "request_info": {
                "path": request.path,
                "host": request.get_host(),
                "method": request.method,
                "content_type": request.content_type or "Not set",
                "headers": {k: v for k, v in request.headers.items() if k.lower() not in ('cookie', 'authorization')},
            },
            "database_info": db_info,
            "database_counts": {
                "assurance_goals": assurance_goals_count,
                "categories": categories_count,
                "subcategories": subcategories_count,
                "techniques": techniques_count,
            },
            "api_endpoints": {
                "assurance_goals": "/api/assurance-goals/",
                "categories": "/api/categories/",
                "techniques": "/api/techniques/",
                "debug": "/api/debug/",
            },
            "settings": safe_settings,
        }

        return Response(response_data)

    elif request.method == "POST":
        # Echo back received data for debugging
        return Response(
            {
                "api_status": "API is running correctly",
                "received_data": request.data,
                "content_type": request.content_type,
                "method": request.method,
                "headers": {k: v for k, v in request.headers.items() if k.lower() not in ('cookie', 'authorization')},
            }
        )
        
    # Default fallback response - should never reach here due to DRF's api_view decorator
    return Response({"error": "Unsupported HTTP method"}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
</file>

<file path="frontend/next.config.ts">
// frontend/next.config.ts
import type { NextConfig } from "next";

// Import bundle analyzer conditionally
let withBundleAnalyzer = (config: NextConfig) => config;
if (process.env.ANALYZE === 'true') {
  const bundleAnalyzer = require('@next/bundle-analyzer');
  withBundleAnalyzer = bundleAnalyzer({
    enabled: true,
  });
}

// Uncomment for debugging at runtime if needed
// console.log('Running next.config.ts - Environment variables:');
// console.log('BACKEND_URL:', process.env.BACKEND_URL);
// console.log('DOCKER_ENV:', process.env.DOCKER_ENV);
// console.log('NODE_ENV:', process.env.NODE_ENV);

// Get the backend URL from environment or use a sensible default
const getBackendUrl = () => {
  // First check for environment variable
  if (process.env.BACKEND_URL) {
    return process.env.BACKEND_URL;
  }
  
  // For Docker environments, try to use the service name
  if (process.env.DOCKER_ENV === 'true') {
    return 'http://backend:8000';
  }
  
  // Default fallback for local development
  return 'http://127.0.0.1:8000';
};

const BACKEND_URL = getBackendUrl();

const nextConfig: NextConfig = {
	reactStrictMode: true,
	
	// Add rewrites to proxy API requests to the backend
	async rewrites() {
		return [
			{
				source: '/api',
				destination: `${BACKEND_URL}/api/` // Proxy to Django backend root with trailing slash
			},
			{
				source: '/api/:path*',
				destination: `${BACKEND_URL}/api/:path*` // Proxy to Django backend paths
			},
			{
				source: '/swagger',
				destination: `${BACKEND_URL}/swagger/` // Proxy Swagger docs with trailing slash
			},
			{
				source: '/swagger/:path*',
				destination: `${BACKEND_URL}/swagger/:path*` // Proxy Swagger docs paths
			}
		];
	},
	
	// Add this output configuration for standalone mode
	output: "standalone",
	
	// Force trailing slashes to match Django's URL pattern
	trailingSlash: true
};

export default withBundleAnalyzer(nextConfig);
</file>

<file path="frontend/package.json">
{
	"name": "frontend",
	"version": "0.1.0",
	"private": true,
	"scripts": {
		"dev": "next dev",
		"dev:turbo": "next dev --turbopack",
		"build": "NEXT_DISABLE_LINT=true next build",
		"analyze": "cross-env ANALYZE=true NODE_ENV=production next build",
		"analyze-deps": "pnpm list --depth=1",
		"analyze-size": "du -sh node_modules",
		"start": "next start",
		"lint": "next lint",
		"test": "jest",
		"test:watch": "jest --watch",
		"install-tests": "pnpm add -D '@testing-library/jest-dom' '@testing-library/react' '@testing-library/user-event' '@types/jest' 'jest' 'jest-environment-jsdom' 'msw' 'ts-jest' 'ts-node'"
	},
	"engines": {
		"node": ">=18.0.0"
	},
	"packageManager": "pnpm@10.6.5",
	"dependencies": {
		"@hookform/resolvers": "^4.1.3",
		"@radix-ui/react-accordion": "^1.2.3",
		"@radix-ui/react-checkbox": "^1.1.4",
		"@radix-ui/react-dialog": "^1.1.6",
		"@radix-ui/react-label": "^2.1.2",
		"@radix-ui/react-popover": "^1.1.6",
		"@radix-ui/react-select": "^2.1.6",
		"@radix-ui/react-slider": "^1.2.3",
		"@radix-ui/react-slot": "^1.1.2",
		"@radix-ui/react-tabs": "^1.1.3",
		"@radix-ui/react-tooltip": "^1.1.8",
		"@tanstack/react-query": "^5.66.10",
		"@types/prismjs": "^1.26.5",
		"axios": "^1.8.1",
		"class-variance-authority": "^0.7.1",
		"clsx": "^2.1.1",
		"cmdk": "^1.0.4",
		"lucide-react": "^0.476.0",
		"next": "15.2.0",
		"prismjs": "^1.29.0",
		"react": "^18.2.0",
		"react-dom": "^18.2.0",
		"react-hook-form": "^7.55.0",
		"tailwind-merge": "^3.0.2",
		"tailwindcss-animate": "^1.0.7",
		"zod": "^3.24.2"
	},
	"devDependencies": {
		"@eslint/eslintrc": "^3",
		"@next/bundle-analyzer": "^15.2.3",
		"@tailwindcss/postcss": "^4",
		"@tailwindcss/typography": "^0.5.16",
		"@types/node": "^20",
		"@types/react": "^18.2.0",
		"@types/react-dom": "^18.2.0",
		"autoprefixer": "^10.4.20",
		"cross-env": "^7.0.3",
		"eslint": "^9",
		"eslint-config-next": "15.2.0",
		"eslint-plugin-react-hooks": "^5.2.0",
		"msw": "^2.2.11",
		"postcss": "^8.5.3",
		"shadcn": "^2.4.0-canary.9",
		"tailwindcss": "^4.0.9",
		"typescript": "^5"
	},
	"optionalDependencies": {
		"@testing-library/jest-dom": "^6.5.1",
		"@testing-library/react": "^15.0.0",
		"@testing-library/user-event": "^14.5.2",
		"@types/jest": "^29.5.12",
		"jest": "^29.7.0",
		"jest-environment-jsdom": "^29.7.0",
		"ts-jest": "^29.1.2",
		"ts-node": "^10.9.2"
	},
	"overrides": {
		"inflight": "npm:lru-cache@^7.14.1"
	}
}
</file>

<file path="frontend/src/lib/api/hooks.ts">
// src/lib/api/hooks.ts
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiClient } from "@/lib/api/client";
import { logApiError } from "@/lib/api/errorUtils";
import type {
	Technique,
	TechniqueFormData,
	Category,
	SubCategory,
	AssuranceGoal,
	APIResponse,
	Tag,
	AttributeType,
	AttributeValue,
	ResourceType,
} from "@/lib/types";

interface QueryParams {
	search?: string;
	assurance_goal?: string;
	assurance_goals?: string | string[];
	category?: string;
	[key: string]: string | string[] | undefined;
}

/**
 * Calculate the total number of pages based on item count and page size
 * 
 * @param totalItems - The total number of items across all pages
 * @param pageSize - The number of items per page (defaults to 20)
 * @returns The total number of pages (minimum 1)
 */
const calculateTotalPages = (
	totalItems: number,
	pageSize: number = 20
): number => {
	return totalItems > 0 ? Math.ceil(totalItems / pageSize) : 1;
};

/**
 * Helper function to try API calls with and without trailing slash
 * 
 * This function attempts to fetch data from an API endpoint, trying both with
 * and without a trailing slash to handle potential server configuration differences.
 * 
 * @param url - The base URL to fetch from
 * @param params - Optional query parameters
 * @returns Promise resolving to the requested data
 * @throws Error if both attempts fail
 */
const fetchAPI = async <T>(
    url: string,
    params?: Record<string, string | number | string[]>
): Promise<T> => {
    // Remove any trailing slash first 
    const urlWithoutSlash = url.endsWith("/") ? url.slice(0, -1) : url;
    const urlWithSlash = urlWithoutSlash + "/";
    
    // Try both URL variants in sequence
    try {
        // Try without trailing slash first
        try {
            const response = await apiClient.get(urlWithoutSlash, { params });
            return response.data as T;
        } catch {
            // If first attempt fails, try with trailing slash
            const response = await apiClient.get(urlWithSlash, { params });
            return response.data as T;
        }
    } catch (error) {
        // This catch will handle any errors from both attempts
        console.error("API request failed with both URL variations:", error);
        throw error;
    }
};

// Base data fetching hooks

/**
 * Hook for fetching assurance goals
 * 
 * @returns Query object with assurance goals data
 */
export const useAssuranceGoals = () => {
	return useQuery({
		queryKey: ["assurance-goals"],
		queryFn: async () => {
			try {
				return await fetchAPI<APIResponse<AssuranceGoal>>('/api/assurance-goals/');
			} catch (error: unknown) {
				logApiError('useAssuranceGoals', error);
				throw error;
			}
		},
		refetchOnWindowFocus: false,
		staleTime: 5 * 60 * 1000, // 5 minutes - this data rarely changes
		retry: 1,
	});
};

/**
 * Hook for fetching categories, optionally filtered by assurance goal
 * 
 * @param assuranceGoalId - Optional ID to filter categories by assurance goal
 * @returns Query object with categories data
 */
export const useCategories = (assuranceGoalId?: number) => {
	// Create params object for axios
	const params: Record<string, string | number> = {};
	if (assuranceGoalId) {
		params.assurance_goal = assuranceGoalId;
	}

	return useQuery({
		queryKey: ["categories", assuranceGoalId],
		queryFn: async () => {
			try {
				return await fetchAPI<APIResponse<Category>>('/api/categories/', params);
			} catch (error: unknown) {
				logApiError('useCategories', error);
				throw error;
			}
		},
		refetchOnWindowFocus: false,
		retry: 1,
	});
};

/**
 * Hook for fetching subcategories for a specific category
 * 
 * @param categoryId - Optional ID to filter subcategories by category
 * @returns Query object with subcategories data
 */
export const useSubCategories = (categoryId?: number) => {
	// Create params object for axios
	const params: Record<string, string | number> = {};
	if (categoryId) {
		params.category = categoryId;
	}

	return useQuery({
		queryKey: ["subcategories", categoryId],
		queryFn: async () => {
			try {
				return await fetchAPI<APIResponse<SubCategory>>('/api/subcategories/', params);
			} catch (error: unknown) {
				logApiError('useSubCategories', error);
				throw error;
			}
		},
		refetchOnWindowFocus: false,
		retry: 1,
		enabled: !!categoryId, // Only run if categoryId is provided
	});
};

/**
 * Hook for fetching all tags
 * 
 * @returns Query object with tags data
 */
export const useTags = () => {
	return useQuery({
		queryKey: ["tags"],
		queryFn: async () => {
			try {
				return await fetchAPI<APIResponse<Tag>>('/api/tags/');
			} catch (error: unknown) {
				logApiError('useTags', error);
				throw error;
			}
		},
		refetchOnWindowFocus: false,
		retry: 1,
	});
};

// New hooks for the flexible attribute system
export const useAttributeTypes = () => {
	return useQuery({
		queryKey: ["attribute-types"],
		queryFn: async () => {
			try {
				return await fetchAPI<APIResponse<AttributeType>>('/api/attribute-types/');
			} catch (error: unknown) {
				logApiError('useAttributeTypes', error);
				throw error;
			}
		},
		refetchOnWindowFocus: false,
		retry: 1,
	});
};

export const useAttributeValues = (attributeTypeId?: number) => {
	// Create params object for axios
	const params: Record<string, string | number> = {};
	if (attributeTypeId) {
		params.attribute_type = attributeTypeId;
	}

	return useQuery({
		queryKey: ["attribute-values", attributeTypeId],
		queryFn: async () => {
			try {
				return await fetchAPI<APIResponse<AttributeValue>>('/api/attribute-values/', params);
			} catch (error: unknown) {
				logApiError('useAttributeValues', error);
				throw error;
			}
		},
		refetchOnWindowFocus: false,
		retry: 1,
		enabled: !!attributeTypeId, // Only run if attributeTypeId is provided
	});
};

// New hooks for the resource system
export const useResourceTypes = () => {
	return useQuery({
		queryKey: ["resource-types"],
		queryFn: async () => {
			try {
				return await fetchAPI<APIResponse<ResourceType>>('/api/resource-types/');
			} catch (error: unknown) {
				logApiError('useResourceTypes', error);
				throw error;
			}
		},
		refetchOnWindowFocus: false,
		retry: 1,
	});
};

/**
 * Hook for fetching techniques with filtering, searching, and pagination
 * 
 * @param params - Query parameters for filtering and searching techniques
 * @param page - Page number for pagination (defaults to 1)
 * @returns Query object with techniques data
 */
export const useTechniques = (params: QueryParams = {}, page: number = 1) => {
	// Filter parameters
	const apiParams: Record<string, string | number | string[]> = { page };

	if (params.search) {
		apiParams.search = params.search;
		// Django REST Framework format for specifying search fields
		apiParams.search_fields = "name"; // Only search in name field
	}

	// Handle assurance_goals as an array
	if (
		params.assurance_goals &&
		Array.isArray(params.assurance_goals) &&
		params.assurance_goals.length > 0
	) {
		// For axios, we need to format this correctly for the backend
		apiParams.assurance_goals = params.assurance_goals;
	} else if (params.assurance_goal && params.assurance_goal !== "all") {
		// Backward compatibility for single goal
		apiParams.assurance_goals = params.assurance_goal;
	}

	if (params.category && params.category !== "all") {
		apiParams.categories = params.category;
	}

	if (params.model_dependency && params.model_dependency !== "all") {
		apiParams.model_dependency = params.model_dependency;
	}

	// Add rating parameters
	if (params.complexity_min) {
		apiParams.complexity_min = params.complexity_min;
	}
	if (params.complexity_max) {
		apiParams.complexity_max = params.complexity_max;
	}
	if (params.computational_cost_min) {
		apiParams.computational_cost_min = params.computational_cost_min;
	}
	if (params.computational_cost_max) {
		apiParams.computational_cost_max = params.computational_cost_max;
	}

	// Create query string
	const queryParams = new URLSearchParams();
	Object.entries(apiParams).forEach(([key, value]) => {
		queryParams.append(key, String(value));
	});

	// Create a more comprehensive query key that captures all filter parameters
	const queryKey = [
		"techniques",
		params.search || "",
		params.search_fields || "",
		// Include all assurance_goals values
		Array.isArray(apiParams.assurance_goals) 
			? apiParams.assurance_goals.join(',') 
			: apiParams.assurance_goals || "all",
		// Include all categories values
		Array.isArray(apiParams.categories)
			? apiParams.categories.join(',')
			: apiParams.categories || "all",
		params.model_dependency || "all",
		// Include rating filters
		params.complexity_min || "1",
		params.complexity_max || "5",
		params.computational_cost_min || "1",
		params.computational_cost_max || "5",
		page,
	];

	return useQuery({
		queryKey: queryKey,
		queryFn: async () => {
			try {
				// Use the apiClient configured with proper baseUrl
				return await fetchAPI("/api/techniques/", apiParams);
			} catch (error: unknown) {
				logApiError("useTechniques", error);
				throw error;
			}
		},
		refetchOnWindowFocus: false,
		staleTime: 60000, // 1 minute stale time
		retry: 1, // Reduce retries to avoid spamming errors
	});
};

export const useTechniqueDetail = (id: number) => {
	return useQuery({
		queryKey: ["technique", id],
		queryFn: async () => {
			try {
				
				try {
					// Try without trailing slash first
					const response = await apiClient.get(`/api/techniques/${id}`);
					const data = response.data;
					
					// Validate and log the response

					// Check if the data has the expected structure
					if (!data.id || !data.name) {
						throw new Error(`API returned malformed data`);
					}

					return data as Technique;
				} catch {
					// Try with trailing slash as fallback
					const response = await apiClient.get(`/api/techniques/${id}/`);
					const data = response.data;
					
					// Validate and log the response

					// Check if the data has the expected structure
					if (!data.id || !data.name) {
						throw new Error(`API returned malformed data`);
					}

					return data as Technique;
				}
			} catch (error: unknown) {
				logApiError('useTechniqueDetail', error);
				throw error;
			}
		},
		enabled: !!id, // Only run if id is provided
		refetchOnWindowFocus: false,
		retry: 1,
	});
};

export const useCreateTechnique = () => {
	const queryClient = useQueryClient();

	return useMutation({
		mutationFn: async (data: TechniqueFormData) => {
			try {
				
				try {
					// Try without trailing slash first
					const response = await apiClient.post(`/api/techniques`, data);
					return response.data as Technique;
				} catch {
					// Try with trailing slash as fallback
					const response = await apiClient.post(`/api/techniques/`, data);
					return response.data as Technique;
				}
			} catch (error: unknown) {
				logApiError('useCreateTechnique', error);
				throw error;
			}
		},
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: ["techniques"] });
		},
	});
};

export const useUpdateTechnique = (id: number) => {
	const queryClient = useQueryClient();

	return useMutation({
		mutationFn: async (data: TechniqueFormData) => {
			try {
				
				try {
					// Try without trailing slash first
					const response = await apiClient.put(`/api/techniques/${id}`, data);
					return response.data as Technique;
				} catch {
					// Try with trailing slash as fallback
					const response = await apiClient.put(`/api/techniques/${id}/`, data);
					return response.data as Technique;
				}
			} catch (error: unknown) {
				logApiError('useUpdateTechnique', error);
				throw error;
			}
		},
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: ["techniques"] });
			queryClient.invalidateQueries({ queryKey: ["technique", id] });
		},
	});
};

export const useDeleteTechnique = () => {
	const queryClient = useQueryClient();

	return useMutation({
		mutationFn: async (id: number) => {
			try {
				
				try {
					// Try without trailing slash first
					await apiClient.delete(`/api/techniques/${id}`);
					return id;
				} catch {
					// Try with trailing slash as fallback
					await apiClient.delete(`/api/techniques/${id}/`);
					return id;
				}
			} catch (error: unknown) {
				logApiError('useDeleteTechnique', error);
				throw error;
			}
		},
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: ["techniques"] });
		},
	});
};

// Relationship hooks
export const useTechniqueRelationships = (techniqueId: number) => {
	// Create params object for axios
	const params: Record<string, string | number> = {};
	if (techniqueId) {
		params.technique_from = techniqueId;
	}

	return useQuery({
		queryKey: ["technique-relationships", techniqueId],
		queryFn: async () => {
			try {
				return await fetchAPI('/api/technique-relationships/', params);
			} catch (error: unknown) {
				logApiError('useTechniqueRelationships', error);
				throw error;
			}
		},
		refetchOnWindowFocus: false,
		retry: 1,
		enabled: !!techniqueId, // Only run if techniqueId is provided
	});
};

// Export the utility functions for use in components
export { calculateTotalPages };
</file>

</files>
